@q cnnctcli.web @>
@q [...]/optinum/Installer/dbsrvcli/src/cnnctcli.web  @>

@q Created by Laurence D. Finston (LDF) Tue Sep 29 10:53:27 CEST 2009  @>

@q * (1) Top @>

@q * (1) Copyright and License.@>

@q This file is part of the OptiNum Grid Installer @>
@q Copyright (C) 2010, 2011, 2012, 2013 Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen @>

@q The OptiNum Grid Installer is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q The OptiNum Grid Installer is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License          @>
@q along with the OptiNum Grid Installer; if not, write to the Free Software                    @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gwdg.de@>

@q Laurence D. Finston                                                   @>
@q Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen  @>
@q Am Fassberg 11         					         @>
@q 37077 Goettingen              					 @>
@q Germany                           					 @>                                

@q Laurence.Finston@@gwdg.de (@@ stands for a single "at" sign.)@>


@q * (0) Client Connection Functions (cnnctcli.web).  @>

@*  Client Connection Functions (cnnctcli\PERIOD web).

@ Version control identifier.
@<Version control identifier@>=
static char version_control_id[] 
   = "$Id: cnnctcli.web 8419 2012-09-21 15:05:36Z finston $";
  
@q ** (2) Include files  @>

@ Include files.

@<Include files@>=

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <getopt.h> 
#include <time.h>
#include <math.h>
#include <pwd.h>

#include <gnutls/gnutls.h>

#include <gnutls/x509.h>

#include <pthread.h>

#include <fstream>
#include <iomanip>
#include <ios>
#include <iostream>
#include <map>
#include <sstream>   
#include <string>
#include <set>
#include <vector>
#include <deque>

#if HAVE_CONFIG_H
# include <config.h>
#endif

#if IS_ROCKS_GOEGRID
#undef HAVE_LIBMYSQLCLIENT
#endif 

#if HAVE_LIBMYSQLCLIENT
#include <mysql.h>
#endif 

#include "ex_rfc2818.h++"
#include "dstngnmt.h++"
#include "x509cert.h++"
#include "rspnstp.h++"
#include "entries.h++"
#include "glblvrbl.h++"
#include "glblfncs.h++"
#include "cmdlnopt.h++"
#include "gntlsfnc.h++"
#include "helper.h++"

#include "parser.h++"
#include "scanner.h++"

#include "prsrclnt.h++"
#include "scnrclnt.h++"

#include "glsinftp.h++"
#include "scprpmtp.h++"

#include "instllfn.h++"
#include "dhprxcrt.h++"

#include "utilfncs.h++"

#ifndef _XOPEN_SOURCE
#define _XOPEN_SOURCE
#endif 


@q ** (2) External function declarations.  @>

@ External function declarations.  

@<External function declarations@>=
int 
zzparse(yyscan_t parameter);

@q ** (2) Client Connect Authorized (|client_connect_auth|).  @>
@ Client Connect Authorized ({\it client\_connect\_auth\/}).
\initials{LDF 2010.02.09.}

\LOG
\initials{LDF 2010.02.09.}
Added this function.  It contains code formerly in |main| 
for {\bf optdbcli}.

\initials{LDF 2010.04.01.}
Added code for writing to log files.
\ENDLOG

@q *** (3) Declaration  @>
@
@<|client_connect_auth| declaration @>=

int
client_connect_auth(void);

@q *** (3) @>
@
@<|client_connect_auth| definition@>=

int
client_connect_auth(void)
{
@q **** (4) @>

  bool DEBUG = true;  /* |false|  */
  set_debug_level(DEBUG);

  stringstream temp_strm;

  int status = 0;

  if (DEBUG)
  {
     lock_cerr_mutex(); 
     cerr << "*** Entering `client_connect_auth'."
          << endl;
     unlock_cerr_mutex(); 

  }  /* |if (DEBUG)|  */   

@q **** (4) @>
@
\LOG
\initials{LDF 2012.03.28.}
Added this section.
\ENDLOG

@<|client_connect_auth| definition@>=

  ifstream grid_mapfile_strm;

  grid_mapfile_strm.open(grid_mapfile_filename.c_str());

  if (!grid_mapfile_strm.is_open())
  {

     temp_strm.str("");

     temp_strm << "ERROR!  In `client_connect_auth':  "
               << "Failed to open grid-mapfile:  `" << grid_mapfile_filename << "'."
               << endl
               << "Exiting function unsuccessfully "
               << "with return value 1."
               << endl;

     lock_cerr_mutex(); 
     cerr << temp_strm.str();
     unlock_cerr_mutex(); 
 
     log_strm << temp_strm.str();
     err_log_strm << temp_strm.str();

     ++errors_occurred;

     return 1;

  }  /* |if (!grid_mapfile_strm.is_open())|  */

  else if (DEBUG)
  {
     lock_cerr_mutex();
     cerr << "In `client_connect_auth':  "
          << "Opened grid-mapfile  `" << grid_mapfile_filename << "' successfully."
          << endl;
     unlock_cerr_mutex();

  }  /* |else if (DEBUG)|  */

  char curr_line[512];  /* 512 characters ought to be enough.  \initials{LDF 2010.04.22.}  */
  Distinguished_Name_Type curr_distinguished_name;

  string::size_type s;

  string curr_user_name;

  string keyword;
  string value;
  string dn;

@q ***** (5) @>
@
@<|client_connect_auth| definition@>=

  while (grid_mapfile_strm)
  {

@q ****** (6) @>

       grid_mapfile_strm.getline(curr_line, 512);

       if (strlen(curr_line) == 0)
          break;

       dn = curr_line;

       if (dn.empty())
          continue;

       curr_distinguished_name.set(dn, &curr_user_name);

@q ****** (6) @>

       if (DEBUG)
       {
            lock_cerr_mutex(); 
            cerr << "dn == " << dn 
                 << endl;
            curr_distinguished_name.show();
            cerr << "curr_user_name == " << curr_user_name << endl;
            unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 
 
       dn.erase(0, 1);  /* Remove leading double-quotation mark.  */
 
       s = dn.find("\"");  /* Remove trailing double-quotation mark and user name */

       dn.erase(s);

       dn_username_map[dn] = curr_user_name; 

       curr_distinguished_name.clear();

  }  /* |while|  */


@q **** (4) @>
@
@<|client_connect_auth| definition@>=

  gnutls_certificate_credentials_t xcred;
  gnutls_session_t session;
  int ret, sd, ii;

  const char *err;

  int char_ctr = 0;

  Scan_Parse_Parameter_Type param;

  string curr_key_filename  = DEFAULT_KEY_FILENAME;
  string curr_cert_filename = DEFAULT_CERT_FILENAME;
  string curr_ca_filename   = DEFAULT_CA_FILENAME;
  string curr_crl_filename  = DEFAULT_CRL_FILENAME;

  status = set_cert_files(curr_key_filename,
                          curr_cert_filename,
                          curr_ca_filename, 
                          curr_crl_filename);  

  if (status)
  {

     temp_strm.str("");

     temp_strm << "ERROR!  In `client_connect_auth':  "
               << "`set_cert_files' failed, returning " << status
               << endl
               << "Exiting function unsuccessfully "
               << "with return value 1."
               << endl;

     lock_cerr_mutex(); 
     cerr << temp_strm.str();
     unlock_cerr_mutex(); 
 
     log_strm << temp_strm.str();
     err_log_strm << temp_strm.str();

     ++errors_occurred;

     return 1;

  }  /* |if (status)|  */

  else if (DEBUG)
  {
     temp_strm << "In `client_connect_auth':  "
               << "`set_cert_files' succeeded, returning " << status
               << endl;

     lock_cerr_mutex(); 
     cerr << temp_strm.str();
     unlock_cerr_mutex(); 
 
     log_strm << temp_strm.str();

     temp_strm.str("");

  }  /* |else if (DEBUG)|  */   

  status = extract_distinguished_name(curr_cert_filename, distinguished_name_str);

@q **** (4) @>
@
@<|client_connect_auth| definition@>=

  gnutls_certificate_allocate_credentials (&xcred);

  status = gnutls_certificate_set_x509_trust_file (xcred, 
                                                   curr_ca_filename.c_str(), 
                                                   GNUTLS_X509_FMT_PEM);   
  if (status < 0)
  {

      temp_strm.str("");

      temp_strm << "ERROR!  In `client_connect_auth':"
           << endl 
           << "`gnutls_certificate_set_x509_trust_file' failed returning " << status 
           << ":" 
           << endl;

      lock_cerr_mutex(); 
      cerr << temp_strm.str();
      gnutls_perror(status);
      unlock_cerr_mutex(); 
 
      log_strm << temp_strm.str();
      err_log_strm << temp_strm.str();

      temp_strm << "Exiting function unsuccessfully "
                << "with return value 1."
                << endl;

      lock_cerr_mutex(); 
      cerr << temp_strm.str();
      unlock_cerr_mutex(); 
 
      log_strm << temp_strm.str();
      err_log_strm << temp_strm.str();

      ++errors_occurred;

      return 1;

  }
  else if (DEBUG)
  {
      temp_strm.str("");


      temp_strm << "In `client_connect_auth':"
                << endl 
                << "`gnutls_certificate_set_x509_trust_file' returned " << status 
                << " (the number of certificates processed)."
                << endl;

       
      lock_cerr_mutex(); 
      cerr << temp_strm.str();
      unlock_cerr_mutex(); 
 
      log_strm << temp_strm.str();

  }  /* |if (DEBUG)|  */ 
  

@q **** (4) @>

  gnutls_certificate_set_x509_key_file (xcred, 
                                        curr_cert_filename.c_str(), 
                                        curr_key_filename.c_str(),
  					GNUTLS_X509_FMT_PEM);

  
  gnutls_init(&session, GNUTLS_CLIENT);  /* Initialize TLS session   */

  ret = gnutls_priority_set_direct(session, "PERFORMANCE", &err); 

  if (ret < 0)   
  {

      if (ret == GNUTLS_E_INVALID_REQUEST) 
      {

          temp_strm.str("");

          temp_strm <<  "ERROR!  In `client_connect_auth':  Syntax error at " 
                    << err 
                    << endl
                    << "Exiting function unsuccessfully "
                    << "with return value 1."
                    << endl;

          lock_cerr_mutex(); 
          cerr << temp_strm.str();
          unlock_cerr_mutex(); 
 
          log_strm << temp_strm.str();
          err_log_strm << temp_strm.str();

          ++errors_occurred;
 
          gnutls_deinit (session);    

          return 1;

      }

      /* !! TODO:  What about other cases?  LDF 2010.02.11.*/

  }  /* |if (ret < 0) |  */

@q **** (4) @>

  /* put the x509 credentials to the current session   */

  status = gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, xcred);

  if (status != 0)
  {
      temp_strm.str("");

      temp_strm <<  "ERROR!  In `client_connect_auth':  `gnutls_credentials_set' failed, " 
                << "returning " << status
                << endl
                << "Exiting function unsuccessfully "
                << "with return value 1."
                << endl;

      lock_cerr_mutex(); 
      cerr << temp_strm.str();
      unlock_cerr_mutex(); 
 
      log_strm << temp_strm.str();
      err_log_strm << temp_strm.str();

      ++errors_occurred;
 
      gnutls_deinit (session);    

      return 1;

  }  /* |if (status != 0)| */

  else if (DEBUG)
  {

      lock_cerr_mutex(); 
      cerr << "In `client_connect_auth':  `gnutls_credentials_set' succeeded."
           << endl;
      unlock_cerr_mutex(); 

  }  /* |else if (DEBUG)|  */ 

@q **** (4) Connect to the peer.  @>
@ Connect to the peer.

\LOG
\initials{LDF 2009.12.15.}
Now calling |tcp_connect| with the arguments |string server_ip_address| 
and |string port_str_auth|.
\ENDLOG 

@<|client_connect_auth| definition@>=

  sd = tcp_connect (server_ip_address, port_str_auth);

  if (sd == -1)
  {

      temp_strm.str("");

      temp_strm <<  "ERROR!  In `client_connect_auth':  "
                << "`tcp_connect' failed, returning " << sd 
                << endl
                << "Exiting function unsuccessfully "
                << "with return value 1."
                << endl;


      lock_cerr_mutex(); 
      cerr << temp_strm.str();
      unlock_cerr_mutex(); 
 
      log_strm << temp_strm.str();
      err_log_strm << temp_strm.str();

      ++errors_occurred;

      gnutls_deinit (session);

      gnutls_certificate_free_credentials (xcred);

      return 1;

  }

@q **** (4) @>
@
\LOG
\initials{LDF 2012.02.02.}
Added call to |reinterpret_cast|.  Formerly, a C-style cast was used.  This function call 
was simply copied from an example in the GNUTLS distribution.
\ENDLOG

@<|client_connect_auth| definition@>=

  gnutls_transport_set_ptr (session, reinterpret_cast<gnutls_transport_ptr_t>(sd));

  /* Perform the TLS handshake   */

  ret = gnutls_handshake (session);

  if (ret < 0)
  {

     temp_strm.str("");
 

     temp_strm << "ERROR!  In `client_connect_auth':  Handshake failed:"
               << endl;

     log_strm << temp_strm.str();
     err_log_strm << temp_strm.str();

     lock_cerr_mutex();
     cerr << temp_strm.str();
     gnutls_perror (ret);
     unlock_cerr_mutex();

     temp_strm.str("");

     temp_strm << "Exiting function unsuccessfully "
               << "with return value 1."
               << endl;

     log_strm << temp_strm.str();
     err_log_strm << temp_strm.str();
  
     lock_cerr_mutex();
     cerr << temp_strm.str();
     unlock_cerr_mutex();

     ++errors_occurred;
  
     gnutls_deinit (session);

     gnutls_certificate_free_credentials (xcred);

     return 1;

  }
  else if (DEBUG)
  {
     cerr << "In `client_connect_auth':  Handshake was completed."
          << endl;
  }

  if (DEBUG)
  {
     lock_cerr_mutex();
     cerr << "In `client_connect_auth':  ***  About to print info:"
          << endl;

     print_info(session);

     cerr << "In `client_connect_auth':  ***  Finished printing info."
          << endl;
     unlock_cerr_mutex();

  }  /* |if (DEBUG)|  */ 


  status = gnutls_record_get_max_size(session);

  if (DEBUG) 
  {
     lock_cerr_mutex(); 
     cerr << "param.MAX_BUFFER == " << param.MAX_BUFFER << endl;
     cerr << "gnutls_record_get_max_size returned " << status << endl;
     unlock_cerr_mutex(); 

  }  /* |if (DEBUG)|  */ 

  if (status < param.MAX_BUFFER)
     param.MAX_BUFFER = status;

@ Verify certificate sent by server.
\initials{LDF 2009.11.30.}

|verify_certificate| is defined in \filename{ex\_rfc2818.web}.
\initials{LDF 2010.08.04.}

@<|client_connect_auth| definition@>=

  if (DEBUG)
  {
      lock_cerr_mutex();
      cerr << "In `client_connect_auth':  ***  About to verify certificate:"
           << endl;
      unlock_cerr_mutex();

  }  /* |if (DEBUG)|  */ 

  status = verify_certificate(session, "");  

@
\LOG
\initials{LDF 2010.04.01.}
Added this section.
\ENDLOG

@<|client_connect_auth| definition@>=


  if (status != 0)
  {
     temp_strm.str("");
 

     temp_strm << "ERROR!  In `client_connect_auth':  Certificate not verified."
               << endl
               << "Exiting function unsuccessfully "
               << "with return value 1."
               << endl;


     log_strm << temp_strm.str();
     err_log_strm << temp_strm.str();

     lock_cerr_mutex();
     cerr << temp_strm.str();
     unlock_cerr_mutex();

     ++errors_occurred;
  
     gnutls_deinit (session);

     gnutls_certificate_free_credentials (xcred);

     return 1;

  }  /* |if (status != 0)|  */

@
@<|client_connect_auth| definition@>=

  else if (DEBUG)
  {
     lock_cerr_mutex();
     cerr << "In `client_connect_auth':  ***  Finished verifying certificate."
          << endl;
     unlock_cerr_mutex();

  }  /* |if (DEBUG)|  */ 

@q **** (4) Break if server rejects client's certificate.  @>

@ Break if server rejects client's certificate.  

\LOG
\initials{LDF 2010.03.26.}
Added this section.

\initials{LDF 2010.03.30.}
Now writing error message to logs.
\ENDLOG

@<|client_connect_auth| definition@>=

  status = gnutls_record_get_max_size(session);

  if (DEBUG)
  {
      cerr << "param.MAX_BUFFER == " << param.MAX_BUFFER << endl;
      cerr << "gnutls_record_get_max_size returned " << status << endl;

  }  /* |if (DEBUG)|  */ 


  if (status < param.MAX_BUFFER)
     param.MAX_BUFFER = status;
  

  char buffer[param.MAX_BUFFER + 1];



  memset(buffer, 0, param.MAX_BUFFER + 1);

  status = gnutls_record_recv (session, buffer, param.MAX_BUFFER);

  if (DEBUG)
  {
      lock_cerr_mutex(); 
      cerr << "In `client_connect_auth':  `gnutls_record_recv' returned " 
           << status << endl;
      unlock_cerr_mutex(); 

  }  /* |if (DEBUG)|  */ 

  if (status < 0)
  {
       temp_strm.str("");

       temp_strm << "ERROR!  In `client_connect_auth':  "
            << "`gnutls_record_recv' failed, returning " << status << ":"
            << endl;

       lock_cerr_mutex();
       cerr << temp_strm.str();
       gnutls_perror(status);
       unlock_cerr_mutex();

       log_strm << temp_strm.str();
       err_log_strm << temp_strm.str();

       temp_strm.str("");

       temp_strm << "Exiting function unsuccessfully "
                 << "with return value 1."
                 << endl;

       lock_cerr_mutex();
       cerr << temp_strm.str();
       gnutls_perror(status);
       unlock_cerr_mutex();

       log_strm << temp_strm.str();
       err_log_strm << temp_strm.str();

       temp_strm.str("");

       if (status == GNUTLS_E_FATAL_ALERT_RECEIVED)
       { 
          gnutls_alert_description_t alert;
          const char *err_1;
          alert = gnutls_alert_get (session);
          err_1 = gnutls_alert_get_name (alert);
          if (err_1)
            temp_strm << "Fatal alert:  " << err_1 << endl;
          else
            temp_strm << "No alert:  " << err_1 << endl;

          lock_cerr_mutex();
          cerr << temp_strm.str();
          gnutls_perror(status);
          unlock_cerr_mutex();

          log_strm << temp_strm.str();
          err_log_strm << temp_strm.str();

       }    

       ++errors_occurred;

       gnutls_bye (session, GNUTLS_SHUT_WR);

       gnutls_deinit (session);

       gnutls_certificate_free_credentials (xcred);
 
       return 1;

  }  /* |if (status < 0)|  */
  
@q **** (4) @>
@
\LOG
\initials{LDF 2010.04.12.}
Consolidated the code for sending the initial input to the server.  Formerly,
there were two separate loops, depending on whether the input came from a file or 
standard input.

\initials{LDF 2010.05.31.}
Added error handling for the case that |file_strm| can't be opened, e.g., if
the file |input_filename| doesn't exist.
\ENDLOG 

@<|client_connect_auth| definition@>=

  char_ctr = 0;

  ifstream file_strm;

  bool read_from_file = (input_filename == "") ? false : true;

  bool sent_data = false;

  if (read_from_file)
  {
     file_strm.open(input_filename.c_str());

     if (!(file_strm && file_strm.is_open()))
     {
         temp_strm << "ERROR!  In `client_connect_auth':  Input file isn't open."
                   << endl 
                   << "Exiting function unsuccessfully "
                   << "with return value 1."
                   << endl;

         lock_cerr_mutex(); 
         cerr << temp_strm.str();
         unlock_cerr_mutex(); 
 
         log_strm << temp_strm.str();
         err_log_strm << temp_strm.str();

         ++errors_occurred;

         return 1;


     }  /* |if (!(file_strm && file_strm.is_open()))|  */

  }  /* |if (read_from_file)|  */

  bool first_time = true;


@q **** (4) @>
@

\LOG
\initials{LDF 2010.07.01.}
Removed code for sending a command for setting the ``effective user'' to server.
I have also removed the code for the command-line option \.{--effective-user-dn} 
from |process_command_line_options| in \filename{cmdlnopt.web}.
It didn't work, because if it's used, a command for setting the effective user 
must be sent to the server before the input is read.  The input may come either from a file
or from standard input.  However, the command contained fewer characters than |MAX_BUFFER|, 
so the server ``thinks'' the client is finished.  On the other hand, it would not 
be straightforward to put the command onto the front of the the character array |buffer| 
and try to fill it up from the input file or the standard input.  Now, the command for setting the 
effective user must either appear in the input file or it must be passed to \.{optdbcli} 
from the standard input in such a way that it precedes any other commands.  \.{echo} and \.{cat} 
are used in the web application to do this, and ``\<space>\.{END}'' is additionally 
placed after the contents of the input file.
\ENDLOG 

@<|client_connect_auth| definition@>=


  int flags = fcntl(STDIN_FILENO, F_GETFL);  /* Set |stdin| to non-blocking.
                                                \initials{LDF 2011.10.04.}  */

  fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK);

  char c;

  for(;;)
  {
@q ***** (5) @>

      memset (buffer, 0, param.MAX_BUFFER + 1);

      if (read_from_file)
      {
          if (!file_strm || file_strm.eof())
             break;

         file_strm.read(buffer, param.MAX_BUFFER);
         char_ctr = file_strm.gcount();
      }

@ Check standard input and read from it, if anything's there.  
\initials{LDF 2011.10.04.}

\LOG
\initials{LDF 2011.10.04.}
Made |stdin| non-blocking here.  This means that \.{optdbcli} no longer waits
for input if there is none.  |stdin| is set to blocking again after the loop.
\ENDLOG 

@<|client_connect_auth| definition@>=

      else 
      {

         c = cin.peek();

         if (DEBUG)
         {
             if (cin)
                 cerr << "cin is true."<< endl;
             else
                cerr << "cin is false."<< endl;

             if (cin.eof())
                 cerr << "cin.eof is true."<< endl;
             else
                cerr << "cin.eof is false."<< endl;

             if (cin.good())
                 cerr << "cin.good is true."<< endl;
             else
                cerr << "cin.good is false."<< endl;

             if (cin.bad())
                 cerr << "cin.bad is true."<< endl;
             else
                cerr << "cin.bad is false."<< endl;

             if (cin.fail())
                 cerr << "cin.fail is true."<< endl;
             else
                cerr << "cin.fail is false."<< endl;

         }  /* |if (DEBUG)|  */ 


         if (!cin || cin.bad() || cin.fail())  
            break;

         cin.read(buffer, param.MAX_BUFFER);  /* Read from standard input  */
         char_ctr = cin.gcount();

      }

@
@<|client_connect_auth| definition@>=

      first_time = false;

      if (char_ctr > 0)
         buffer[char_ctr] = '\0';

      if (DEBUG)
      {

          lock_cerr_mutex();
          cerr << "In `client_connect_auth':  Read " << char_ctr 
              << " characters." 
              << endl
              << "buffer == " << endl
              << buffer << endl;
          unlock_cerr_mutex();

      }  /* |if (DEBUG)|  */ 
        

      if (sleep_value > 0)
      {
         if (DEBUG)
         {
             lock_cerr_mutex();
             cerr << "In `client_connect_auth':  Going to sleep for " 
                  << sleep_value 
                  << " seconds."
                  << endl;
             unlock_cerr_mutex();

         }  /* |if (DEBUG)|  */ 

         sleep(sleep_value);

      }

      if (char_ctr > 0)
      {

         status = gnutls_record_send(session, buffer, strlen (buffer));

         if (status < 0)
         {

              temp_strm.str("");

              temp_strm << "ERROR!  In `client_connect_auth':  "
                   << "`gnutls_record_send' failed, returning " 
                   << status << ":"
                   << endl;

              lock_cerr_mutex();       
              cerr << temp_strm.str(); 
              gnutls_perror(status);
              unlock_cerr_mutex();     

              log_strm << temp_strm.str();
              err_log_strm << temp_strm.str();

              temp_strm.str("");

              temp_strm << "Exiting function unsuccessfully "
                        << "with return value 1."
                        << endl;

              log_strm << temp_strm.str();
              err_log_strm << temp_strm.str();

              ++errors_occurred;

              tcp_close (sd);
              gnutls_deinit (session);
              gnutls_certificate_free_credentials (xcred);

              return 1;

          }  /* |if (status < 0)| */

          else 
             sent_data = true;

      }  /* |if (char_ctr > 0)|  */

@q ***** (5) @>

  }  /* |for|  */

  fcntl(STDIN_FILENO, F_SETFL, flags);

@q **** (4) @>
@
@<|client_connect_auth| definition@>=

  if (read_from_file)
     file_strm.close();

  if (char_ctr == param.MAX_BUFFER || !sent_data)  /* This should prevent server from blocking
                                                \initials{LDF 2010.01.22.}  */
                                   
  {
      
      memset (buffer, 0, param.MAX_BUFFER + 1);
      buffer[0] = EOF;
      gnutls_record_send(session, buffer, 1);  /* Don't bother checking return value.
                                                  \initials{LDF 2010.01.22.}  */  

  }  /* |if (char_ctr == param.MAX_BUFFER)| */
  
@q ***** (5) Get response from server.  @>

@ Get response from server.  
\initials{LDF 2009.12.18.}

If the client sends data back to the server in response to a request 
from the server, this is where we start  the procedure again.
\initials{LDF 2010.01.11.}

\LOG
\initials{LDF 2010.01.21.}
Moved the code for opening |out_strm| to here.  Previously, the entire 
input was stored in |stringstream temp_strm| and then written from it to
|out_strm| following the loop.  This could have failed for long inputs.

\initials{LDF 2010.02.11.}
Removed code to |exchange_data_with_server|.  Now calling this function here.

\initials{LDF 2012.05.15.}
Now setting |param.PARSER_DEBUG = parser_trace|.
\ENDLOG 

@<|client_connect_auth| definition@>=

   param.PARSER_DEBUG = parser_trace;  /* Set here for |zzparse| (authenticated connection)
                                          \initials{LDF 2010.05.27.}
                                       */

   set_debug_level(param.PARSER_DEBUG);

   param.thread_ctr   = 0;
   param.session = &session;
   param.fd = sd;
   param.cert_cred_ptr = &xcred;
   param.anon_server_cred_ptr = 0;
   param.anon_client_cred_ptr = 0;

  if (!session_id.empty())
     param.session_id = session_id;

#if 1 /* 0 */
bool save_DEBUG = DEBUG;
DEBUG = false; /* |true|  */
#endif 

   if (DEBUG)
   {
     log_strm << "`param.session_id' == " << param.session_id << endl;
     err_log_strm << "`param.session_id' == " << param.session_id << endl;

   }  /* |if (DEBUG)|  */ 


#if 1 /* 0 */
DEBUG = save_DEBUG; 
#endif 



#if 0 
/* These aren't needed at present.  \initials{LDF 2010.01.19.}  */
    param.ca_list       = ca_list;
    param.ca_list_size  = ca_list_size;
#endif 

   status = exchange_data_with_server(param);

   if (status != 0)
   {

       temp_strm.str("");
       
       temp_strm << "ERROR!  (3) In `client_connect_auth':  "
                 << "`exchange_data_with_server' failed, returning " 
                 << status << ":"
                 << endl
                 << "Exiting function unsuccessfully "
                 << "with return value 1."
                 << endl;
       


       lock_cerr_mutex(); 
       cerr << temp_strm.str();
       unlock_cerr_mutex(); 
 
       log_strm << temp_strm.str();
       err_log_strm << temp_strm.str();

       ++errors_occurred;

       tcp_close (sd);
       gnutls_deinit (session);
       gnutls_certificate_free_credentials (xcred);

       return 1;

   }  /* |if (status != 0)|  */

   else if (DEBUG)
   {

       temp_strm.str("");

       temp_strm << "In `client_connect_auth':  "
                 << "`exchange_data_with_server' succeeded."
                 << endl;

       lock_cerr_mutex(); 
       cerr << temp_strm.str();
       unlock_cerr_mutex(); 
 
       log_strm << temp_strm.str();

       temp_strm.str("");

   }  /* |else if (DEBUG)|  */ 

#if 0 
   if (errors.size() > 0)
   {
       
   }  /* |if (errors.size() > 0)|  */
#endif 


@q **** (4) @>
@ 
@<|client_connect_auth| definition@>=

  tcp_close (sd);

  gnutls_deinit (session);

  gnutls_certificate_free_credentials (xcred);

@q **** (4) @>

@ The value of |fetch|, i.e., |true| or |false|, doesn't matter, since nothing
needs to be done either way.
\initials{LDF 2010.02.12.}

\LOG
\initials{LDF 2010.02.12.}
Added this section.
\ENDLOG

@<|client_connect_auth| definition@>=

   if (DEBUG)
   {
      lock_cerr_mutex();
      cerr << "In `client_connect_auth':  ";   

      if (fetch == true) 
          cerr << "`fetch' == `true'." << endl;
      else  
          cerr << "`fetch' == `false'." << endl;
      unlock_cerr_mutex();

   }  /* |if (DEBUG)|  */ 

@q **** (4) Check |install|.  @>

@ Check |install|.  If it's |true|, call |install_packages|.
\initials{LDF 2010.02.12.}

\LOG
\initials{LDF 2010.02.12.}
Added this section.
\ENDLOG

@<|client_connect_auth| definition@>=

   if (install == true)
   {
@q ***** (5) @>   

        if (DEBUG)
        {
           lock_cerr_mutex();
           cerr << "In `client_connect_auth':  "
                << "`install' == `true'.  Calling `install_packages'."
                << endl;

           unlock_cerr_mutex();

        }  /* |if (DEBUG)|  */ 

        status = install_packages(param);

@q ***** (5) @>
@
\LOG
\initials{LDF 2010.07.21.}
Now returning |status| instead of 1.
\ENDLOG 
@<|client_connect_auth| definition@>=

        if (status != 0)
        {

           temp_strm.str("");

           temp_strm << "ERROR!  In `client_connect_auth':  "
                     << "`install_packages' failed, returning " << status << "."
                     << endl
                     << "Exiting function unsuccessfully with return value " 
                     << status << "."
                     << endl;

           lock_cerr_mutex(); 
           cerr << temp_strm.str();
           unlock_cerr_mutex(); 

           log_strm << temp_strm.str();
           err_log_strm << temp_strm.str();

           ++errors_occurred;

           return status;

        }  /* |if (status != 0)|  */

@q ***** (5) @>

        else if (DEBUG)
        {

           temp_strm.str("");

           temp_strm << "In `client_connect_auth':  "
                     << "`install_packages' succeeded."
                     << endl;

           lock_cerr_mutex(); 
           cerr << temp_strm.str();
           unlock_cerr_mutex(); 

           log_strm << temp_strm.str();

           temp_strm.str("");

        }  /* |else if (DEBUG)|  */ 

@q ***** (5) @>

   }  /* |if (install == true)|  */

@q **** (4) @>
@
@<|client_connect_auth| definition@>=
      
   else if (DEBUG)
   {
           temp_strm.str("");

           temp_strm << "In `client_connect_auth':  "
                     << "`install' == `false'.  Not calling `install_packages'."
                     << endl;

           lock_cerr_mutex(); 
           cerr << temp_strm.str();
           unlock_cerr_mutex(); 

           log_strm << temp_strm.str();

           temp_strm.str("");

   }  /* |else if (DEBUG)|  */ 

@q **** (4) Exit |client_connect_auth| successfully.  @>

@ Exit |client_connect_auth| successfully.  
\initials{LDF 2009.12.08.}

@<|client_connect_auth| definition@>=

  if (DEBUG)    
  {

           temp_strm.str("");

           temp_strm << "*** Exiting `optdbcli' (`client_connect_auth' function) "
                     << "successfully with exit value 0."
                     << endl;

           lock_cerr_mutex(); 
           cerr << temp_strm.str();
           unlock_cerr_mutex(); 

           log_strm << temp_strm.str();


  }  /* |if DEBUG|  */

  return 0;

} /* End of |client_connect_auth| definition  */

@q ** (2) Client Connect Non-Authorized (|client_connect_non_auth|).  @>
@ Client Connect Authorized ({\it client\_connect\_non\_auth\/}).
\initials{LDF 2010.02.09.}

\LOG
\initials{LDF 2010.02.09.}
Added this function.
\ENDLOG

@q *** (3) Declaration  @>
@
@<|client_connect_non_auth| declaration @>=

int
client_connect_non_auth(void);

@q *** (3) Definition  @>
@
@<|client_connect_non_auth| definition@>=

int
client_connect_non_auth(void)
{
@q **** (4) @>

  bool DEBUG = false;  /* |true|  */
  set_debug_level(DEBUG);

  int status = 0;

  if (DEBUG) 
  {
      lock_cerr_mutex();
      cerr << "*** Entering `client_connect_non_auth'."
           << endl;
      unlock_cerr_mutex();

  }  /* |if (DEBUG)|  */

@q **** (4) @>


  int ret, sd, ii;
  gnutls_session_t session;


  gnutls_anon_client_credentials_t anoncred;
  /* Need to enable anonymous KX specifically. */

  gnutls_anon_allocate_client_credentials (&anoncred);

  /* Initialize TLS session    */

  gnutls_init (&session, GNUTLS_CLIENT);

  /* Use default priorities */
  gnutls_priority_set_direct (session, "PERFORMANCE:+ANON-DH:!ARCFOUR-128", NULL);

  /* put the anonymous credentials to the current session   */

  gnutls_credentials_set (session, GNUTLS_CRD_ANON, anoncred);

@
\LOG
\initials{LDF 2012.02.02.}
Added call to |reinterpret_cast|.  Formerly, a C-style cast was used.  This function call 
was simply copied from an example in the GNUTLS distribution.
\ENDLOG

@<|client_connect_non_auth| definition@>=

  /* connect to the peer   */

  sd = tcp_connect (server_ip_address, port_str_non_auth);

  gnutls_transport_set_ptr (session, reinterpret_cast<gnutls_transport_ptr_t>(sd));


@
@<|client_connect_non_auth| definition@>=

  /* Perform the TLS handshake   */

  ret = gnutls_handshake (session);

  if (ret < 0)
  {

      lock_cerr_mutex(); 
      cerr << "ERROR!  In `client_connect_non_auth':  *** Handshake failed"
           << endl;
      gnutls_perror (ret);
      cerr << "Exiting function unsuccessfully with return value 1."
           << endl;
      unlock_cerr_mutex(); 

      tcp_close (sd);
      gnutls_deinit (session);
      gnutls_anon_free_client_credentials (anoncred);

      return 1;

  }

  else if (DEBUG) 
  {
      lock_cerr_mutex(); 
      cerr << "In `client_connect_non_auth':  Handshake was completed"
           << endl;
      unlock_cerr_mutex(); 

  }  /* |else if (DEBUG)|  */


@q **** (4) Handle proxy credential.  @>

@ Handle proxy credential.
\initials{LDF 2011.05.25.}

\LOG
\initials{LDF 2011.05.25.}
Added this section.
\ENDLOG

@<|client_connect_non_auth| definition@>=

   if (!proxy_cred_filename.empty())
   {

       status = handle_proxy_cred();

       if (status != 0)
       {
           lock_cerr_mutex(); 
           cerr << "ERROR!  In `client_connect_non_auth':  `handle_proxy_cred' failed, "
                << "returning " << status << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           tcp_close (sd);
           gnutls_deinit (session);
           gnutls_anon_free_client_credentials (anoncred);

           return 1;

       }  /* |if (status != 0)|  */

       else if (DEBUG)
       {

           lock_cerr_mutex(); 
           cerr << "In `client_connect_non_auth':  `handle_proxy_cred' succeeded."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */ 

   }  /* |if (!proxy_cred_filename.empty())|  */

@q **** (4) @>
@
\LOG 
\initials{LDF 2012.05.15.}
Now setting |param.PARSER_DEBUG = parser_trace|.
\ENDLOG 

@<|client_connect_non_auth| definition@>=

  Scan_Parse_Parameter_Type param;

  param.PARSER_DEBUG = parser_trace;  /* Set here for |zzparse| (non-authenticated connection)
                                         \initials{LDF 2010.05.27.}
                                      */

  set_debug_level(param.PARSER_DEBUG);

  param.thread_ctr   = 0;
  param.session = &session;
  param.fd = sd;
  param.anon_client_cred_ptr = &anoncred;
  param.anon_server_cred_ptr = 0;
  param.cert_cred_ptr  = 0;

  if (!session_id.empty())
     param.session_id = session_id;

#if 1 /* 0 */
bool save_DEBUG = DEBUG;
DEBUG = false; /* |true|  */
#endif 

   if (DEBUG)
   {
     log_strm << "`param.session_id' == " << param.session_id << endl;
     err_log_strm << "`param.session_id' == " << param.session_id << endl;

   }  /* |if (DEBUG)|  */ 


#if 1 /* 0 */
DEBUG = save_DEBUG; 
#endif 


@q **** (4) Extract Distinguished Name from proxy credential @>
@q **** (4) (if one was passed to `optdbli').                 @>

@ Extract Distinguished Name from proxy credential (if one was 
passed to \.{optdbli}).
\initials{LDF 2011.06.01.}

\LOG
\initials{LDF 2011.06.01.}
Added this section.
\ENDLOG

@<|client_connect_non_auth| definition@>=

  if (!proxy_cred_filename.empty())
  {
@q ***** (5) @>

       string temp_str;
 
       status = extract_distinguished_name(proxy_cred_filename, temp_str, true);

       if (status != 0)
       {
          lock_cerr_mutex();
          cerr << "ERROR!  In `client_connect_non_auth':  "
               << "`extract_distinguished_name' failed, returning " << status << "."
               << endl
               << "Exiting function unsuccessfully "
               << "with return value 1."
               << endl;
          unlock_cerr_mutex();

          tcp_close (sd);
          gnutls_deinit (session);
          gnutls_anon_free_client_credentials (anoncred);

          return 1;

       }  /* |if (status != 0)|  */

       else if (DEBUG) 
           cerr << "`extract_distinguished_name' succeeded." << endl
                << "`temp_str' == " << temp_str << endl;

       if (distinguished_name_str.empty())
       {
           if (DEBUG) 
               cerr << "In `client_connect_non_auth':  Setting "
                    << "`distinguished_name_str'." << endl;

           distinguished_name_str = temp_str;
       }
       else if (distinguished_name_str != temp_str)
       {
           lock_cerr_mutex();
           cerr << "ERROR!  In `client_connect_non_auth':  "
                << "Distinguished Name mismatch!"
                << endl
                << "`distinguished_name_str' == " << distinguished_name_str
                << endl 
                << "Distinguished Name from proxy credential == " 
                << temp_str
                << endl
                << "This isn't permitted."
                << endl 
                << "Exiting function unsuccessfully "
                << "with return value 1."
                << endl;
           unlock_cerr_mutex();

           tcp_close (sd);
           gnutls_deinit (session);
           gnutls_anon_free_client_credentials (anoncred);

           return 1;


       }  /* |else if|  */

       else if (DEBUG) 
           
           cerr << "In `client_connect_non_auth':  Distinguished Names match."  
                << endl;

@q ***** (5) @>

  }  /* |if (!proxy_cred_filename.empty())|  */

@q **** (4) @>

@ Send initial message to server.
\initials{LDF 2010.02.11.}

@<|client_connect_non_auth| definition@>=

  if (distinguished_name_str == "")
  {

      lock_cerr_mutex();
      cerr << "ERROR!  In `client_connect_non_auth':  "
           << "`distinguished_name_str' is empty."
           << endl
           << "Exiting function unsuccessfully "
           << "with return value 1."
           << endl;
      unlock_cerr_mutex();

      tcp_close (sd);
      gnutls_deinit (session);
      gnutls_anon_free_client_credentials (anoncred);

      return 1;

  }  /* |if (distinguished_name_str == "")|  */

  else if (DEBUG) /* |distinguished_name_str != ""|  */
  {

      lock_cerr_mutex();
      cerr << "In `client_connect_non_auth':  "
           << "`distinguished_name_str' == " << distinguished_name_str
           << endl;
      unlock_cerr_mutex();

  }  /* |else if (DEBUG)| (|distinguished_name_str != ""|)  */

  distinguished_name.set(distinguished_name_str);

  if (DEBUG)
  {
     lock_cerr_mutex(); 
     distinguished_name.show("distinguished_name:");
     unlock_cerr_mutex(); 

  }  /* |if (DEBUG)|  */ 

@q **** (4) Check grid-mapfile for Distinguished Name of caller.  @>

@ Check \filename{grid-mapfile} for Distinguished Name of caller.  
\initials{LDF 2010.05.25.}

\LOG
\initials{LDF 2010.05.25.}
Added this section.

\initials{LDF 2010.05.27.}
Commented-out for testing.

\initials{LDF 2011.05.05.}
Commented back in.  This is needed for encrypted entries.
\ENDLOG

@<|client_connect_non_auth| definition@>=

   ifstream grid_mapfile_strm;

   grid_mapfile_strm.open(grid_mapfile_filename.c_str());

   if (!grid_mapfile_strm.is_open())
   {

      lock_cerr_mutex();
      cerr << "ERROR!  In `client_connect_non_auth':  "
           << "Failed to open grid-mapfile:  `" << grid_mapfile_filename << "'."
           << endl
           << "Exiting function unsuccessfully "
           << "with return value 1."
           << endl;
      unlock_cerr_mutex();

      tcp_close (sd);
      gnutls_deinit (session);
      gnutls_anon_free_client_credentials (anoncred);

      return 1;


   }  /* |if (!grid_mapfile_strm.is_open())|  */

   else if (DEBUG)
   {
      lock_cerr_mutex();
      cerr << "In `client_connect_non_auth':  "
           << "Opened grid-mapfile  `" << grid_mapfile_filename << "' successfully."
           << endl;
      unlock_cerr_mutex();

   }  /* |else if (DEBUG)|  */

   struct passwd pwbuf;
    
   char buf[sysconf(_SC_GETPW_R_SIZE_MAX)]; 

   struct passwd *pwbufp;

   status = getpwuid_r(getuid(), &pwbuf,
                   buf, sysconf(_SC_GETPW_R_SIZE_MAX), &pwbufp);

   char curr_line[512];  /* 512 characters ought to be enough.  \initials{LDF 2010.04.22.}  */
   Distinguished_Name_Type curr_distinguished_name;


   string::size_type s;

   string curr_user_name;

   string keyword;
   string value;
   string dn;

   bool found_user = false;

   if (DEBUG)
   {
   lock_cerr_mutex(); 
   cerr << "In `client_connect_non_auth':" << endl 
        << "`getpwuid_r' returned `" << status << "'" << endl
        << "`pwbuf.pw_name' == " << pwbuf.pw_name << endl;
   unlock_cerr_mutex(); 
   }  /* |if (DEBUG)|  */ 

@q **** (4) @>
@
\LOG
\initials{LDF 2011.05.06.}
Now using this loop to fill |dn_username_map|.  It now reads in the whole 
\filename{grid-mapfile}.
\ENDLOG 

@<|client_connect_non_auth| definition@>=

   while (grid_mapfile_strm)
   {

@q ***** (5) @>

       grid_mapfile_strm.getline(curr_line, 512);

       if (strlen(curr_line) == 0)
          break;

       dn = curr_line;

       if (dn.empty())
          continue;

       curr_distinguished_name.set(dn, &curr_user_name);

@q ***** (5) @>

       if (DEBUG)
       {
            lock_cerr_mutex(); 
            cerr << "dn == " << dn 
                 << endl;
            curr_distinguished_name.show();
            cerr << "curr_user_name == " << curr_user_name << endl;
            unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 
 
       dn.erase(0, 1);  /* Remove leading double-quotation mark.  */
 
       s = dn.find("\"");  /* Remove trailing double-quotation mark and user name */

       dn.erase(s);

       dn_username_map[dn] = curr_user_name; 

@q ***** (5) @>

       if (    curr_distinguished_name == distinguished_name 
           &&  !strcmp(curr_user_name.c_str(), pwbuf.pw_name))
       {
            found_user = true;
       }
      

       curr_distinguished_name.clear();

   }  /* |while|  */

   if (!found_user)
   {
      lock_cerr_mutex();
      cerr << "ERROR!  In `client_connect_non_auth':  "
           << "No entry for user `" << pwbuf.pw_name << "' in "
           << "grid-mapfile `" << grid_mapfile_filename << "'."
           << endl;
      distinguished_name.show("distinguished_name:");
  
      cerr << endl
           << "Exiting function unsuccessfully "
           << "with return value 1."
           << endl;
      unlock_cerr_mutex();

      tcp_close (sd);
      gnutls_deinit (session);
      gnutls_anon_free_client_credentials (anoncred);

      return 1;


   }  /* |if (!found_user)|  */

   else if (DEBUG)
   {
      lock_cerr_mutex();
      cerr << "In `client_connect_non_auth':  "
           << "Found entry for user `" << pwbuf.pw_name << "' in "
           << "grid-mapfile `" << grid_mapfile_filename << "'."
           << endl;
      distinguished_name.show("distinguished_name:");
      unlock_cerr_mutex();

   }  /* |else if (DEBUG)|  */ 


@q **** (4) Send Distinguished Name to optdbsrv for validation.  @>
@q **** (4) Also send input file or text from standard input, if present.  @>

@ Send Distinguished Name to optdbsrv for validation.
@q **** (4) Also send input file or text from standard input, if present.  @>
\initials{LDF Date unknown.}
\initials{LDF 2011.10.03.}

\LOG
\initials{LDF 2011.10.03.}
Added code for sending input file or text from standard input, if present.
Previously, this was not possible in this function.  However, if this function
has been called, the user will now have identified himself or herself with a
proxy credential, so it is no longer necessary to prevent him or her from using
certain commands.
\ENDLOG 

@<|client_connect_non_auth| definition@>=


   status = gnutls_record_get_max_size(session);

   if (DEBUG) 
   {
      lock_cerr_mutex(); 
      cerr << "param.MAX_BUFFER == " << param.MAX_BUFFER << endl;
      cerr << "gnutls_record_get_max_size returned " << status << endl;
      unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

   if (status < param.MAX_BUFFER)
      param.MAX_BUFFER = status;


  char buffer[param.MAX_BUFFER + 1];

  memset (buffer, 0, param.MAX_BUFFER + 1);
  strcpy(buffer, "VALIDATE DISTINGUISHED_NAME <");
  strcat(buffer, distinguished_name_str.c_str());
  strcat(buffer, ">");

@q ***** (5) @>
  
  int char_ctr = 0;

  ifstream file_strm;

  stringstream temp_strm;

  bool read_from_file = (input_filename == "") ? false : true;

  bool sent_data = false;

  if (read_from_file)
  {
     file_strm.open(input_filename.c_str());

     if (!(file_strm && file_strm.is_open()))
     {
         temp_strm << "ERROR!  In `client_connect_non_auth':  Input file isn't open."
                   << endl 
                   << "Exiting function unsuccessfully "
                   << "with return value 1."
                   << endl;

         lock_cerr_mutex(); 
         cerr << temp_strm.str();
         unlock_cerr_mutex(); 
 
         log_strm << temp_strm.str();
         err_log_strm << temp_strm.str();

         ++errors_occurred;

         return 1;


     }  /* |if (!(file_strm && file_strm.is_open()))|  */

  }  /* |if (read_from_file)|  */


@q ***** (5) @>

@ Upon the first iteration of the loop, the command for validating the
distinguished name is put at the front of |buffer|, and any other commands from
an input file or standard input are put after it.  If there was more than would
fit into |buffer|, the loop will iterate until all of the input has been sent.
\initials{LDF 2011.10.03.}

@<|client_connect_non_auth| definition@>=

  bool first_time = true;

  char *buffer_ptr = 0;

  int flags = fcntl(STDIN_FILENO, F_GETFL);  /* Set |stdin| to non-blocking.
                                                \initials{LDF 2011.10.03.}  */
  fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK);

  char c;

  for(;;)
  {
@q ****** (6) @>

      if (first_time)
      {
          buffer_ptr = buffer + strlen(buffer);
          char_ctr = strlen(buffer);
      }
      else
         memset (buffer, 0, param.MAX_BUFFER + 1);

@q ****** (6) @>

      if (read_from_file)
      {
          if (!file_strm || file_strm.eof())
             break;

         if (first_time)
         {
            file_strm.read(buffer_ptr, param.MAX_BUFFER - strlen(buffer));
            char_ctr += file_strm.gcount();
         }
         else
         {
            file_strm.read(buffer, param.MAX_BUFFER);
            char_ctr = file_strm.gcount();
         }
      }

@q ****** (6) @>

      else  /* Check standard input and read from it, if anything's there.  
               \initials{LDF 2011.10.03.}  */ 
      {

         c = cin.peek();

         if (DEBUG)
         {
             if (cin)
                 cerr << "cin is true."<< endl;
             else
                cerr << "cin is false."<< endl;

             if (cin.eof())
                 cerr << "cin.eof is true."<< endl;
             else
                cerr << "cin.eof is false."<< endl;

             if (cin.good())
                 cerr << "cin.good is true."<< endl;
             else
                cerr << "cin.good is false."<< endl;

             if (cin.bad())
                 cerr << "cin.bad is true."<< endl;
             else
                cerr << "cin.bad is false."<< endl;

             if (cin.fail())
                 cerr << "cin.fail is true."<< endl;
             else
                cerr << "cin.fail is false."<< endl;

         }  /* |if (DEBUG)|  */ 

         if (!cin || cin.bad() || cin.fail())  
         {
            if (!first_time)
                break;
         }

         else if (first_time)
         {
            cin.read(buffer_ptr, param.MAX_BUFFER - strlen(buffer)); 
            char_ctr += cin.gcount();
         }
         else
         {
            cin.read(buffer, param.MAX_BUFFER);  
            char_ctr = cin.gcount();

         }

      }  /* |else| (|!read_from_file|)  */

@q ****** (6) @>

      if (char_ctr > 0)
         buffer[char_ctr] = '\0';

      if (DEBUG)
      {
          lock_cerr_mutex();
          cerr << "In `client_connect_non_auth':  Read " << char_ctr 
              << " characters." 
              << endl
              << "buffer == " << endl
              << buffer << endl;
          unlock_cerr_mutex();

      }  /* |if (DEBUG)|  */ 

      if (sleep_value > 0)
      {
         if (DEBUG)
         {
             lock_cerr_mutex();
             cerr << "In `client_connect_non_auth':  Going to sleep for " 
                  << sleep_value 
                  << " seconds."
                  << endl;
             unlock_cerr_mutex();

         }  /* |if (DEBUG)|  */ 

         sleep(sleep_value);

      }

@q ****** (6) @>

      if (char_ctr > 0)
      {

         status = gnutls_record_send(session, buffer, strlen (buffer));

         if (status < 0)
         {

              temp_strm.str("");

              temp_strm << "ERROR!  In `client_connect_non_auth':  "
                   << "`gnutls_record_send' failed, returning " 
                   << status << ":"
                   << endl;

              lock_cerr_mutex();       
              cerr << temp_strm.str(); 
              gnutls_perror(status);
              unlock_cerr_mutex();     

              log_strm << temp_strm.str();
              err_log_strm << temp_strm.str();

              temp_strm.str("");

              temp_strm << "Exiting function unsuccessfully "
                        << "with return value 1."
                        << endl;

              log_strm << temp_strm.str();
              err_log_strm << temp_strm.str();

              ++errors_occurred;

              tcp_close (sd);
              gnutls_deinit (session);
              gnutls_anon_free_client_credentials (anoncred);

              return 1;

          }  /* |if (status < 0)| */

          else 
          {
             if (DEBUG) 
                cerr << "Send succeeded." << endl;

             sent_data = true;
          }


      }  /* |if (char_ctr > 0)|  */

      first_time = false;
      buffer_ptr = 0;

@q ****** (6) @>

  }  /* |for|  */

  fcntl(STDIN_FILENO, F_SETFL, flags);   /* Set |stdin| back to blocking again.
                                            \initials{LDF 2011.10.03.}  */


@q **** (4) @>
@
@<|client_connect_non_auth| definition@>=

  if (read_from_file)
     file_strm.close();

  if (char_ctr == param.MAX_BUFFER || !sent_data)  /* This should prevent server from blocking
                                                \initials{LDF 2010.01.22.}  */
                                   
  {
      
      memset (buffer, 0, param.MAX_BUFFER + 1);
      buffer[0] = EOF;
      gnutls_record_send(session, buffer, 1);  /* Don't bother checking return value.
                                                  \initials{LDF 2010.01.22.}  */  

  }  /* |if (char_ctr == param.MAX_BUFFER)| */

@q **** (4) @>
@
@<|client_connect_non_auth| definition@>=

  status = exchange_data_with_server(param);

  if (status != 0)
  {
      lock_cerr_mutex();
      cerr << "ERROR!  In `client_connect_non_auth':  "
           << "`exchange_data_with_server' failed, returning " 
           << status << ":"
           << endl
           << "Exiting function unsuccessfully "
           << "with return value 1."
           << endl;
      unlock_cerr_mutex();

      tcp_close (sd);
      gnutls_deinit (session);
      gnutls_anon_free_client_credentials (anoncred);

      return 1;

  }  /* |if (status != 0)|  */

   else if (DEBUG)
   {

       lock_cerr_mutex();
       cerr << "In `client_connect_non_auth':  "
            << "`exchange_data_with_server' succeeded."
            << endl;
       unlock_cerr_mutex();

   }  /* |else if (DEBUG)|  */ 

@q **** (4) @>
@
@<|client_connect_non_auth| definition@>=

   tcp_close (sd);
   gnutls_deinit (session);
   gnutls_anon_free_client_credentials (anoncred);

@q **** (4) @>
@
@<|client_connect_non_auth| definition@>=

   if (install == true)
   {
@q ***** (5) @>   

        if (DEBUG)
        {
           lock_cerr_mutex();
           cerr << "In `client_connect_non_auth':  "
                << "`install' == `true'.  Calling `install_packages'."
                << endl;
           unlock_cerr_mutex();

        }  /* |if (DEBUG)|  */ 

        status = install_packages(param);

@q ***** (5) @>

        if (status != 0)
        {

           lock_cerr_mutex();
           cerr << "ERROR!  In `client_connect_non_auth':  "
                << "`install_packages' failed, returning " << status << "."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex();

           return 1;

        }  /* |if (status != 0)|  */

@q ***** (5) @>

        else if (DEBUG)
        {
           lock_cerr_mutex();
           cerr << "In `client_connect_non_auth':  "
                << "`install_packages' succeeded."
                << endl;
           unlock_cerr_mutex();

        }  /* |else if (DEBUG)|  */ 

@q ***** (5) @>

   }  /* |if (install == true)|  */

@q **** (4) @>
@
@<|client_connect_non_auth| definition@>=
      
   else if (DEBUG)
   {
       lock_cerr_mutex();
       cerr << "In `client_connect_non_auth':  "
            << "`install' == `false'.  Not calling `install_packages'."
            << endl;
       unlock_cerr_mutex();


   }  /* |else if (DEBUG)|  */ 

@q **** (4) @>
@
@<|client_connect_non_auth| definition@>=


  if (DEBUG) 
  {
      lock_cerr_mutex();
      cerr << "*** Exiting `client_connect_non_auth' successfully with return value 0."
           << endl;
      unlock_cerr_mutex();

  }  /* |if (DEBUG)|  */


  return 0;

}  /* End of |client_connect_non_auth| definition  */

@q ** (2) Exchange data with server.  @>
@ Exchange data with server.
\initials{LDF 2010.02.11.}

\LOG
\initials{LDF 2010.02.11.}
Added this function.
\ENDLOG

@q *** (3) Declaration  @>
@
@<|exchange_data_with_server| declaration@>=
int
exchange_data_with_server(Scan_Parse_Parameter_Type& param);

@q *** (3) Definition @>
@
@<|exchange_data_with_server| definition@>=
int
exchange_data_with_server(Scan_Parse_Parameter_Type& param)
{

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    int loop_ctr = 0;

    ofstream out_strm;

    yyscan_t parameter;

    Response_Type response;

    char temp_filename[14];

    memset(temp_filename, 0, 14);

    FILE *fp = 0;

    int fd = 0;

    char buffer[param.MAX_BUFFER + 1];

    int status = 0;

    stringstream temp_strm;

@q **** (4) @>
@
@<|exchange_data_with_server| definition@>=

    YY_BUFFER_STATE zz_buffer_state;

    bool wrote_data_to_out_strm;
  
    char c = 0;

  
READ_SERVER_DATA:

@q ***** (5) @>
@ 
@<|exchange_data_with_server| definition@>=

    wrote_data_to_out_strm = false;

@q **** (4) @>
@
@<|exchange_data_with_server| definition@>=

  for(;;)
  {
@q ***** (5) @>

     memset (buffer, 0, param.MAX_BUFFER + 1);

     status = gnutls_record_recv(*param.session, buffer, param.MAX_BUFFER);

     if (status == 0)
     {

       temp_strm.str(""); 
       
       temp_strm << "In `exchange_data_with_server':  Peer has closed the TLS connection" 
                 << endl
                 << "Exiting function successfully with return value 0."
                 << endl;

       lock_cerr_mutex();
       cerr << temp_strm.str();
       unlock_cerr_mutex();

       gnutls_bye (*param.session, GNUTLS_SHUT_WR);

       return 0;

     }

@q ***** (5) @>

     else if (status < 0)
     {

       temp_strm.str(""); 

       temp_strm << "ERROR:  In |exchange_data_with_server|:  "
                 << endl 
                 << gnutls_strerror (status)
                 << endl
                 << "Exiting function unsuccessfully "
                 << "with return value 1."
                 << endl;

       lock_cerr_mutex();
       cerr << temp_strm.str();
       unlock_cerr_mutex();

       err_log_strm << temp_strm.str();
       log_strm << temp_strm.str();

       ++errors_occurred;

       gnutls_bye (*param.session, GNUTLS_SHUT_WR);

       return 1;

     }

@q ***** (5) @>

     else if (status > 0)
     {
@q ****** (6) @>

         if (DEBUG) 
         {
            lock_cerr_mutex();
            cerr << "In `exchange_data_with_server':  Received " << status << " bytes "
                 << endl
                 << "`buffer' == " << buffer
                 << endl;
            unlock_cerr_mutex();

         }  /* |if (DEBUG)|  */

@q ****** (6) @>

         if (status ==  param.MAX_BUFFER)
         {
@q ******* (7) @>
@
\LOG
\initials{LDF 2010.04.07.}
Now creating temporary file in \.{/tmp/}.

\initials{LDF 2010.04.09.}
Now only using a temporary file if the input exceeds the size of |buffer|.
This will probably never happen.

\initials{LDF 2010.04.12.}
Moved this code.  Formerly, |mkstemp| was called above, outside the |for| loop.  
Now, it's only called if a temporary file is needed.
\ENDLOG

@<|exchange_data_with_server| definition@>=

            if (!wrote_data_to_out_strm)
            {
@q ******** (8) @>

               if (temp_filename[0] == 0)
               {
@q ********* (9) @>

                   strcpy(temp_filename, "/tmp/AAXXXXXX");

                   fd = mkstemp(temp_filename);

@q ********* (9) @>

                   if (fd == -1)
                   {
@q ********** (10) @>
                       temp_strm.str("");

                       temp_strm << "ERROR!  In `exchange_data_with_server':  "
                                 << "`mkstemp' failed, returning -1:"
                                 << endl;

                       lock_cerr_mutex();
                       cerr << temp_strm.str();
                       perror("Error:");
                       unlock_cerr_mutex();

                       err_log_strm << temp_strm.str();
                       log_strm << temp_strm.str();

                       temp_strm.str(""); 

                       temp_strm << "Exiting function unsuccessfully "
                                 << "with return value 1."
                                 << endl;

                       lock_cerr_mutex();
                       cerr << temp_strm.str();
                       unlock_cerr_mutex();

                       err_log_strm << temp_strm.str();
                       log_strm << temp_strm.str();

                       ++errors_occurred;

                       gnutls_bye (*param.session, GNUTLS_SHUT_WR);

                       return 1;

@q ********** (10) @>

                   }   /* |if (fd == -1)| (|mkstemp| failed)  */

@q ********* (9) @>

@ Close the file descriptor.  We don't need it, we just need the name.  
This is a somewhat roundabout way of doing things, but the functions for generating 
a unique filename only are deprecated and we want to open a {\CPLUSPLUS/} output 
file stream (|ofstream|).
\initials{LDF 2009.10.05.}

@<|exchange_data_with_server| definition@>=

                   close(fd);

               }  /* |if (temp_filename[0] == 0)|  */

@q ******** (8) @>

               out_strm.open(temp_filename);                    
        
               if (!out_strm)
               {
                   lock_cerr_mutex();
                   cerr << "ERROR!  In `exchange_data_with_server':  Failed to open output stream."
                        << endl
                        << "Exiting function unsuccessfully "
                        << "with return value 1."
                        << endl;
                   unlock_cerr_mutex();

                   gnutls_bye (*param.session, GNUTLS_SHUT_WR);

                   return 1;

               }  /* |if (!out_strm)|  */

               wrote_data_to_out_strm = true;

@q ******** (8) @>

            }  /* |if (!wrote_data_to_out_strm)|  */

            if (DEBUG)
            {
               lock_cerr_mutex();
               cerr << "In `exchange_data_with_server':  `status' == `param.MAX_BUFFER'.  "
                    << "Writing to `out_strm'." 
                    << endl;
               unlock_cerr_mutex();

            }  /* |if (DEBUG)|  */ 

            out_strm << buffer;

@q ******* (7) @>

         }  /* |if (status == param.MAX_BUFFER)|  */

@q ****** (6) @>

         else if (status < param.MAX_BUFFER)
         {

            if (wrote_data_to_out_strm)  
               out_strm << buffer;
 
            /* Otherwise, we just read directly from |buffer|.
               \initials{LDF 2010.04.09.}  */

            if (DEBUG)
            {
               lock_cerr_mutex();
               cerr << "In `exchange_data_with_server':  `status' < `param.MAX_BUFFER'.  "
                    << "No more data.  Breaking." 
                    << endl;
               unlock_cerr_mutex();

            }  /* |if (DEBUG)|  */ 

            break;

         } /* |else if (status < param.MAX_BUFFER)|  */

@q ****** (6) @>

      }  /* |else if (status > 0)|  */
     
@q ***** (5) @>

   }  /* |for|  */

@q **** (4) @>

@ The server sometimes sends empty messages to the client in order to prevent 
the latter from blocking.  This may seem a bit wasteful, but it seems to be 
best solution to the problem.  For a discussion of the problem, see the comments 
in the definition of |exchange_data_with_client| in \filename{connect.web}.
\initials{LDF 2010.03.04.}

\LOG
\initials{LDF 2010.03.04.}
Now testing whether the temporary file is empty.
If it is, we don't bother calling |zzparse|.
\ENDLOG 

@<|exchange_data_with_server| definition@>=

    if (out_strm)
       out_strm.close();

    if (wrote_data_to_out_strm)
    {
       fp = fopen(temp_filename, "r");
       c = fgetc(fp);
    }

@q ***** (5) @>
@
\LOG
\initials{LDF 2010.05.18.}
Added this section.
\ENDLOG

@<|exchange_data_with_server| definition@>=

    if (status == 1 && !wrote_data_to_out_strm 
        && (buffer[0] == EOF || buffer[0] == 255 || buffer[0] == 0))
    {
        if (DEBUG)
        {
            cerr << "Nothing to read.  Not calling `zzparse'."
                 << endl;

        }  /* |if (DEBUG)|  */ 

    }  /* |if|  */

@q ***** (5) @>
@
@<|exchange_data_with_server| definition@>=

    else if (   (wrote_data_to_out_strm && c != EOF) 
        || (!wrote_data_to_out_strm && buffer[0] != 0))
    {
       if (wrote_data_to_out_strm)
          ungetc(c, fp);

       param.server_finished = false;

       zzlex_init(&parameter);      
       zzset_extra(&param, parameter);

       if (wrote_data_to_out_strm)
       {
          if (DEBUG) 
          {           
              cerr << "Calling `zzset_in'."
                   << endl;
          }

          zzset_in(fp, parameter);
       }
       else
       {
          if (DEBUG) 
             cerr << "Calling `zz_scan_string'."
                  << endl;

          zz_buffer_state = zz_scan_string(buffer, parameter);
       }

       status = zzparse(parameter);

       if (!wrote_data_to_out_strm)
          zz_delete_buffer(zz_buffer_state, parameter);

       if (status != 0)
       {
          lock_cerr_mutex();
          cerr <<  "ERROR!  In `exchange_data_with_server':  "
               << "`zzparse' returned  " << status << endl
               << endl
               << "Exiting function unsuccessfully "
               << "with return value " << status << "."
               << endl;
          unlock_cerr_mutex();

          zzlex_destroy(parameter);
          gnutls_bye (*param.session, GNUTLS_SHUT_WR);

          if (wrote_data_to_out_strm)
          {
             fclose(fp);
             fp = 0;
          }

          return 1;

       }  /* |if (status != 0)|  */
  
       else if (DEBUG) 
       {
          lock_cerr_mutex();
          cerr <<  "In `exchange_data_with_server':  "
               << "`zzparse' succeeded."
               << endl;
          unlock_cerr_mutex();

       }  /* |else if (DEBUG)|  */

       zzlex_destroy(parameter);

    }  /* |else if|  */  

@q **** (4) @>
@
@<|exchange_data_with_server| definition@>=

    else if (DEBUG)
    {
          lock_cerr_mutex();
          cerr <<  "In `exchange_data_with_server':  "
               << "Temporary file or `buffer' is empty.  Not parsing."
               << endl;
          unlock_cerr_mutex();

    }  /* |else if (DEBUG)|  */ 

    if (wrote_data_to_out_strm)
    { 
       fclose(fp);
       fp = 0;

       if(!save_temp_files)
       {
          status = unlink(temp_filename);

          if (status == -1)
          {
              lock_cerr_mutex();
              cerr << "WARNING!  In `exchange_data_with_server':" 
                   << endl 
                   << "`unlink' failed to removed temporary file `" 
                   << temp_filename << "'."
                   << endl 
                   << "Continuing."
                   << endl;
              unlock_cerr_mutex();
   
          }  /* |if (status == -1)|  */

       }  /* |if(!save_temp_files)|  */

   }  /* |if (wrote_data_to_out_strm)|  */

@q **** (4) @>
@
@<|exchange_data_with_server| definition@>=

    pthread_mutex_lock(&param.response_deque_mutex);
    status = param.response_deque.size();
    pthread_mutex_unlock(&param.response_deque_mutex);

    if (DEBUG) 
    {
        lock_cerr_mutex();
        cerr << "`param.response_deque.size()' == " << status
             << endl
             << "`param.server_finished' == " << param.server_finished
             << endl;
        unlock_cerr_mutex();

    } /* |if (DEBUG)|  */

    if (status > 0)  /* |response_deque.size()|  */
    {

        param.client_finished = false;

        pthread_mutex_lock(&param.response_deque_mutex);
        response = param.response_deque.front();
        param.response_deque.pop_front(); 
        pthread_mutex_unlock(&param.response_deque_mutex);

        if (DEBUG)
        {
            lock_cerr_mutex();
            cerr << "In `exchange_data_with_server':"
                 << endl;
            response.show("response");
            unlock_cerr_mutex();
  
        }  /* |if (DEBUG)|  */ 

        memset (buffer, 0, param.MAX_BUFFER + 1);
        strcpy(buffer, response.command.c_str());      

        if (DEBUG)     
        {

           lock_cerr_mutex(); 
           cerr << "In `exchange_data_with_server':  Sending `buffer' to server.  "
                << "`buffer' == "
                << endl
                << buffer
                << endl;
           unlock_cerr_mutex();

        }  /* |if (DEBUG)|  */

        status = gnutls_record_send(*param.session, buffer, strlen (buffer));


@q **** (4) @>
@
\LOG
\initials{LDF 2011.04.21.}
Now testing for |response.type == Response_Type::INSTALLATION_SCRIPT_ENCRYPTED_TYPE|,
|response.type == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE| and 
|response.type == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE|
in this conditional.

\initials{LDF 2011.05.06.}
Now testing for |response.type == Response_Type::AUTHORIZATION_TYPE|,
in this conditional.


\initials{LDF 2011.11.03.}
Now testing for |response.type == Response_Type::KEY_PAIR_TYPE|
in this conditional.
\ENDLOG 

@<|exchange_data_with_server| definition@>=

        if (   response.type == Response_Type::INSTALLATION_SCRIPT_TYPE
            || response.type == Response_Type::INSTALLATION_SCRIPT_ENCRYPTED_TYPE
            || response.type == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE
            || response.type == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE
            || response.type == Response_Type::AUTHORIZATION_TYPE
            || response.type == Response_Type::PROXY_CREDENTIAL_TYPE
            || response.type == Response_Type::KEY_PAIR_TYPE
            || response.type == Response_Type::SEND_ENVIRONMENT_SHELLSCRIPT_TYPE)
        {
@q ***** (5) @>

            bool delete_local_file_val = false;

            if (response.type == Response_Type::KEY_PAIR_TYPE)
               delete_local_file_val = true;

            status = param.send_data_to_peer(response, delete_local_file_val);

            if (status != 0)
            {
                 lock_cerr_mutex();
                 cerr << "ERROR!  In `exchange_data_with_server':  "
                      << "`Scan_Parse_Parameter_Type::send_data_to_peer' failed, returning "
                      << status
                      << endl 
                      << "Continuing."
                      << endl;
                 unlock_cerr_mutex();              

            }  /* |if (status != 0)|  */

            else if (DEBUG)
            {
                 lock_cerr_mutex();
                 cerr << "In `exchange_data_with_server':  "
                      << "`Scan_Parse_Parameter_Type::send_data_to_peer' "
                      << "succeeded."
                      << endl;
                 unlock_cerr_mutex();

            }  /* |if (DEBUG)|  */ 

@q ***** (5) Send public key.  @>

@ Send public key.  
\initials{LDF 2011.12.12.}

\LOG
\initials{LDF 2011.12.12.}
Added this section.
\ENDLOG

@<|exchange_data_with_server| definition@>=

            if (response.type == Response_Type::KEY_PAIR_TYPE)
            {
@q ****** (6) @>
                  response.type = Response_Type::PUBLIC_KEY_TYPE;
                  response.local_filename = response.local_filename_1;
                  response.local_filename_1 = "";

                  status = param.send_data_to_peer(response, delete_local_file_val);

                  if (status != 0)
                  {
                       lock_cerr_mutex();
                       cerr << "ERROR!  In `exchange_data_with_server':  "
                            << "`Scan_Parse_Parameter_Type::send_data_to_peer' failed, returning "
                            << status
                            << endl 
                            << "Continuing."
                            << endl;
                       unlock_cerr_mutex();              

                  }  /* |if (status != 0)|  */

                  else if (DEBUG)
                  {
                       lock_cerr_mutex();
                       cerr << "In `exchange_data_with_server':  "
                            << "`Scan_Parse_Parameter_Type::send_data_to_peer' "
                            << "succeeded."
                            << endl;
                       unlock_cerr_mutex();

                  }  /* |if (DEBUG)|  */ 

@q ****** (6) @>

            }  /* |if (response.type == Response_Type::KEY_PAIR_TYPE)|  */

@q ***** (5) @>

        }  /* |if (   response.type == Response_Type::INSTALLATION_SCRIPT_TYPE
                   || response.type == Response_Type::INSTALLATION_SCRIPT_ENCRYPTED_TYPE
                   || response.type == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE
                   || response.type == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE
                   || response.type == Response_Type::AUTHORIZATION_TYPE
                   || response.type == Response_Type::PROXY_CREDENTIAL_TYPE
                   || response.type == Response_Type::KEY_PAIR_TYPE
                   || response.type == Response_Type::SEND_ENVIRONMENT_SHELLSCRIPT_TYPE)|  */
@q **** (4) @>

        if (DEBUG) 
        {
           lock_cerr_mutex();
           cerr << "In `exchange_data_with_server':  Going back to `READ_SERVER_DATA' (" 
                << loop_ctr++ << ")" 
                << endl;
           unlock_cerr_mutex();

        }  /* |if (DEBUG)|  */

        goto READ_SERVER_DATA;

    }   /* |if (status > 0)| (|response_deque.size()|)  */

    else if (!param.server_finished)
    {

       memset (buffer, 0, param.MAX_BUFFER + 1);
       strcpy(buffer, "Client Finished");

       param.client_finished = true;

       if (DEBUG) 
       {
           lock_cerr_mutex();
           cerr << "In `exchange_data_with_server':  Sending `buffer' to server.  `buffer' == "
                << endl
                << buffer
                << endl;
           unlock_cerr_mutex();

       }  /* |if (DEBUG)|  */

       status = gnutls_record_send(*param.session, buffer, strlen (buffer));
       
       if (status < 0)
       {
           temp_strm.str(""); 

           temp_strm << "ERROR:  In |exchange_data_with_server|:  "
                     << endl 
                     << "`gnutls_record_send' failed returning " << status << "."
                       << endl
                     << "Exiting function unsuccessfully "
                     << "with return value 1."
                     << endl;

           lock_cerr_mutex();
           cerr << temp_strm.str();
           gnutls_perror(status);
           unlock_cerr_mutex();

           err_log_strm << temp_strm.str();
           log_strm << temp_strm.str();

           ++errors_occurred;

           gnutls_bye (*param.session, GNUTLS_SHUT_WR);

           return 1;

       }  /* |if (status < 0)|  */

       if (DEBUG) 
       {
          lock_cerr_mutex();
          cerr << "In `exchange_data_with_server':  Going back to `READ_SERVER_DATA' (" 
               << loop_ctr++ << ")"  
               << endl;
          unlock_cerr_mutex(); 
 
       }  /* |if (DEBUG)|  */

       goto READ_SERVER_DATA;

    }  /* |else if (!param.server_finished)| */
 
@ 
\LOG
\initials{LDF 2010.05.26.}
@:BUG FIX@> BUG FIX:
If |param.client_finished == true|, then the client has already sent the 
string |"Client Finished"| to the server and the latter has broken the TLS connection.
Previously, |gnutls_record_send| failed at this point, causing the program to crash 
because of a broken pipe.  Now, |gnutls_record_send| and |gnutls_bye| are only called
if |param.client_finished == false|.
\ENDLOG 

@<|exchange_data_with_server| definition@>=

   else /* |param.server_finished && param.response_deque.size() == 0| */
   {

      if (!param.client_finished)
      {

          if (DEBUG) 
          {
              lock_cerr_mutex();
              cerr << "In `exchange_data_with_server':  Ending connection."
                   << endl
                   << buffer
                   << endl;
              unlock_cerr_mutex();

          }  /* |if (DEBUG)|  */

          param.client_finished = true;
          memset (buffer, 0, param.MAX_BUFFER + 1);
          strcpy(buffer, "Client Finished");

          status = gnutls_record_send(*param.session, buffer, strlen (buffer));

          status = gnutls_bye(*param.session, GNUTLS_SHUT_WR);

      }  /* |if (!param.client_finished)|  */

      if (DEBUG) 
      {
          lock_cerr_mutex();
          cerr << "*** Exiting `exchange_data_with_server' successfully "
               << "with return value 0."
               << endl;
          unlock_cerr_mutex();

      }  /* |if (DEBUG)|  */

       return 0;

   }  /* |else| (|param.server_finished && param.response_deque.size() == 0|) */

}  /* End of |exchange_data_with_server| definition  */

@q ** (2) @>
@
@<Garbage@>=
#if 0 
#endif 

@q ** (2) Putting Client Connection Functions together.@>

@ Putting Client Connection Functions together.
@c
using namespace std;
@<Include files@>@;@/
extern int yydebug;
extern int zzdebug;
@<Version control identifier@>@;@/
@<External function declarations@>@;@/
@<|client_connect_auth| declaration@>@;@/
@<|client_connect_non_auth| declaration@>@;@/
@<|exchange_data_with_server| declaration@>@;@/
@<|client_connect_auth| definition@>@;@/
@<|client_connect_non_auth| definition@>@;@/
@<|exchange_data_with_server| definition@>@;@/

#if 0 /* 1 */ 
@<Garbage@>@;@/
#endif 

@
@(cnnctcli.h@>=
@<|client_connect_auth| declaration@>@;@/
@<|client_connect_non_auth| declaration@>@;@/
@<|exchange_data_with_server| declaration@>@;@/


@q (progn (cweb-mode) (outline-minor-mode))                  @>

@q * (1) Local variables for Emacs @>

@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q abbrev-mode:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>
