@q scprpmtp.web  @>
@q Created by Laurence D. Finston (LDF) Di Jul  8 14:53:39 CEST 2008  @>

@q * (1) Top @>

@q * (1) Copyright and License.@>

@q This file is part of the OptiNum Grid Installer @>
@q Copyright (C) 2010, 2011, 2012, 2013 Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen @>

@q The OptiNum Grid Installer is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q The OptiNum Grid Installer is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License          @>
@q along with the OptiNum Grid Installer; if not, write to the Free Software                    @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gwdg.de@>

@q Laurence D. Finston                                                   @>
@q Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen  @>
@q Am Fassberg 11         					         @>
@q 37077 Goettingen              					 @>
@q Germany                           					 @>                                

@q Laurence.Finston@@gwdg.de (@@ stands for a single "at" sign.)@>

@q ** (2)  scprpmtp.web  @>
@* {\bf Scan\_Parse\_Parameter\_Type}.

@q ** (2) Include files  @>

@ Include files.

@<Include files@>=
#include <stdlib.h>  /* Standard Library for C  */
#include <stdio.h>
#include <errno.h>
#include <unistd.h>

#include <algorithm> /* Standard Template Library (STL) for C++  */
#include <fstream> 
#include <iomanip>
#include <ios>
#include <iostream>
#include <map>
#include <string>
#include <time.h>
#include <math.h>
#include <sstream>  

#include <set>
#include <vector>
#include <deque>


#include <pthread.h>  /* POSIX threads  */

#include <gcrypt.h> /* for |gcry_control| */
#include <gnutls/gnutls.h>

#if HAVE_CONFIG_H
#include <config.h>
#endif 

#if IS_ROCKS_GOEGRID
#undef HAVE_LIBMYSQLCLIENT
#endif 

#if HAVE_LIBMYSQLCLIENT
#include <mysql.h>
#endif 

#include "entries.h++"  /* Headers generated from CWEB files belonging to this package  */
#include "dstngnmt.h++"

#include "glblvrbl.h++"  
#include "glblfncs.h++"
#include "utilfncs.h++"
#include "parser.h++"    
#include "scanner.h++"
#include "x509cert.h++"
#include "rspnstp.h++"
#include "thrdfncs.h++"
#include "sssndttp.h++"
#include "glsinftp.h++"

@q ** (2) @>
@
@<External function declarations@>=
int 
yyparse(yyscan_t parameter);

@q ** (2) Scan_Parse_Parameter_Type. @>

@ {\bf Scan\_Parse\_Parameter\_Type}.

@:NOTE@> !! PLEASE NOTE:  The |unsigned int effective_user_id| 
is used when the client \.{optdbcli} is called by the web application
\.{optwbsrv}.  In this case, the user's certificate is passed to \.{optwbsrv} using 
\.{curl} or in some other way.  \.{optwbsrv} then calls \.{optdbcli}.  While the 
user's certificate is available to \.{optwbsrv} and could theoretically be passed 
to \.{optdbcli}, the key file is not.  Therefore, \.{optdbcli} must use a certificate 
of its own for authentication by the server.  This requires a way of allowing the user 
identified by \.{optdbcli}'s certificate to act on behalf of the owner of the 
certificate passed to \.{optwbsrv}.
\par
For \.{optdbcli} to be used for ``fetching'' and/or ``installing'', it must be installed 
on the computer where this is to take place.  Therefore, there is no need to use 
\.{optwbsrv} and |unsigned int effective_user_id| is not used by the ``fetch'' 
or ``install'' functions.
\initials{LDF 2010.07.01.}

\LOG
\initials{LDF 2009.09.23.}
Removed code specific to ``Quali'' package.

\initials{LDF 2009.10.06.}
Added |int fd|.

\initials{LDF 2009.10.12.}
Added |vector<struct Entry_Type> entries|.

\initials{LDF 2009.12.09.}
Added |gnutls_certificate_credentials_t* cert_cred_ptr|.

\initials{LDF 2009.12.09.}
Added |gnutls_x509_crt_t *ca_list| and |unsigned int ca_list_size|.

\initials{LDF 2009.12.18.}
Changed the type of |out_strm| from |ofstream| to |ostream*|.  This makes it possible
to set |out_strm = &cout|.

\initials{LDF 2009.12.23.}
Added |MYSQL* mysql_ptr|.  It should be initialized using |mysql_init| when the 
|Scan_Parse_Parameter_Type| object is created.

\initials{LDF 2009.12.29.}
Added |unsigned int user_id| and |string user_name|.  They're 
set by |Scan_Parse_Parameter_Type::get_database_username|.

\initials{LDF 2010.01.21.}
Changed |stringstream request_strm| to |stack<string> request_stack|.

\initials{LDF 2010.01.21.}
Removed |stack<string> request_stack| and |queue<Response_Type> send_file_queue|.  
Replaced them with |deque<Response_Type> response_deque|.

\initials{LDF 2010.02.11.}
Added |gnutls_anon_server_credentials_t* anon_server_cred_ptr| and
|gnutls_anon_server_credentials_t* anon_client_cred_ptr|.


\initials{LDF 2010.03.05.}
Added |string prerequisite_list|.

\initials{LDF 2010.03.11.}
Added |stringstream err_strm|.

\initials{LDF 2010.03.16.}
Renamed |stringstream err_strm| |msg_strm|.

\initials{LDF 2010.03.17.}
Added |vector<string> prerequisite_string_vector| and |entry_string_vector|.

\initials{LDF 2010.03.29.}
Added the |string| data members |download_url_string| and |download_command_string|.

\initials{LDF 2010.05.26.}
Added |string remote_ip_address| and |int remote_port|.

\initials{LDF 2010.06.30.}
Added |string effective_user_dn|, |string effective_user_name| 
and |unsigned int effective_user_id|.

\initials{LDF 2010.10.01.}
Added |vector<struct Entry_Type> emendations|.

\initials{LDF 2011.01.28.}
Added |unsigned int show_options|.

\initials{LDF 2011.10.03.}
Added |vector<struct Entry_Type> install_vector|.

\initials{LDF 2011.10.12.}
Added |string proxy_cert_filename|.

\initials{LDF 2011.10.23.}
Added |pthread_mutex_t response_deque_mutex|.  Added code for initializing and 
destroying it in the default constructor (only constructor at present) 
and the destructor, respectively.

\initials{LDF 2011.11.03.}
Added |string user_dn|.

\initials{LDF 2011.11.16.}
Added |unsigned int MAX_BUFFER|.  Formerly, |MAX_BUFFER| was a global variable, 
but the size of the messages that can be sent by |gnutls_record_send| is limited
and negotiated during the handshake, i.e., unknown until then.

\initials{LDF 2011.11.17.}
Added |vector<string> globus_site_list|.

\initials{LDF 2011.11.21.}
Changed |vector<string> globus_site_list| to |set<string> globus_site_set|.
This way, duplicates aren't added to it.

\initials{LDF 2011.12.16.}
Added |unsigned long int key_id|.

\initials{LDF 2011.12.22.}
Added |string session_id|.

\initials{LDF 2011.12.25.}
Added |map<int, int> show_level_map|.

\initials{LDF 2012.01.03.}
Added |Session_Data_Type *session_data|.

\initials{LDF 2012.02.09.}
Changed |Scan_Parse_Parameter_Type| from a |struct| to a |class|.  Added |friend| declarations.
All of the data members and member functions are |private|.
@:TODO@> !! TODO:  Add functions for accessing data members and see if I can get rid 
of some of the |friend| declarations.

\initials{LDF 2012.03.16.}
Added |stringstream environment_strm| and |string environment_host|.

\initials{LDF 2012.03.20.}
Added |vector<string> environment_shellscript_filename_vector|.

\initials{LDF 2012.03.22.}
Added |unsigned int show_environment_shellscript_options|
and |string show_environment_shellscript_globus_site|.

\initials{LDF 2012.03.22.}
Changed name of |string environment_host| to |environment_globus_site|.
Added |unsigned int environment_admin_flag|.

\initials{LDF 2012.03.27.}
Changed |string show_environment_shellscript_globus_site| to 
|set<string> show_environment_shellscript_globus_site_set|.

\initials{LDF 2012.04.12.}
Added |Globus_Site_Info_Type globus_site_options|.
\ENDLOG 

@:NOTE@> !! PLEASE NOTE:  It can be useful to set |MAX_BUFFER| to a low value in order 
to test the code for writing data to temporary files if and only if 
the length of the data exceeds |MAX_BUFFER|.  However, character buffers of size 
|MAX_BUFFER| are also used for commands that the peers send to each other.  If a command 
is longer than |MAX_BUFFER|, this will cause a segmentation fault.
\initials{LDF 2010.04.12.}
(See also above \initials{LDF 2011.11.16.})

@q *** (3) Declaration  @>
 
@<|class Scan_Parse_Parameter_Type| declaration@>=

class Scan_Parse_Parameter_Type
{

   friend int client_connect_auth();
   friend int client_connect_non_auth();

   friend void* connect_func(void*);
   friend void* connect_func_non_auth(void*);
   friend int exchange_data_with_client(Scan_Parse_Parameter_Type*);

   friend int exchange_data_with_server(Scan_Parse_Parameter_Type&);

   friend class Entry_Type;

   friend void verify_cert2(gnutls_x509_crt_int*, gnutls_x509_crt_int*, 
                            gnutls_x509_crl_int**, int, Scan_Parse_Parameter_Type*);

   friend int verify_last_cert(gnutls_x509_crt_int*, gnutls_x509_crt_int**, 
                               int, gnutls_x509_crl_int**, int, Scan_Parse_Parameter_Type*);

   friend int verify_certificate_chain(gnutls_session_int*, const char*, 
                                       const gnutls_datum_t*, int, gnutls_x509_crt_int**, int, 
                                       X509_Cert_Type*, X509_Cert_Type*, 
                                       Scan_Parse_Parameter_Type*);

   friend int extract_dn_fields(gnutls_x509_crt_int*&, X509_Cert_Type*, bool, 
                                Scan_Parse_Parameter_Type*);

   friend int install_packages(Scan_Parse_Parameter_Type&);

   friend int hidden_install(Scan_Parse_Parameter_Type &param, vector<string> &arg_vector);

   friend int yyparse(void*);

   friend int parse_input(FILE*, char*, Scan_Parse_Parameter_Type*);

   friend int accept_data(Scan_Parse_Parameter_Type*, char*, int, int, std::string*);

   friend int remote_install_rule_func(Scan_Parse_Parameter_Type*, 
                                       int, std::string, std::string, std::string, 
                                       std::string, std::string, int, int, std::string);

   friend int yylex(YYSTYPE*, void*);

@ |IN_PRSRCLNT| is defined in \filename{prsrclnt.web} before including
\filename{scprpmtp.h++}, and then undefined afterwards.  This prevents a warning
about |zzlex| already being a |friend| of |Scan_Parse_Parameter_Type|.
\initials{LDF 2012.02.10.}

@<|class Scan_Parse_Parameter_Type| declaration@>=

#ifndef IN_PRSRCLNT   

   friend int zzlex(YYSTYPE*, void*);

#endif 

   friend class GPG_Key_Pair_Type;

   friend void* remote_install_func(void*);

   friend void* sub_distribute_key_pair(void*);

   friend class X509_Cert_Type;

   friend void* listen_auth(void*);
   friend void* listen_non_auth(void*);

   friend int init_globus_site_map(Scan_Parse_Parameter_Type*);


   bool PARSER_DEBUG;

   int thread_ctr;

   pthread_t thread_id;

   int start_condition;

   unsigned int MAX_BUFFER;

   string date_time_str;

   string in_filename;
   string out_filename;

   ostream* out_strm;

   stringstream msg_strm;

   Scan_Parse_Parameter_Type* up;

   int fd;  /* File descriptor, used by |connect_func| in \filename{connect.web}.  
               Specifically, in the call to |gnutls_transport_set_ptr|.
               \initials{LDF 2009.12.28.}
               \initials{LDF 2012.05.22.}
            */

   vector<class Entry_Type> entries;

   vector<class Entry_Type> emendations;

   vector<class Entry_Type> install_vector;

   gnutls_certificate_credentials_t* cert_cred_ptr;

   gnutls_anon_server_credentials_t* anon_server_cred_ptr;

   gnutls_anon_client_credentials_t* anon_client_cred_ptr;

   gnutls_x509_crt_t *ca_list;  
   unsigned int ca_list_size;

#if HAVE_LIBMYSQLCLIENT
   MYSQL *mysql_ptr;
#endif 

   string user_name;
   unsigned int user_id;

   string user_dn;
   string effective_user_dn;
   string effective_user_name;
   unsigned int effective_user_id;

   deque<Response_Type> response_deque;

   pthread_mutex_t response_deque_mutex;

   gnutls_session_t *session;

   string prerequisite_list;

   bool server_finished;
   bool client_finished;

   vector<string> prerequisite_string_vector;
   vector<string> entry_string_vector;

   string download_url_string;
   string download_command_string;

   string remote_ip_address;
   int remote_port;

   unsigned int show_options;

   unsigned int show_environment_shellscript_options;
   set<string> show_environment_shellscript_globus_site_set;

   string proxy_cred_filename;

   set<string> globus_site_set;

   static const unsigned int MAX_KEY_PAIR_SIZE;

   char key_pair_str[65536];  /*  |MAX_KEY_PAIR_SIZE| can't be used here,
                                  because it hasn't been initialized yet.
                                  !! If the value is changed below,
                                  it must be changed here, too!
                                  \initials{LDF 2011.11.23.}
                              */
   string key_name;
   unsigned long int key_id;

   string session_id;

   Session_Data_Type *session_data;

   map<int, int> show_level_map;

   stringstream environment_strm;

   string environment_globus_site;

   unsigned int environment_admin_flag;

   vector<string> environment_shellscript_filename_vector;

   Globus_Site_Info_Type globus_site_options;


   @<|Scan_Parse_Parameter_Type| function declarations@>@;

};

@q *** (3) Initialize |static| constant |Scan_Parse_Parameter_Type| member variables.  @>

@ Initialize {\bf static} constant {\bf Scan\_Parse\_Parameter\_Type} 
member variables.
\initials{LDF 2011.11.23.}

\LOG
\initials{LDF 2011.11.23.}
Added this section with the initialization of 
|Scan_Parse_Parameter_Type::MAX_KEY_PAIR_SIZE|.
\ENDLOG

@:NOTE@> !! PLEASE NOTE:  If the value of |MAX_KEY_PAIR_SIZE| is changed here,
it must also be changed in the declaration of |char key_pair_str| above!
\initials{LDF 2011.11.23.}

@<Initialize |static| constant |Scan_Parse_Parameter_Type| member variables@>=

   const unsigned int Scan_Parse_Parameter_Type::MAX_KEY_PAIR_SIZE = 65536;  /* $2^{16}$  */

@q *** (3) |Scan_Parse_Parameter_Type| functions.@>
@ {\bf Scanner\_Type} functions.

@q **** (4) Default constructor.  @>
@ Default constructor.

\LOG
\initials{LDF 2008.07.07.}
Added this function.

\initials{LDF 2009.10.06.}
Now initializing |int fd| to $-1$.

\initials{LDF 2011.01.28.}
Now initializing |unsigned int show_options| to 0.

\initials{LDF 2012.03.22.}
Now initializing |unsigned int show_environment_shellscript_options| to 0.
\ENDLOG

@<|Scan_Parse_Parameter_Type| function declarations@>=

Scan_Parse_Parameter_Type(void);

@
@<|Scan_Parse_Parameter_Type| constructor definitions@>=

Scan_Parse_Parameter_Type::Scan_Parse_Parameter_Type(void)
{

   PARSER_DEBUG = false;  /* |true|  */

   start_condition = 0;

   thread_ctr = -1; 
  
   user_id   = 0;
   effective_user_id   = 0;

   up = 0;

   fd = -1;

   cert_cred_ptr = 0;

   remote_port = 0;

   anon_server_cred_ptr = 0;
   anon_client_cred_ptr = 0;

   ca_list = 0;  
   ca_list_size = 0;

#if HAVE_LIBMYSQLCLIENT
   mysql_ptr = 0;
#endif 

   session = 0;

   server_finished = false;

   client_finished = false;

   MAX_BUFFER = 16384;  /* $2^{14}$.  Default value.  May be reduced, depending 
                           on the return value of |gnutls_record_get_max_size|, 
                           which is determined during the GNUTLS session handshake.
                           \initials{LDF 2011.11.23.}
                        */


   memset(key_pair_str, 0, MAX_KEY_PAIR_SIZE);

   show_options = 0;

   show_environment_shellscript_options = 0;

   session_data = 0;

   pthread_mutex_init(&response_deque_mutex, 0);

   return;

}  /* End of |Scan_Parse_Parameter_Type::Scan_Parse_Parameter_Type(void)| definition.  */

@q **** (4) Destructor.  @>
@ Destructor.

\LOG
\initials{LDF 2008.07.08.}\hfil\break 
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type| function declarations@>=

~Scan_Parse_Parameter_Type(void);

@
@<|Scan_Parse_Parameter_Type| destructor definition@>=

Scan_Parse_Parameter_Type::~Scan_Parse_Parameter_Type(void)
{

   bool DEBUG = false; /* |true|  */ 

   up = 0;

   cert_cred_ptr = 0;

   anon_server_cred_ptr = 0;
   anon_client_cred_ptr = 0;

   ca_list = 0;  
   ca_list_size = 0;

#if HAVE_LIBMYSQLCLIENT

   if (mysql_ptr)
      mysql_close(mysql_ptr); 

   mysql_ptr = 0;

#endif 

   session = 0;

   delete session_data;
   session_data = 0;

   if (!save_temp_files)
   {
       for (vector<string>::const_iterator iter 
            = environment_shellscript_filename_vector.begin();
            iter != environment_shellscript_filename_vector.end();
            ++iter)
       {
           unlink(iter->c_str());
       }

   }  /* |if|  */


   pthread_mutex_destroy(&response_deque_mutex);

   return;

}  /* End of |Scan_Parse_Parameter_Type::~Scan_Parse_Parameter_Type(void)| definition.  */

@q **** (4) Write entries to database.@>

@ Write entries to database.
\initials{LDF 2009.10.12.}

\LOG
\initials{LDF 2012.01.13.}
Removed the definition of this function to \filename{spptwren.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
write_entries(void);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Get Database Username.  @>
@ Get Database Username.
\initials{LDF 2009.12.23.}

\LOG
\initials{LDF 2009.12.23.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

string
get_database_username(X509_Cert_Type& cert);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=

#if HAVE_LIBMYSQLCLIENT

string
Scan_Parse_Parameter_Type::get_database_username(X509_Cert_Type& cert)
{
@q ****** (6) @>
 
   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG);

   int status = 0;

   string thread_ctr_str = "";

   {
       stringstream s;
 
       s << "[Thread " << thread_ctr << "]:  ";

       thread_ctr_str = s.str();
       
   }  

   if (DEBUG)
   {
      lock_cerr_mutex(); 
      cerr << thread_ctr_str << "Entering `Scan_Parse_Parameter_Type::get_database_username'."
           << endl;
      unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
\LOG
\initials{LDF 2012.05.10.}
@:BUG FIX@> BUG FIX:  Added |"order by u.user_id"| to SQL query.  There should only
be one |user_id| associated with a Distinguished Name, but for some reason multiple rows
have been created in the \.{Users} table.  It is not clear to me under exactly what 
conditions this has occurred.  I am working on preventing this from happening.  This
change is just extra insurance.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=

    Distinguished_Name_Type distinguished_name;

    distinguished_name = cert;

    MYSQL_RES* result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    stringstream query_strm;

    int certificate_id;

    query_strm << "select u.user_id, u.user_name, c.issuer_cert_id, c.certificate_id, "
               << "c.serialNumber, c.commonName "
               << "from Users as u, Certificates as c "
               << "where u.user_id = c.user_id and u.user_id > 0 "
               << "and ((c.serialNumber is not NULL and c.serialNumber <> 0 and c.serialNumber = " 
               << cert.serialNumber << ") or "
               << "(c.commonName = '" << distinguished_name.commonName 
               << "' and c.organization = '" << distinguished_name.organization
               << "' and c.organizationalUnitName = '" << distinguished_name.organizationalUnitName
               << "' and c.countryName = '" << distinguished_name.countryName << "')) "
               << "order by u.user_id";

    if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_database_username':"
             << endl 
             << "`query_strm.str()' == " 
             << endl
             << query_strm.str()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=

    status = submit_mysql_query(query_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_database_username':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value \"\" "
             << "(i.e., an empty `string')."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return string("");

    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_database_username':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_database_username':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) |row_ctr == 0|.  Check \filename{grid-mapfile}.  @>

@ |row_ctr == 0|.  Check \filename{grid-mapfile}.
\initials{LDF 2010.04.23.}

@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=

    if (row_ctr ==  0)
    {
@q ******* (7) @>

        status = check_grid_mapfile("", &cert, &user_name);

        if (status <= 0)
        {
@q ******** (8) @>

            lock_cerr_mutex();
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::get_database_username':"
                 << endl 
                 << "No rows returned and `Scan_Parse_Parameter_Type::check_grid_mapfile' "
                 << " failed, returning " << status << "."
                 << endl 
                 << "Exiting function with return value \"\" (i.e., an empty `string')."
                 << endl;
            unlock_cerr_mutex(); 

            mysql_free_result(result);        

            user_name = "";

            return string("");             

@q ******** (8) @>

        }  /* |if (status <= 0)|  */         

@q ******* (7) @>

        else 
        {
@q ******** (8) @>

           user_id = status;

           if (DEBUG) 
           {
               lock_cerr_mutex();
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "In `Scan_Parse_Parameter_Type::get_database_username':"
                    << endl 
                    << "No rows returned, but `Scan_Parse_Parameter_Type::check_grid_mapfile' "
                    << "succeeded, returning " << status << "."
                    << endl
                    << "`user_name' == " << user_name
                    << endl 
                    << "`user_id' == " << user_id
                    << endl;
               unlock_cerr_mutex(); 

               mysql_free_result(result);        

               return user_name;  

           }  /* |if (DEBUG)|  */

@q ******** (8) @>

         }  /* |else|  */
     
@q ******* (7) @>
   
    } /* |if (row_ctr ==  0)| */

@q ****** (6) Found entries in database tables.  @>

@ Found entries in database tables.  
\initials{LDF 2010.04.23.}

@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=

    else /* |row_ctr >  0| */
    {
@q ******* (7) @>

        curr_row = mysql_fetch_row(result);

        if (curr_row == 0)
        {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::get_database_username':"
                << endl 
                << "`mysql_fetch_row' failed:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting function unsuccessfully with return value "
                << "\"\" (i.e., an empty `string')."
                << endl;
           unlock_cerr_mutex(); 

           if (result)
              mysql_free_result(result);

           return string("");

        }  /* |if (curr_row == 0)|  */

@q ******* (7) @>

        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::get_database_username':"
                 << endl;
            if (curr_row[0])
               cerr << "`curr_row[0]' == " << curr_row[0]
                    << endl;
            else
               cerr << "`curr_row[0]' is NULL." << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */

@q ******* (7) @>

        if (curr_row[0])
        {
           sscanf(curr_row[0], "%d", &user_id);
           cert.user_id = user_id;
        }
        else 
           cert.user_id = user_id = 0;

        if (curr_row[1])
        {
           user_name = cert.user_name = curr_row[1];
        }
        else
        {
            user_name = cert.user_name = "";

            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "WARNING!  In `Scan_Parse_Parameter_Type::get_database_username':"
                 << endl 
                 << "Failed to find username."
                 << endl 
                 << "Exiting function successfully with return value "
                 << "\"\" (i.e., an empty `string')."
                 << endl;
            unlock_cerr_mutex(); 

            mysql_free_result(result);

            return string("");

        }  /* |else| (|!curr_row[1]|)  */

        if (curr_row[3])
        {
           sscanf(curr_row[3], "%d", &certificate_id);
        }

        string curr_commonName;

        if (curr_row[5])
           curr_commonName = curr_row[5];


@q ******* (7) Check serial number.  If it's not set, update the entry @>
@q ******* (7) in the datbase table {\bf Certificates}.                @>

@ Check serial number.  If it's not set, update the entry in 
the datbase table {\bf Certificates}.
\initials{LDF 2010.04.23.}

@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=

@q ******* (7) @>

        if (curr_row[4] && strlen(curr_row[4]))
        {
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "]:  "
                     << "In `Scan_Parse_Parameter_Type::get_database_username':"
                     << endl 
                     << "`curr_row[4]' != NULL && `strlen(curr_row[4])' > 0.  "
                     << "Serial number == " << curr_row[4]
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */ 

            mysql_free_result(result);        
        
            result = 0;

        }  /* |if (curr_row[4] && strlen(curr_row[4]))|  */

@q ******* (7) @>

@ |curr_row[4] == 0 || strlen(curr_row[4]) == 0|.
\initials{LDF 2010.04.26.}

@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=

        else 
        {
@q ******** (8) @>

            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "]:  "
                     << "In `Scan_Parse_Parameter_Type::get_database_username':"
                     << endl 
                     << "`curr_row[4]' == NULL or `strlen(curr_row[4])' == 0.  No serial number."
                     << endl;

                cerr << "curr_row[5] == " << curr_row[5] << endl;
                cerr << "curr_row[1] == " << curr_row[1] << endl;
                cerr << "user_name == " << user_name << endl;
                cerr << "curr_commonName == " << curr_commonName << endl;
                cerr << "distinguished_name.commonName == " 
                     << distinguished_name.commonName << endl;

                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */ 

@q ******** (8) @>

            mysql_free_result(result);

            query_strm.str("");

            query_strm << "update Certificates set serialNumber = " 
                       << cert.serialNumber;

            struct tm tmp;
            struct tm* tmp_ptr = &tmp;
            char outstr[256];

            if (cert.Validity_notBefore > 0)
            {
               gmtime_r(&cert.Validity_notBefore, tmp_ptr);     
               if (!(   tmp_ptr == 0 
                     || strftime(outstr, sizeof(outstr), "%Y-%m-%d %H:%M:%S UTC", tmp_ptr) == 0)) 
                  query_strm << ", Validity_notBefore = '" << outstr << "'";
 
            }

            memset(outstr, 0, 256);

            if (cert.Validity_notAfter > 0)
            {
               gmtime_r(&cert.Validity_notAfter, tmp_ptr);     
               if (!(   tmp_ptr == 0 
                     || strftime(outstr, sizeof(outstr), "%Y-%m-%d %H:%M:%S UTC", tmp_ptr) == 0)) 
                  query_strm << ", Validity_notAfter = '" << outstr << "'";
 
            }

            query_strm << " where certificate_id = " << certificate_id;

            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "]:  "
                     << "In `Scan_Parse_Parameter_Type::get_database_username':"
                     << endl 
                     << "`query_strm.str()' == "
                     << endl
                     << query_strm.str()
                     << endl;
                unlock_cerr_mutex(); 
 
            }  /* |if (DEBUG)|  */ 


@q ******** (8) @>


            status = submit_mysql_query(query_strm.str(),
                                        result);

            if (status)
            {
                lock_cerr_mutex(); 
                cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                     << "ERROR!  In `Scan_Parse_Parameter_Type::get_database_username':"
                     << endl 
                     << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                     << status << "."
                     << endl
                     << "Exiting function unsuccessfully with return value \"\" "
                     << "(i.e., an empty `string')."
                     << endl;
                unlock_cerr_mutex(); 

               if (result) 
                  mysql_free_result(result);

               return string("");

            }  /* |if (status)|  */

            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "]:  "
                     << "In `Scan_Parse_Parameter_Type::get_database_username':"
                     << endl 
                     << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */

            mysql_free_result(result);


@q ******** (8) @>

        }  /* |else| (|curr_row[4] == 0 || strlen(curr_row[4]) == 0|)  */


@q ******* (7) @>
 
    }  /* |else| (|row_ctr > 0|) */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=

   if (DEBUG)
   {
      lock_cerr_mutex(); 
      cerr << thread_ctr_str 
           << "Exiting `Scan_Parse_Parameter_Type::get_database_username' successfully "
           << "with return value \"" << user_name << "\"."
           << endl;
      unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 


   return user_name;

}  /* End of |get_database_username| definition  */

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) @>

@q **** (4) Get Database Username (int argument).  @>
@ Get Database Username (int argument).
\initials{LDF 2011.09.29.}

\LOG
\initials{LDF 2011.09.29.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

string
get_database_username(int user_id);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=

#if HAVE_LIBMYSQLCLIENT

string
Scan_Parse_Parameter_Type::get_database_username(int user_id)
{
@q ****** (6) @>
 
   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG);

   int status = 0;

   string thread_ctr_str = "";

   {
       stringstream s;
 
       s << "[Thread " << thread_ctr << "]:  ";

       thread_ctr_str = s.str();
       
   }  

   if (DEBUG)
   {
      lock_cerr_mutex(); 
      cerr << thread_ctr_str << "Entering `Scan_Parse_Parameter_Type::get_database_username(int)'."
           << endl;
      unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=


    MYSQL_RES* result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    stringstream query_strm;

    query_strm << "select user_name from Users where user_id = " << user_id;

    if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_database_username(int)':"
             << endl 
             << "`query_strm.str()' == " 
             << endl
             << query_strm.str()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=

    status = submit_mysql_query(query_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_database_username(int)':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value \"\" "
             << "(i.e., an empty `string')."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return string("");

    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_database_username(int)':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_database_username(int)':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) |row_ctr == 0|.  @>

@ |row_ctr == 0|.  
\initials{LDF 2011.09.29.}

@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=

    if (row_ctr ==  0)
    {
         lock_cerr_mutex();
         cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
              << "ERROR!  In `Scan_Parse_Parameter_Type::get_database_username'(int):"
              << endl 
              << "No rows returned."
              << endl 
              << "Exiting function with return value \"\" (i.e., an empty `string')."
              << endl;
         unlock_cerr_mutex(); 

         mysql_free_result(result);        

         user_name = "";

         return string("");             

    } /* |if (row_ctr ==  0)| */

@q ****** (6) Found entry in database.  @>

@ Found entry in database.
\initials{LDF 2011.09.29.}

@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=

    else /* |row_ctr >  0| */
    {
@q ******* (7) @>

        curr_row = mysql_fetch_row(result);

        if (curr_row == 0)
        {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::get_database_username(int)':"
                << endl 
                << "`mysql_fetch_row' failed:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting function unsuccessfully with return value "
                << "\"\" (i.e., an empty `string')."
                << endl;
           unlock_cerr_mutex(); 

           if (result)
              mysql_free_result(result);

           return string("");

        }  /* |if (curr_row == 0)|  */

@q ******* (7) @>

        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::get_database_username(int)':"
                 << endl;
            if (curr_row[0])
               cerr << "`curr_row[0]' == " << curr_row[0]
                    << endl;
            else
               cerr << "`curr_row[0]' is NULL." << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */

@q ******* (7) @>

        if (curr_row[0])
        {
            user_name = curr_row[0];
        }


   }  /* |else| (|row_ctr >  0|) */

   if (result)
      mysql_free_result(result);

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>=

   if (DEBUG)
   {
      lock_cerr_mutex(); 
      cerr << thread_ctr_str 
           << "Exiting `Scan_Parse_Parameter_Type::get_database_username(int)' successfully "
           << "with return value \"" << user_name << "\"."
           << endl;
      unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

   return user_name;

}  /* End of |Scan_Parse_Parameter_Type::get_database_username(int)| definition  */

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */



@q **** (4) Submit SQL query. @>

@ Submit SQL query.
\initials{LDF 2009.10.13.}

\LOG
\initials{LDF 2009.10.13.}
Added this function.

\initials{LDF 2010.01.08.}
Changed the type of the arguments |row_ctr| and |field_ctr| from 
from |unsigned int &| to |unsigned int *|.  They are now both optional with
the default 0.
\par
The reason for this is that this function can be called for {\bf INSERT} commands 
or other commands that don't produce a result set.

\initials{LDF 2012.04.30.}
Added optional argument |long *affected_rows| with the default |0|.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
submit_mysql_query(string query,
                   MYSQL_RES*& result,
                   unsigned int *row_ctr = 0, 
                   unsigned int *field_ctr = 0,
                   long *affected_rows = 0);
#endif 

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::submit_mysql_query| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::submit_mysql_query(string query,
                                              MYSQL_RES*& result, 
                                              unsigned int *row_ctr, 
                                              unsigned int *field_ctr,
                                              long *affected_rows)
{
@q ****** (6) @>

     int status;
     int DEBUG = false;  /* |true|  */

     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "]:  "
              << "Entering `submit_mysql_query'."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */

     if (affected_rows)
        *affected_rows = 0L;

@q ****** (6) @>

     if (mysql_query(mysql_ptr, query.c_str()))
     {
         lock_cerr_mutex(); 
         cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
              << "ERROR!  In `Scan_Parse_Parameter_Type::submit_mysql_query':"
              << endl 
              << "`mysql_query' failed:"
              << endl 
              << mysql_error(mysql_ptr)
              << endl 
              << "Exiting function unsuccessfully with return value 1."
              << endl;
         unlock_cerr_mutex(); 

         return 1;
         
     }  /* |if| (|mysql_query| failed.)  */

@q ****** (6) @>

        result = mysql_store_result(mysql_ptr);        

        if (result == 0)
        {
            if (row_ctr)
            {
                lock_cerr_mutex(); 
                cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                     << "WARNING!  In `Scan_Parse_Parameter_Type::submit_mysql_query':"
                     << endl 
                     << "`mysql_store_result' returned " << result
                     << endl
                     << mysql_error(mysql_ptr)
                     << endl 
                     << "Exiting function with return value 0."
                     << endl;
                unlock_cerr_mutex(); 
  
                return 0;

            }  /* |if (row_ctr)|  */
           
            else if (DEBUG) 
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "]:  "
                     << "In `Scan_Parse_Parameter_Type::submit_mysql_query':"
                     << endl 
                     << "`mysql_store_result' returned " << result
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)| */

            
        }  /* |if| (No result)  */

@q ****** (6) @>

        if (row_ctr == 0 || field_ctr == 0)
        {
            if (DEBUG) 
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "]:  "
                     << "In `Scan_Parse_Parameter_Type::submit_mysql_query':"
                     << endl 
                     << "`row_ctr' and/or `field_ctr' is NULL."
                     << endl 
                     << "Not storing rows or columns returned."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)| */


        }   /* |if (row_ctr == 0 || field_ctr == 0)| */

@q ****** (6) @>

        else
        {
            *row_ctr   = mysql_num_rows(result);
            *field_ctr = mysql_num_fields(result);

            if (DEBUG)
            {

                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "]:  "
                     << "In `Scan_Parse_Parameter_Type::submit_mysql_query':"
                     << endl 
                     << "`*row_ctr' == " << *row_ctr 
                     << endl
                     << "`*field_ctr' == " << *field_ctr 
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */

        }  /* |else|  */

@q ****** (6) @>
@
\LOG
\initials{LDF 2012.04.30.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::submit_mysql_query| definition@>=

        if (affected_rows != 0)
        {
            *affected_rows = (long) mysql_affected_rows(mysql_ptr);

            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "]:  "
                     << "In `Scan_Parse_Parameter_Type::submit_mysql_query':"
                     << "`*affected_rows' == " << *affected_rows
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */

        }  /* |if (affected_rows != 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::submit_mysql_query| definition@>=

     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "]:  "
              << "Exiting `Scan_Parse_Parameter_Type::submit_mysql_query' "
              << "successfully with return value 0."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */

    return 0;

@q ****** (6) @>

}  /* End of |submit_mysql_query|  */

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) @>

@q **** (4) Conditionally append to |vector<Entry_Type> entries| .  @>
@ Conditionally append to ``Entries'' vector.
\initials{LDF 2010.03.08.}

This function ensures that there is only one entry per package on 
|entries| (where package name and package version uniquely identify a package).
\par
It tries to find an object in |vector<Entry_Type> entries| equal 
to the |Entry_Type| object passed as an argument.
It uses the equality operator |Entry_Type::operator==|, which returns |true|, if 
the |string| data members |package_name| and |package_version| (of |Entry_Type|) are equal.
\par
If |entries| contains a matching element, the |int install_order| data members are compared 
and the existing |Entry_Type| on the vector has its |install_order| member set to 
the maximum of the two values.
\initials{LDF 2010.03.08.}
\initials{LDF 2012.05.31.}

\LOG
\initials{LDF 2010.03.08.}
Added this function.

\initials{LDF 2012.02.01.}
Added code for setting |iter->encrypted_flag|.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
int
cond_append(Entry_Type &e);

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::cond_append| definition@>=
int
Scan_Parse_Parameter_Type::cond_append(Entry_Type &e)
{
@q ****** (6) @>

   int DEBUG = false;  /* |true|  */

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::cond_append'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

   if (DEBUG) 
      e.show("e:");


@q ****** (6) @>

   vector<Entry_Type>::iterator iter = find(entries.begin(), entries.end(), e);

   if (iter == entries.end())
   {
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::cond_append':"
                << endl
                << e.package_name << " " << e.package_version << " not already on vector.  "
                << "Adding."
                << endl;
           unlock_cerr_mutex(); 
           
       }  /* |if (DEBUG)|  */ 

      entries.push_back(e);

   }  /* |if (iter == entries.end())|  */

   else
   {

        if (DEBUG)
        {
            cerr << "Appending:" << endl;
            iter->show("*iter:");
            e.show("e:");
        
        }  /* |if (DEBUG)|  */ 

       if (iter->installation_script.empty() && !e.installation_script.empty())
           iter->installation_script = e.installation_script;

       if (   iter->installation_script_encrypted.empty() 
           && !e.installation_script_encrypted.empty())
       {
           iter->installation_script_encrypted = e.installation_script_encrypted;
           iter->encrypted_flag = true;
       }

       if (iter->download_url.empty() && !e.download_url.empty())
           iter->download_url = e.download_url;

       if (iter->download_command.empty() && !e.download_command.empty())
       {
           iter->download_command = e.download_command;
       }


       if (iter->download_url_encrypted.empty() && !e.download_url_encrypted.empty())
       {
           iter->download_url_encrypted = e.download_url_encrypted;
           iter->encrypted_flag = true;
       }

       if (iter->download_command_encrypted.empty() && !e.download_command_encrypted.empty())
       {
           iter->download_command_encrypted = e.download_command_encrypted;
           iter->encrypted_flag = true;
       }


       if (iter->owner.empty() && !e.owner.empty())
       {
           iter->owner = e.owner;
           iter->encrypted_flag = true;
       }


       if (iter->owner_key_id <= 0 && e.owner_key_id > 0)
       {
           iter->owner_key_id = e.owner_key_id;
           iter->encrypted_flag = true;
       }


       if (iter->authorization.empty() && !e.authorization.empty())
       {
           iter->authorization = e.authorization;
           iter->encrypted_flag = true;
       }


       if (DEBUG)
       {
           cerr << "iter->authorization == " << iter->authorization << endl;
           cerr << "e.authorization == " << e.authorization << endl;
       }  /* |if (DEBUG)|  */ 

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::cond_append':"
                << endl
                << e.package_name << " " << e.package_version << " is already on vector.  "
                << "Comparing `install_order' values:"
                << endl
                << "`e.install_order' == " << e.install_order
                << endl 
                << "`iter->install_order' == " << iter->install_order
                << endl 
                << "Setting `iter->install_order' to the maximum:  " 
                << max(e.install_order, iter->install_order)
                << endl;
           unlock_cerr_mutex(); 
           
       }  /* |if (DEBUG)|  */ 

       iter->install_order = max(e.install_order, iter->install_order);

   }  /* |else|  */
    

@q ****** (6) @>

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::cond_append' successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

    return 0;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::cond_append(Entry_Type &e)| definition  */

@q ***** (5) @>

@q **** (4) Show.  @>
@ Show.  
\initials{LDF 2009.12.29.}

\LOG
\initials{LDF 2009.12.29.}
Added this function.

\initials{LDF 2010.03.08.}
Now showing more data members.
\ENDLOG

@q *** (3) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

void
show(string s = "Scan_Parse_Parameter_Type:");

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::show| definition@>=

void
Scan_Parse_Parameter_Type::show(string s)
{
@q ***** (5) @>

   cerr << s << endl
        << "user_name == " << user_name
        << endl 
        << "effective_user_name == " << effective_user_name
        << endl 
        << "user_id == " << user_id
        << endl 
        << "effective_user_id == " << effective_user_id
        << endl 
        << "user_dn == " << user_dn
        << endl 
        << "effective_user_dn == " << effective_user_dn
        << endl 
        << "PARSER_DEBUG == " << PARSER_DEBUG
        << endl 
        << "thread_ctr == " << thread_ctr
        << endl 
        << "thread_id == " << thread_id
        << endl 
        << "in_filename == " << in_filename
        << endl 
        << "out_filename == " << out_filename
        << endl 
        << "proxy_cred_filename == " << proxy_cred_filename
        << endl 
        << "start_condition == " << start_condition
        << endl 
        << "date_time_str == " << date_time_str
        << endl
        << "prerequisite_list == " << prerequisite_list
        << endl
        << "server_finished == " << server_finished
        << endl
        << "client_finished == " << client_finished
        << endl
        << "entries.size() == " << entries.size()
        << endl
        << "install_vector.size() == " << install_vector.size()
        << endl
        << "key_name == " << key_name
        << endl
        << "key_id == " << key_id
        << endl
        << "session_id == " << session_id
        << endl
        << "show_options == " << show_options
        << endl
        << "show_environment_shellscript_options == " 
        << show_environment_shellscript_options
        << endl;

   if (show_environment_shellscript_globus_site_set.size() == 0)
      cerr << "show_environment_shellscript_globus_site_set is empty."
           << endl;
   else
   {
      cerr << "show_environment_shellscript_globus_site_set:"
           << endl;

       for (set<string>::const_iterator iter 
               = show_environment_shellscript_globus_site_set.begin();
            iter != show_environment_shellscript_globus_site_set.end();
            ++iter)
       {
            cerr << *iter << endl;
       }

   }  /* |else|  */

   if (remote_ip_address.empty())
      cerr << "remote_ip_address is empty." << endl;
   else
      cerr << "remote_ip_address == " << remote_ip_address << endl;

   cerr << "remote_port == " << remote_port << endl;

#if 0 
   for (vector<class Entry_Type>::const_iterator iter = entries.begin();
        iter != entries.end();
        ++iter)
      iter->show();
#endif 

#if 0 
   for (vector<class Entry_Type>::const_iterator iter = install_vector.begin();
        iter != install_vector.end();
        ++iter)
      iter->show();
#endif 

   if(entry_string_vector.size() == 0)
      cerr << "entry_string_vector is empty." << endl;
   else
   {

       cerr << "entry_string_vector == " << endl;

       for (vector<string>::const_iterator iter = entry_string_vector.begin();
            iter != entry_string_vector.end();
            ++iter)
          cerr << *iter << endl;

   }  /* |else|  */

   if(prerequisite_string_vector.size() == 0)
      cerr << "prerequisite_string_vector is empty." << endl;
   else
   {

       cerr << "prerequisite_string_vector.size() == " << prerequisite_string_vector.size() 
            << endl 
            << "prerequisite_string_vector == " << endl;

       for (vector<string>::const_iterator iter = prerequisite_string_vector.begin();
            iter != prerequisite_string_vector.end();
            ++iter)
          cerr << *iter << endl;

   }  /* |else|  */

   cerr << "download_url_string == " << download_url_string
        << endl 
        << "download_command_string == " << download_command_string
        << endl;
   

   if(globus_site_set.size() == 0)
      cerr << "globus_site_set is empty." << endl;
   else
   {

       cerr << "globus_site_set.size() == " << globus_site_set.size() 
            << endl
            << "globus_site_set == " << endl;

       for (set<string>::const_iterator iter = globus_site_set.begin();
            iter != globus_site_set.end();
            ++iter)
          cerr << *iter << endl;

   }  /* |else|  */

   cerr << "show_level_map.size() == " << show_level_map.size()
        << endl
        << "environment_strm.str() == " << environment_strm.str()
        << endl 
        << "environment_globus_site == " << environment_globus_site
        << endl 
        << "environment_admin_flag == " << environment_admin_flag
        << endl;

   if (environment_shellscript_filename_vector.size() == 0)
       cerr << "environment_shellscript_filename_vector is empty."
            << endl;

   else
   {
       cerr << "environment_shellscript_filename_vector:"
            << endl;

       for (vector<string>::const_iterator iter = environment_shellscript_filename_vector.begin();
            iter != environment_shellscript_filename_vector.end();
            ++iter)
       {

           cerr << *iter << endl;

       }

   }  /* |else|  */

   globus_site_options.show("globus_site_options:");

@q ***** (5) @>

   return;

} /* End of |Scan_Parse_Parameter_Type::show| definition   */

@q **** (4) Fetch installation script. @>

@ Fetch installation script.
\initials{LDF 2010.01.19.}

\LOG
\initials{LDF 2010.01.19.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
fetch_installation_script(Response_Type& response);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::fetch_installation_script(Response_Type& response)
{
@q ****** (6) @>

     int status;
     int DEBUG = false;  /* |true|  */

     MYSQL_RES* result = 0;
     unsigned int row_ctr       = 0;
     unsigned int field_ctr     = 0;

     Response_Type new_response;
     stringstream temp_strm;
 
     ofstream out_strm;

     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "]:  "
              << "Entering `fetch_installation_script'."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */

@q ****** (6) @>
@
@:TODO@> !! TODO:  Make it possible to query for ``public'' entries.
\initials{LDF 2010.01.19.}
\initials{LDF 2010.10.13.}

\LOG
\initials{LDF 2010.10.13.}
Now sorting by |version_ctr| and |last_modified| instead of |version_ctr| alone.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>=

   stringstream sql_strm;

   string owner;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `fetch_installation_script':"
            << endl 
            << "user_id == " << user_id 
            << endl
            << "`response.entry_name' == " << response.entry_name
            << endl 
            << "`response.version' == " << response.version
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

   sql_strm << "select entry_id, installation_script, package_version, encrypted, "
            << "installation_script_encrypted, owner "
            << "from Entries where user_id = " 
            << user_id << " and package_name = '" << response.entry_name << "'";

   if (!response.version.empty())
      sql_strm << " and package_version = '" << response.version << "'";

   sql_strm << " order by version_ctr desc, last_modified desc";
   
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_installation_script':"
            << endl 
            << "`sql_strm.str()' == " << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);

   if (status != 0)
   {
       lock_cerr_mutex();
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_installation_script':"
            << endl 
            << "`submit_mysql_query' failed, returning " << status 
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       { 
          mysql_free_result(result);
          result = 0;
       }

       new_response.type = Response_Type::COMMAND_ONLY_TYPE;

       temp_strm.str("");

       temp_strm << "NO INSTALLATION_SCRIPT FOR ENTRY <" << response.entry_name 
                 << ">";
 
       if (!response.version.empty())
           temp_strm << " <" << response.version << ">";

       temp_strm << " ORDER " << response.install_order; 

       new_response.command = temp_strm.str();

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_front(new_response);
       pthread_mutex_unlock(&response_deque_mutex);

       return 1;

   } /* |if (status != 0)| */

   else if (DEBUG)
   {
       lock_cerr_mutex();
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_installation_script':"
            << endl 
            << "`submit_mysql_query' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 

   if (row_ctr == 0)
   {
       lock_cerr_mutex();
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "WARNING!  In `Scan_Parse_Parameter_Type::fetch_installation_script':"
            << endl 
            << "`submit_mysql_query' returned 0 rows." 
            << endl
            << "Exiting function with return value 2."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       { 
          mysql_free_result(result);
          result = 0;
       }

       new_response.type = Response_Type::COMMAND_ONLY_TYPE;

       temp_strm.str("");

       temp_strm << "NO INSTALLATION_SCRIPT FOR ENTRY <" << response.entry_name 
                 << ">";
 
       if (!response.version.empty())
           temp_strm << " <" << response.version << ">";

       temp_strm << " ORDER " << response.install_order; 

       new_response.command = temp_strm.str();

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_front(new_response);
       pthread_mutex_lock(&response_deque_mutex);

       return 2;

   }  /* |if (row_ctr == 0)| */

   else if (DEBUG) /* |row_ctr > 0|  */
   {
       lock_cerr_mutex();
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_installation_script':"
            << endl 
            << "`submit_mysql_query' returned " << row_ctr << " rows." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)| (|row_ctr > 0|)  */

@q ****** (6) @>
@
\LOG
\initials{LDF 2010.10.13.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>=

   if (row_ctr > 1 && DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_installation_script':"
            << endl 
            << "More than one match for `" << response.entry_name;
 
       if (!response.version.empty())
           cerr<< " " << response.version;

       cerr << "' (" << row_ctr << " matches)." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (row_ctr > 1)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>=

    MYSQL_ROW curr_row;

    if ((curr_row = mysql_fetch_row(result)) == 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_installation_script':"
             << endl 
             << "`mysql_fetch_row' failed:"
             << endl
             << mysql_error(mysql_ptr)
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
        {
           mysql_free_result(result);
           result = 0;
        }

        new_response.type = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm.str("");

        temp_strm << "NO INSTALLATION_SCRIPT FOR ENTRY <" << response.entry_name 
                  << ">";
 
        if (!response.version.empty())
            temp_strm << " <" << response.version << ">";

        temp_strm << " ORDER " << response.install_order; 

        new_response.command = temp_strm.str();

        pthread_mutex_lock(&response_deque_mutex);
        response_deque.push_front(new_response);
        pthread_mutex_unlock(&response_deque_mutex);

        return 1;

    }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */


@q ****** (6) `encrypted' field.  @>
@ \.{encrypted} field.  
\initials{LDF 2011.03.31.}

\LOG
\initials{LDF 2011.03.31.}
Added this section.

\initials{LDF 2011.04.08.}
Now testing whether |curr_row[3]| is empty.
\ENDLOG

@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>=

    if (!curr_row[3] || strlen(curr_row[3]) == 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_installation_script':"
             << endl 
             << "`curr_row[3]' (`encrypted') is NULL or empty."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
        {
           mysql_free_result(result);
           result = 0;
        }

        new_response.type = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm.str("");

        temp_strm << "NO INSTALLATION_SCRIPT FOR ENTRY <" << response.entry_name 
                  << ">";
 
        if (!response.version.empty())
            temp_strm << " <" << response.version << ">";

        temp_strm << " ORDER " << response.install_order; 

        new_response.command = temp_strm.str();

        pthread_mutex_lock(&response_deque_mutex);
        response_deque.push_front(new_response);
        pthread_mutex_unlock(&response_deque_mutex);

        return 1;

    }  /* |if (!curr_row[3] || strlen(curr_row[3]) == 0)|  */

@q ****** (6) Installation script (encrypted or unencrypted).  @>
@ Installation script (encrypted or unencrypted).  
\initials{LDF Date unknown.}

@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>=

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_installation_script':"
             << endl 
             << "`curr_row[0]' == " << curr_row[0]
             << endl 
             << "`curr_row[3]' == " << curr_row[3]
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */


@q ****** (6) @>
@
\LOG
\initials{LDF 2010.03.16.}
Added code for sending a response to the client.

\initials{LDF 2011.03.31.}
Added code to account for encrypted installation scripts.

\initials{LDF 2012.03.28.}
@:BUG FIX@> BUG FIX:  Now calling |mysql_free_result(result)| 
after accessing |curr_row[2]|.  Previously, it was done before, 
which caused a ``Segmentation fault'' error.
\ENDLOG

@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>=

    bool encrypted = atoi(curr_row[3]);
 
    if (curr_row[5] && strlen(curr_row[5]) > 0)  /* \.{owner}  */
       owner = curr_row[5];

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_installation_script':"
             << endl 
             << "`encrypted' == " << encrypted
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    if (   (!encrypted && (curr_row[1] == 0 || strlen(curr_row[1]) == 0))
        || (encrypted && (curr_row[4] == 0 || strlen(curr_row[4]) == 0)))

    {
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::fetch_installation_script':"
                 << endl 
                 << "No installation script.  "
                 << "Exiting function successfully with return value 0."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */ 

        new_response.type = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm.str("");

        temp_strm << "NO INSTALLATION_SCRIPT FOR ENTRY <" << response.entry_name 
                  << ">";

        if (curr_row[2] != 0 && strlen(curr_row[2]) > 0)
        {
           temp_strm << " <" << curr_row[2] << ">";
        }

        temp_strm << " ORDER " << response.install_order; 

        new_response.command = temp_strm.str();

        pthread_mutex_lock(&response_deque_mutex);
        response_deque.push_front(new_response);
        pthread_mutex_unlock(&response_deque_mutex);

        mysql_free_result(result);
        result = 0;

        return 0;

    } /* |if (curr_row[1] == 0 || strlen(curr_row[1]) == 0)| */

@q ****** (6) @>
@
@:TODO@> !! TODO: @:NOTE@> !! PLEASE NOTE: At this point in program run, the
encrypted installation script does not have two newline characters at the end of
it.  In |check_checksum| in \.{scrinstl}, it has them.  I am trying to find out
where they are added.  
\initials{LDF 2011.11.30.}

@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>=

    else if (encrypted && DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_installation_script':"
             << endl 
             << "`curr_row[4]' == " << endl
             << static_cast<char>(12) << curr_row[4] << static_cast<char>(12) 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |else if (DEBUG)|  */ 
    
@q ****** (6) @>

@ @:NOTE@> !! PLEASE NOTE:  In other places, I've changed the code so that a temporary file 
is only created if the size of the data that needs to be stored is greater than 
|MAX_BUFFER|.  This doesn't apply here.  In this case, storing the data in a file 
seems reasonable.  If later it seems desirable to store it in memory, a character buffer 
or |string| in |Response_Type| could be used instead.
\initials{LDF 2010.04.12.}

\LOG
\initials{LDF 2010.04.07.}
Now creating temporary file in \.{/tmp/}.
\ENDLOG

@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>=

    if (curr_row[2] != 0 && strlen(curr_row[2]) > 0)
       response.version = curr_row[2];

    sscanf(curr_row[0], "%d", &new_response.entry_id);

    char temp_filename[14];

    strcpy(temp_filename, "/tmp/EEXXXXXX");

    int temp_fd = mkstemp(temp_filename);

    if (temp_fd == -1)
    {

        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  " 
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_installation_script':  "
             << "`mkstemp' failed, returning -1:"
             << endl;
        perror("Error:");
        cerr << "Exiting function unsuccessfully with return value 1.";
        unlock_cerr_mutex(); 

        temp_strm << "NO INSTALLATION_SCRIPT FOR ENTRY <" << response.entry_name 
                  << ">";
  
        if (curr_row[2] != 0 && strlen(curr_row[2]) > 0)
           temp_strm << " <" << curr_row[2] << ">";

        temp_strm << " ORDER " << response.install_order; 

        new_response.command = temp_strm.str();

        pthread_mutex_lock(&response_deque_mutex);
        response_deque.push_front(new_response);
        pthread_mutex_unlock(&response_deque_mutex);

        if (result)
        {
            mysql_free_result(result);
            result = 0;
        }

        return 1;

    }   /* |if (temp_fd == -1)| (|mkstemp| failed)  */

@q ****** (6) @>

    else /* |mkstemp| succeeded  */
    {

@q ******* (7) @>

@ Close the file descriptor.  We don't need it, we just need the name.  
This is a somewhat roundabout way of doing things, but the functions for generating 
a unique filename only are deprecated and we want to open a {\CPLUSPLUS/} output 
file stream (|ofstream|).
\initials{LDF 2009.10.05.}

@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>=
       
        close(temp_fd);

        temp_file_vector.push_back(string(temp_filename));


@q ******* (7) @>

    }  /* |else| (|mkstemp|) succeeded  */

@q ****** (6) @>

    new_response.local_filename  = temp_filename;

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "response.remote_filename == " << response.remote_filename
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    if (response.remote_filename != "")
    {
       new_response.remote_filename = response.remote_filename;
    }
    else
    {

       new_response.remote_filename = response.entry_name;
       
       string temp_str = response.version;

       response.version = "";

       for (int i = 0; i < temp_str.size(); ++i)
       {
           if (!isblank(response.version[i]))
              response.version += temp_str[i];
       }
 
       if (response.version != "")
       {

          new_response.remote_filename += "_";
          new_response.remote_filename += response.version;
       }

       new_response.remote_filename += "_install.sh";

       string s;

       for (int i = 0; i < new_response.remote_filename.size(); ++i)
       {
          if (isblank(new_response.remote_filename[i]))
             s += "_";
          else
             s += new_response.remote_filename[i];
       }

       new_response.remote_filename = s;

    }  /* |else|  */

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "response.remote_filename == " << response.remote_filename
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    new_response.type = Response_Type::INSTALLATION_SCRIPT_TYPE;

    if (DEBUG) 
    {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_installation_script':"
            << endl;
       new_response.show("new_response:");
       cerr << "new_response.local_filename == " << new_response.local_filename 
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

    out_strm.open(new_response.local_filename.c_str());

    if (!out_strm)
    {

        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_installation_script':"
             << endl 
             << "Failed to open output stream `out_strm' (filename `" 
             << new_response.local_filename << "')."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
        {
           mysql_free_result(result);
           result = 0;
        }

        return 1;

    }  /* |if (!out_strm)| */

    else if (DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_installation_script':"
             << endl 
             << "Opened output stream `out_strm' successfully."
             << endl;

        if (encrypted)
           cerr << "strlen(static_cast<char*>(curr_row[4])) == " 
                << strlen(static_cast<char*>(curr_row[4]));
        else 
           cerr << "strlen(static_cast<char*>(curr_row[1])) == " 
                << strlen(static_cast<char*>(curr_row[1]));

        cerr << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 

    if (encrypted)
       out_strm << static_cast<char*>(curr_row[4]); 
    else
       out_strm << static_cast<char*>(curr_row[1]); 

    out_strm.close();

@q ****** (6) @>
@
\LOG
\initials{LDF 2010.11.11.}
Minor changes to the way words in the string are quoted and separated.
\ENDLOG 
@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>=

   temp_strm.str("");

   temp_strm << "SERVER SENDING INSTALLATION_SCRIPT";

   if (encrypted)
      temp_strm << "_ENCRYPTED";

   temp_strm <<  " <" << new_response.remote_filename
             << "> FOR ENTRY <" << response.entry_name << ">";

   if (curr_row[2] != 0 && strlen(curr_row[2]) > 0)      /* package version */
      temp_strm << " <" << curr_row[2] << ">" << " ";
   else if (encrypted)
      temp_strm << " <-1> ";

   if (curr_row[5] != 0 && strlen(curr_row[5]) > 0)    /* owner  */
      temp_strm << " <" << curr_row[5] << ">" << " ";

@q ****** (6) @>
@
\LOG
\initials{LDF 2011.04.15.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>=

   if (encrypted)   /* \.{Public\_Keys.key\_id}  */
   {
@q ******* (7) @>

      sql_strm.str("");

      sql_strm << "select key_id from Public_Keys where key_name = '"
               << owner << "'";

      if (DEBUG) 
         cerr << "sql_strm.str() == " << sql_strm.str() << endl;
 
      status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);

@q ******* (7) @>

      if (status != 0)
      {
          lock_cerr_mutex();
          cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
               << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_installation_script':"
               << endl 
               << "`submit_mysql_query' failed, returning " << status 
               << endl
               << "Exiting function unsuccessfully with return value 1."
               << endl;
          unlock_cerr_mutex(); 


          temp_strm.str("");

          temp_strm << "NO INSTALLATION_SCRIPT FOR ENTRY <" << response.entry_name 
                    << ">";
 
          if (!response.version.empty())
              temp_strm << " <" << response.version << ">";

          temp_strm << " ORDER " << response.install_order; 

          new_response.command = temp_strm.str();

          pthread_mutex_lock(&response_deque_mutex);
          response_deque.push_front(new_response);
          pthread_mutex_unlock(&response_deque_mutex);

          if (result)
          {
             mysql_free_result(result);
             result = 0;
          } 

          return 1;


      } /* |if (status != 0)| */

@q ******* (7) @>

      else if (DEBUG)
      {
          lock_cerr_mutex();
          cerr << "[Thread " << thread_ctr << "]:  "
               << "In `Scan_Parse_Parameter_Type::fetch_installation_script':"
               << endl 
               << "`submit_mysql_query' succeeded."
               << endl;
          unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)| */


@q ******* (7) @>

      if (row_ctr == 0)
      {
          lock_cerr_mutex();
          cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
               << "WARNING!  In `Scan_Parse_Parameter_Type::fetch_installation_script':"
               << endl 
               << "`submit_mysql_query' returned 0 rows." 
               << endl
               << "Exiting function with return value 1."
               << endl;
          unlock_cerr_mutex(); 

          temp_strm.str("");

          temp_strm << "NO INSTALLATION_SCRIPT FOR ENTRY <" << response.entry_name 
                    << ">";
 
          if (!response.version.empty())
              temp_strm << " <" << response.version << ">";

          temp_strm << " ORDER " << response.install_order; 

          new_response.command = temp_strm.str();

          pthread_mutex_lock(&response_deque_mutex);
          response_deque.push_front(new_response);
          pthread_mutex_unlock(&response_deque_mutex);

          if (result)
          {
             mysql_free_result(result);
             result = 0;
          }

          return 1;


      }  /* |if (row_ctr == 0)| */

@q ******* (7) @>

      else if (DEBUG) /* |row_ctr > 0|  */
      {
          lock_cerr_mutex();
          cerr << "[Thread " << thread_ctr << "]:  "
               << "In `Scan_Parse_Parameter_Type::fetch_installation_script':"
               << endl 
               << "`submit_mysql_query' returned " << row_ctr << " rows." 
               << endl;
          unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)| (|row_ctr > 0|) */

@q ******* (7) @>

      if ((curr_row = mysql_fetch_row(result)) == 0)
      {
          lock_cerr_mutex(); 
          cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
               << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_installation_script':"
               << endl 
               << "`mysql_fetch_row' failed:"
               << endl
               << mysql_error(mysql_ptr)
               << endl 
               << "Exiting function unsuccessfully with return value 1."
               << endl;
          unlock_cerr_mutex(); 

          temp_strm.str("");

          temp_strm << "NO INSTALLATION_SCRIPT FOR ENTRY <" << response.entry_name 
                    << ">";
 
          if (!response.version.empty())
              temp_strm << " <" << response.version << ">";

          temp_strm << " ORDER " << response.install_order; 

          new_response.command = temp_strm.str();

          pthread_mutex_lock(&response_deque_mutex);
          response_deque.push_front(new_response);
          pthread_mutex_unlock(&response_deque_mutex);

          if (result)
          {
             mysql_free_result(result);
             result = 0;
          }

          return 1;


      }  /* |if (curr_row = mysql_fetch_row(result) == 0)| */

@q ******* (7) @>

      else if (DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << "[Thread " << thread_ctr << "]:  "
               << "In `Scan_Parse_Parameter_Type::fetch_installation_script':"
               << endl 
               << "`curr_row[0]' == " << curr_row[0]
               << endl;
          unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)| */

      temp_strm << " <" << curr_row[0] << ">";

@q ******* (7) @>

   }  /* |if (encrypted)|  */

@q ****** (6) @>

   temp_strm << " ORDER " << response.install_order; 


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>=

   if (result)
   {
      mysql_free_result(result);
      result = 0;
   }

@q ****** (6) @>

   new_response.command = temp_strm.str();

   pthread_mutex_lock(&response_deque_mutex);
   response_deque.push_front(new_response);
   pthread_mutex_unlock(&response_deque_mutex);

   server_finished = false;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::fetch_installation_script' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

   return 0;

@q ****** (6) @>

}  /* End of |fetch_installation_script|  */

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Fetch download info. @>

@ Fetch download info.
\initials{LDF 2010.02.02.}

\LOG
\initials{LDF 2010.02.02.}
Added this function.

\initials{LDF 2010.03.29.}
Changed the name of this function from |fetch_download_url| to |fetch_download_info|.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
fetch_download_info(Response_Type& response);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::fetch_download_info(Response_Type& response)
{
@q ****** (6) @>

   int status;
   int DEBUG = false;  /* |true|  */

   MYSQL_RES* result = 0;
   unsigned int row_ctr       = 0;
   unsigned int field_ctr     = 0;
   
   MYSQL_ROW curr_row;
   Response_Type new_response;
   new_response.type = Response_Type::COMMAND_ONLY_TYPE;

   stringstream temp_strm;

   string owner;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `fetch_download_info'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

   stringstream sql_strm;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `fetch_download_info':"
            << endl 
            << "user_id == " << user_id 
            << endl
            << "`response.entry_name' == " << response.entry_name
            << endl 
            << "`response.version' == " << response.version
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
\LOG
\initials{LDF 2010.10.13.}
Now sorting by |version_ctr| and |last_modified| instead of |version_ctr| alone.

\initials{LDF 2011.04.15.}
Now retrieving \.{Public\_Keys.owner\_key\_id}.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

   /* 
      !! TODO:  Make it possible to query for ``public'' entries.
      \initials{LDF 2010.02.02.}
      \initials{LDF 2010.10.13.}
   */

   sql_strm << "select entry_id, download_url, download_command, package_version, "
            << "encrypted, download_url_encrypted, download_command_encrypted, owner "
            << "from Entries where user_id = " << user_id 
            << " and package_name = '" << response.entry_name << "'";

   if (response.version != "")
      sql_strm << " and package_version = '" << response.version << "'";

   sql_strm << " order by version_ctr desc, last_modified desc";

   if (DEBUG)
   {
      lock_cerr_mutex(); 
      cerr << "[Thread " << thread_ctr << "]:  "
           << "In `fetch_download_info':"
           << endl 
           << "`sql_strm.str()' == " 
           << endl 
           << sql_strm.str()
           << endl;      
      unlock_cerr_mutex();  

   }  /* |if (DEBUG)|  */ 

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

   if (status != 0)
   {
       lock_cerr_mutex();
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_download_info':"
            << endl 
            << "`submit_mysql_query' failed, returning " << status 
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);


       temp_strm.str("");

       temp_strm << "SERVER DOWNLOAD_INFO NOT_FOUND FOR ENTRY <"
                 << response.entry_name << ">";

       if (response.version != "")
          temp_strm << " <" << response.version << ">";

       new_response.command = temp_strm.str();

       temp_strm.str("");

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_front(new_response);
       pthread_mutex_unlock(&response_deque_mutex);

       server_finished = false;

       return 1;

   } /* |if (status != 0)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

   else if (DEBUG)
   {
       lock_cerr_mutex();
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_download_info':"
            << endl 
            << "`submit_mysql_query' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

   if (row_ctr == 0)
   {
       lock_cerr_mutex();
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "WARNING!  In `Scan_Parse_Parameter_Type::fetch_download_info':"
            << endl 
            << "`submit_mysql_query' returned 0 rows." 
            << endl
            << "Exiting function with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       temp_strm.str("");

       temp_strm << "SERVER DOWNLOAD_INFO NOT_FOUND FOR ENTRY <"
                 << response.entry_name << ">";

       if (response.version != "")
          temp_strm << " <" << response.version << ">";

       new_response.command = temp_strm.str();

       temp_strm.str("");


       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_front(new_response);
       pthread_mutex_unlock(&response_deque_mutex);

       server_finished = false;

       return 1;

   }  /* |if (row_ctr == 0)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

   else if (DEBUG) /* |row_ctr > 0|  */
   {
       lock_cerr_mutex();
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_download_info':"
            << endl 
            << "`submit_mysql_query' returned " << row_ctr << " rows." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)| (|row_ctr > 0|) */

@q ****** (6) @>
@
\LOG
\initials{LDF 2010.10.13.}
Added this section.
\ENDLOG
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

   if (row_ctr > 1 && DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_download_info':"
            << endl 
            << "More than one match for `" << response.entry_name;
 
       if (!response.version.empty())
           cerr<< " " << response.version;

       cerr << "' (" << row_ctr << " matches)." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (row_ctr > 1)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=


    if ((curr_row = mysql_fetch_row(result)) == 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_download_info':"
             << endl 
             << "`mysql_fetch_row' failed:"
             << endl
             << mysql_error(mysql_ptr)
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);


        temp_strm.str("");

        temp_strm << "SERVER DOWNLOAD_INFO NOT_FOUND FOR ENTRY <"
                  << response.entry_name << ">";

        if (response.version != "")
           temp_strm << " <" << response.version << ">";

        new_response.command = temp_strm.str();

        temp_strm.str("");

        pthread_mutex_lock(&response_deque_mutex);
        response_deque.push_front(new_response);
        pthread_mutex_unlock(&response_deque_mutex);

        server_finished = false;

        return 1;

    }  /* |if (curr_row = mysql_fetch_row(result) == 0)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_download_info':"
             << endl 
             << "`curr_row[0]' == " << curr_row[0]
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)| */

@q ****** (6) @>
@
\LOG
\initials{LDF 2010.03.29.}
Changed this code to account for changes in |zzparse|.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

    temp_strm.str("");

    bool encrypted = false;

    if (curr_row[4] != 0 && atoi(curr_row[4]))
    {
         encrypted = true;

         if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "In `Scan_Parse_Parameter_Type::fetch_download_info':"
                  << endl
                  << "`encrypted' == `true'."
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */ 

    }  /* |if (curr_row[4] != 0 && atoi(curr_row[4]))|  */

    else if (DEBUG)
    {
             lock_cerr_mutex(); 
             cerr << "In `Scan_Parse_Parameter_Type::fetch_download_info':"
                  << endl
                  << "`encrypted' == `false'."
                  << endl;
             unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 



@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

    if ((   !encrypted && (curr_row[1] == 0 || strlen(curr_row[1]) == 0)
         && (curr_row[2] == 0 || strlen(curr_row[2]) == 0))
        ||
        (   encrypted && (curr_row[5] == 0 || strlen(curr_row[5]) == 0) 
         && (curr_row[6] == 0 || strlen(curr_row[6]) == 0)))
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::fetch_download_info':"
             << endl 
             << "No download URL or download command (encrypted or unencrypted).  "
             << "Exiting function unsuccessfully with return value 0."
             << endl;
        unlock_cerr_mutex(); 

        mysql_free_result(result);
        result = 0;

        temp_strm.str("");

        temp_strm << "SERVER DOWNLOAD_INFO NOT_FOUND FOR ENTRY <"
                  << response.entry_name << ">";

        if (response.version != "")
           temp_strm << " <" << response.version << ">";

        new_response.command = temp_strm.str();

        temp_strm.str("");

        pthread_mutex_lock(&response_deque_mutex);
        response_deque.push_front(new_response);
        pthread_mutex_unlock(&response_deque_mutex);

        server_finished = false;

        return 1;

    } /* |if|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

    if (encrypted)
    {
@q ******* (7) @>

      ofstream out_strm;
 
      status = create_temp_file(new_response.local_filename, &out_strm, "WW");
 
      if (status != 0)
      {
          lock_cerr_mutex(); 
          cerr << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_download_info':"
               << endl
               << "`create_temp_file' failed, returning " << status << "."
               << endl 
               << "Exiting function unsuccessfully with return value 1."
               << endl;
           unlock_cerr_mutex(); 

           new_response.local_filename = "";

           if (result) 
             mysql_free_result(result);

           temp_strm.str("");

           new_response.type = Response_Type::COMMAND_ONLY_TYPE;

           temp_strm << "SERVER DOWNLOAD_INFO NOT_FOUND FOR ENTRY <"
                     << response.entry_name << ">";

           if (response.version != "")
              temp_strm << " <" << response.version << ">";

           new_response.command = temp_strm.str();

           temp_strm.str("");

           pthread_mutex_lock(&response_deque_mutex);
           response_deque.push_front(new_response);
           pthread_mutex_unlock(&response_deque_mutex);

           server_finished = false;

           return 1;

      }  /* |if (status != 0)|  */

@q ******* (7) @>
@
\LOG
\initials{LDF 2011.03.30.}
Added code for sending the contents of the |download_command_encrypted| field, 
if present.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

      else if (DEBUG)
      {

          lock_cerr_mutex(); 
          cerr << "In `Scan_Parse_Parameter_Type::fetch_download_info':"
               << endl
               << "`create_temp_file' succeeded."
               << endl;
           unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)|  */ 

      if (curr_row[6] && strlen(curr_row[6]) > 0)
      {

         new_response.type = Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE;

         out_strm << curr_row[6];

         temp_strm << "SERVER SENDING DOWNLOAD_COMMAND_ENCRYPTED ";

      }
      else if (curr_row[5] && strlen(curr_row[5]) > 0)
      {

         new_response.type = Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE;

         out_strm << curr_row[5];
   
         temp_strm << "SERVER SENDING DOWNLOAD_URL_ENCRYPTED ";
      }

      out_strm.close(); 

@q ******* (7) @>

    }  /* |if (encrypted)|  */

@q ****** (6) @>

    else  /* |!encrypted|  */
    {
@q ******* (7) @>

        if (DEBUG) 
        {
           lock_cerr_mutex(); 
           cerr << "`encrypted' == `false'." << endl;
           unlock_cerr_mutex(); 
        }  

        temp_strm << "SERVER SENDING ";

        if (curr_row[1] != 0 && strlen(curr_row[1]) > 0)
           temp_strm << "DOWNLOAD_URL <" << curr_row[1] << "> ";


        if (curr_row[2] != 0 && strlen(curr_row[2]) > 0)
           temp_strm << "DOWNLOAD_COMMAND <" << curr_row[2] << "> ";

@q ******* (7) @>

    }    /* |else| (|!encrypted|)  */

    temp_strm << "FOR ENTRY "
              << "<" << response.entry_name << ">";

    if (curr_row[3] != 0 && strlen(curr_row[3]) > 0)
       temp_strm << " <" << curr_row[3] << ">";
    else if (encrypted)
       temp_strm << " <-1> ";

    if (encrypted && curr_row[7] && strlen(curr_row[7]) > 0)  /* \.{owner}  */
    {
        temp_strm << " <" << curr_row[7] << ">";
        owner = curr_row[7];
        
    }


    mysql_free_result(result);

    result = 0;


@q ******* (7) @>
@
\LOG
\initials{LDF 2011.04.15.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

    if (encrypted)   /* \.{Public\_Keys.key\_id}  */
    {
@q ******** (8) @>

        sql_strm.str("");

        sql_strm << "select key_id from Public_Keys where key_name = '"
                 << owner << "'";

        if (DEBUG) 
           cerr << "sql_strm.str() == " << sql_strm.str() << endl;
 
        status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);

@q ******** (8) @>

        if (status != 0)
        {
            lock_cerr_mutex();
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_download_info':"
                 << endl 
                 << "`submit_mysql_query' failed, returning " << status 
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            if (result) 
               mysql_free_result(result);

            temp_strm.str("");

            temp_strm << "SERVER DOWNLOAD_INFO NOT_FOUND FOR ENTRY <"
                      << response.entry_name << ">";

            if (response.version != "")
               temp_strm << " <" << response.version << ">";

            new_response.command = temp_strm.str();

            temp_strm.str("");

            pthread_mutex_lock(&response_deque_mutex);
            response_deque.push_front(new_response);
            pthread_mutex_unlock(&response_deque_mutex);

            server_finished = false;

            return 1;

        } /* |if (status != 0)| */

@q ******** (8) @>

        else if (DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::fetch_download_info':"
                 << endl 
                 << "`submit_mysql_query' succeeded."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)| */


@q ******** (8) @>

        if (row_ctr == 0)
        {
            lock_cerr_mutex();
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "WARNING!  In `Scan_Parse_Parameter_Type::fetch_download_info':"
                 << endl 
                 << "`submit_mysql_query' returned 0 rows." 
                 << endl
                 << "Exiting function with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            if (result) 
               mysql_free_result(result);

            temp_strm.str("");

            temp_strm << "SERVER DOWNLOAD_INFO NOT_FOUND FOR ENTRY <"
                      << response.entry_name << ">";

            if (response.version != "")
               temp_strm << " <" << response.version << ">";

            new_response.command = temp_strm.str();

            temp_strm.str("");

            pthread_mutex_lock(&response_deque_mutex);
            response_deque.push_front(new_response);
            pthread_mutex_unlock(&response_deque_mutex);

            server_finished = false;

            return 1;

        }  /* |if (row_ctr == 0)| */

@q ******** (8) @>

        else if (DEBUG) /* |row_ctr > 0|  */
        {
            lock_cerr_mutex();
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::fetch_download_info':"
                 << endl 
                 << "`submit_mysql_query' returned " << row_ctr << " rows." 
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)| (|row_ctr > 0|) */

@q ******** (8) @>

        if ((curr_row = mysql_fetch_row(result)) == 0)
        {
            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_download_info':"
                 << endl 
                 << "`mysql_fetch_row' failed:"
                 << endl
                 << mysql_error(mysql_ptr)
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            if (result)
               mysql_free_result(result);

            temp_strm.str("");

            temp_strm << "SERVER DOWNLOAD_INFO NOT_FOUND FOR ENTRY <"
                      << response.entry_name << ">";

            if (response.version != "")
               temp_strm << " <" << response.version << ">";

            new_response.command = temp_strm.str();

            temp_strm.str("");

            pthread_mutex_lock(&response_deque_mutex);
            response_deque.push_front(new_response);
            pthread_mutex_unlock(&response_deque_mutex);

            server_finished = false;

            return 1;

        }  /* |if (curr_row = mysql_fetch_row(result) == 0)| */

@q ******** (8) @>

        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::fetch_download_info':"
                 << endl 
                 << "`curr_row[0]' == " << curr_row[0]
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)| */

        temp_strm << " <" << curr_row[0] << ">";

@q ******** (8) @>

    }  /* |if (encrypted)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=


    temp_strm << " ORDER " << response.install_order; 

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "temp_strm.str() == " << temp_strm.str() << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    new_response.command = temp_strm.str();
 
    pthread_mutex_lock(&response_deque_mutex);
    response_deque.push_front(new_response);
    pthread_mutex_unlock(&response_deque_mutex);

    server_finished = false;

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_download_info':"
            << endl;
       new_response.show("new_response:");
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

    if (result)
       mysql_free_result(result);

    result = 0;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "Exiting `Scan_Parse_Parameter_Type::fetch_download_info' "
             << "successfully with return value 0."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)| */

    return 0;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::fetch_download_info| */

#endif /* |#if HAVE_LIBMYSQLCLIENT| */

@q **** (4) Fetch authorization. @>

@ Fetch authorization.
\initials{LDF 2011.05.06.}

\LOG
\initials{LDF 2011.05.06.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
fetch_authorization(Response_Type& response);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::fetch_authorization(Response_Type& response)
{
@q ****** (6) @>

   int status;
   int DEBUG = false;  /* |true|  */

   MYSQL_RES* result = 0;
   unsigned int row_ctr       = 0;
   unsigned int field_ctr     = 0;
   
   MYSQL_ROW curr_row;
   Response_Type new_response;
   new_response.type = Response_Type::COMMAND_ONLY_TYPE;

   stringstream temp_strm;

   string owner;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `fetch_authorization'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

   stringstream sql_strm;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `fetch_authorization':"
            << endl 
            << "user_id == " << user_id 
            << endl
            << "`response.entry_name' == " << response.entry_name
            << endl 
            << "`response.version' == " << response.version
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

   sql_strm << "select entry_id, authorization, package_version "
            << "from Entries where user_id = " << user_id 
            << " and package_name = '" << response.entry_name << "'";

   if (response.version != "")
      sql_strm << " and package_version = '" << response.version << "'";

   sql_strm << " order by version_ctr desc, last_modified desc";

   if (DEBUG)
   {
      lock_cerr_mutex(); 
      cerr << "[Thread " << thread_ctr << "]:  "
           << "In `fetch_authorization':"
           << endl 
           << "`sql_strm.str()' == " 
           << endl 
           << sql_strm.str()
           << endl;      
      unlock_cerr_mutex();  

   }  /* |if (DEBUG)|  */ 

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

   if (status != 0)
   {
       lock_cerr_mutex();
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_authorization':"
            << endl 
            << "`submit_mysql_query' failed, returning " << status 
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);


       temp_strm.str("");

       temp_strm << "SERVER AUTHORIZATION NOT_FOUND FOR ENTRY <"
                 << response.entry_name << ">";

       if (response.version != "")
          temp_strm << " <" << response.version << ">";

       new_response.command = temp_strm.str();

       temp_strm.str("");

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_front(new_response);
       pthread_mutex_unlock(&response_deque_mutex);

       server_finished = false;

       return 1;

   } /* |if (status != 0)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

   else if (DEBUG)
   {
       lock_cerr_mutex();
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_authorization':"
            << endl 
            << "`submit_mysql_query' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

   if (row_ctr == 0)
   {
       lock_cerr_mutex();
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_authorization':"
            << endl 
            << "`submit_mysql_query' returned 0 rows." 
            << endl
            << "Exiting function with return value 1."
            << endl;
       unlock_cerr_mutex(); 
      
       if (result) 
          mysql_free_result(result);

       temp_strm.str("");

       temp_strm << "SERVER AUTHORIZATION NOT_FOUND FOR ENTRY <"
                 << response.entry_name << ">";

       if (response.version != "")
          temp_strm << " <" << response.version << ">";

       new_response.command = temp_strm.str();

       temp_strm.str("");

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_front(new_response);
       pthread_mutex_unlock(&response_deque_mutex);

       server_finished = false;

       return 1;

   }  /* |if (row_ctr == 0)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

   else if (DEBUG) /* |row_ctr > 0|  */
   {
       lock_cerr_mutex();
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_authorization':"
            << endl 
            << "`submit_mysql_query' returned " << row_ctr << " rows." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)| (|row_ctr > 0|) */

@q ****** (6) @>
@
\LOG
\initials{LDF 2010.10.13.}
Added this section.
\ENDLOG
@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

   if (row_ctr > 1 && DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_authorization':"
            << endl 
            << "More than one match for `" << response.entry_name;
 
       if (!response.version.empty())
           cerr<< " " << response.version;

       cerr << "' (" << row_ctr << " matches)." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (row_ctr > 1)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

    if ((curr_row = mysql_fetch_row(result)) == 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_authorization':"
             << endl 
             << "`mysql_fetch_row' failed:"
             << endl
             << mysql_error(mysql_ptr)
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);


        temp_strm.str("");

        temp_strm << "SERVER AUTHORIZATION NOT_FOUND FOR ENTRY <"
                  << response.entry_name << ">";

        if (!response.version.empty())
           temp_strm << " <" << response.version << ">";

        new_response.command = temp_strm.str();

        temp_strm.str("");

        pthread_mutex_lock(&response_deque_mutex);
        response_deque.push_front(new_response);
        pthread_mutex_unlock(&response_deque_mutex);

        server_finished = false;

        return 1;

    }  /* |if (curr_row = mysql_fetch_row(result) == 0)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_authorization':"
             << endl 
             << "`curr_row[0]' == " << curr_row[0]
             << endl
             << "`curr_row[1]' == " << curr_row[1]
             << endl
             << "`curr_row[2]' == " << curr_row[2]
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)| */

@q ****** (6) @>
@
\LOG
\initials{LDF 2011.07.06.}
Now returning 2 in this case.   This isn't an error:  Non-encrypted entries don't have
authorizations, but it's not known whether an entry is encrypted or not at the time 
\.{optdbcli} creates the response that causes this function to be called.
\par
@:TODO@> !! TODO: 
It would be possible to change the behavior of the programs so that an 
authorization is only requested once it's been determined that an entry is 
encrypted, but this doesn't have a high priority.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

    temp_strm.str("");

    if (curr_row[1] == 0 || strlen(curr_row[1]) == 0)
    {
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::fetch_authorization':"
                 << endl 
                 << "`curr_row[1]' == 0 or `strlen(curr_row[1])' == 0.  "
                 << "No authorization for `" << response.entry_name;

            if (!response.version.empty())
              cerr << " " << response.version << "'";

            cerr << "."
                 << endl 
                 << "Exiting function successfully with return value 2."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */ 

        mysql_free_result(result);

        temp_strm.str("");

        temp_strm << "SERVER AUTHORIZATION NOT_FOUND FOR ENTRY <"
                  << response.entry_name << ">";


        if (!response.version.empty())
           temp_strm << " <" << response.version << ">";

        new_response.command = temp_strm.str();

        temp_strm.str("");

        pthread_mutex_lock(&response_deque_mutex);
        response_deque.push_front(new_response);
        pthread_mutex_unlock(&response_deque_mutex);

        server_finished = false;

        return 2;

    }  /* |if (curr_row[1] == 0 || strlen(curr_row[1]) == 0)|  */

@q ******* (7) @>

      ofstream out_strm;
 
      status = create_temp_file(new_response.local_filename, &out_strm, "YY");
 
      if (status != 0)
      {
          lock_cerr_mutex(); 
          cerr << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_authorization':"
               << endl
               << "`create_temp_file' failed, returning " << status << "."
               << endl 
               << "Exiting function unsuccessfully with return value 1."
               << endl;
           unlock_cerr_mutex(); 

           new_response.local_filename = "";

           mysql_free_result(result);

           temp_strm.str("");

           new_response.type = Response_Type::COMMAND_ONLY_TYPE;

           temp_strm << "SERVER AUTHORIZATION NOT_FOUND FOR ENTRY <"
                     << response.entry_name << ">";

           if (response.version != "")
              temp_strm << " <" << response.version << ">";

           new_response.command = temp_strm.str();

           temp_strm.str("");

           pthread_mutex_lock(&response_deque_mutex);
           response_deque.push_front(new_response);
           pthread_mutex_unlock(&response_deque_mutex);

           server_finished = false;

           return 1;

      }  /* |if (status != 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

      else if (DEBUG)
      {

          lock_cerr_mutex(); 
          cerr << "In `Scan_Parse_Parameter_Type::fetch_authorization':"
               << endl
               << "`create_temp_file' succeeded."
               << endl;
           unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)|  */ 


      new_response.type = Response_Type::AUTHORIZATION_TYPE;

      out_strm << curr_row[1];

      out_strm.close(); 

      temp_strm << "SERVER SENDING AUTHORIZATION ";

      temp_strm << "FOR ENTRY "<< "<" << response.entry_name << ">";

      if (!(curr_row[2] == 0 || strlen(curr_row[2]) == 0))
      {  
         temp_strm << "<" << curr_row[2] << ">";
      }
      else 
         temp_strm << "<-1>";

          
@q ****** (6) @>


@q ******* (7) @>
@

@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

    temp_strm << " ORDER " << response.install_order; 

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "temp_strm.str() == " << temp_strm.str() << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    mysql_free_result(result);

    result = 0;

    new_response.command = temp_strm.str();
 
    pthread_mutex_lock(&response_deque_mutex);
    response_deque.push_front(new_response);
    pthread_mutex_unlock(&response_deque_mutex);

    server_finished = false;

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_authorization':"
            << endl;
       new_response.show("new_response:");
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "Exiting `Scan_Parse_Parameter_Type::fetch_authorization' "
             << "successfully with return value 0."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)| */

    return 0;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::fetch_authorization| */

#endif /* |#if HAVE_LIBMYSQLCLIENT| */

@q **** (4) Fetch prerequisites. @>

@ Fetch prerequisites.
\initials{LDF 2010.03.04.}

\LOG
\initials{LDF 2010.03.04.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
fetch_prerequisites(Response_Type& response);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::fetch_prerequisites| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::fetch_prerequisites(Response_Type& response)
{
@q ****** (6) @>

   int status;
   int DEBUG = false;  /* |true|  */

   MYSQL_RES* result = 0;
   unsigned int row_ctr       = 0;
   unsigned int field_ctr     = 0;
   MYSQL_ROW curr_row;

   Response_Type new_response;
   new_response.type = Response_Type::COMMAND_ONLY_TYPE;

   Entry_Type curr_entry;

   stringstream temp_strm;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `fetch_prerequisites'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_prerequisites| definition@>=

   stringstream sql_strm;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `fetch_prerequisites':"
            << endl 
            << "user_id == " << user_id 
            << endl
            << "`response.entry_name' == " << response.entry_name
            << endl 
            << "`response.version' == " << response.version
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 


@q ****** (6) Get |entry_id|.  @>

@ Get |entry_id|.
\initials{LDF 2010.03.04.}

If |response.version| is empty, the result is ordered by |version_ctr|, descending.
However, |version_ctr| is currently not used.  This code is meant to ensure that 
the most recent version is used if no version is specified.  
Versions can be named and/or numbered in arbitrary ways, so sorting them 
alphabetically or numerically won't work.
\initials{LDF 2010.03.04.}

\LOG
\initials{LDF 2010.10.13.}
Now sorting by |version_ctr| and |last_modified| instead of |version_ctr| alone.
\ENDLOG 


@<|Scan_Parse_Parameter_Type::fetch_prerequisites| definition@>=

   sql_strm << "select entry_id from Entries where user_id = " 
            << user_id << " and package_name = '" << response.entry_name << "'";

   if (response.version != "")
      sql_strm << " and package_version = '" << response.version << "'";

   sql_strm << " order by version_ctr desc, last_modified desc";

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);

@q ****** (6) @>

   if (status != 0)
   {
       lock_cerr_mutex();
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
            << endl 
            << "`submit_mysql_query' failed, returning " << status 
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       temp_strm.str("");

       temp_strm << "SERVER PREREQUISITES NOT_FOUND FOR ENTRY <"
                 << response.entry_name << ">";

       if (response.version != "")
          temp_strm << " <" << response.version << ">";

       new_response.command = temp_strm.str();

       temp_strm.str("");

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_front(new_response);
       pthread_mutex_unlock(&response_deque_mutex);

       server_finished = false;

       return 1;

   } /* |if (status != 0)| */

@q ****** (6) @>

   else if (DEBUG)
   {
       lock_cerr_mutex();
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
            << endl 
            << "`submit_mysql_query' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)| */

@q ****** (6) @>

   if (row_ctr == 0)
   {
       lock_cerr_mutex();
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "WARNING!  In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
            << endl 
            << "`submit_mysql_query' returned 0 rows." 
            << endl
            << "Exiting function with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       temp_strm.str("");

       temp_strm << "SERVER PREREQUISITES NOT_FOUND FOR ENTRY <"
                 << response.entry_name << ">";

       if (response.version != "")
          temp_strm << " <" << response.version << ">";

       new_response.command = temp_strm.str();

       temp_strm.str("");

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_front(new_response);
       pthread_mutex_unlock(&response_deque_mutex);

       server_finished = false;

       return 1;

   }  /* |if (row_ctr == 0)| */

@q ****** (6) @>

   else if (DEBUG) /* |row_ctr > 0|  */
   {
       lock_cerr_mutex();
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
            << endl 
            << "`submit_mysql_query' returned " << row_ctr << " rows." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)| (|row_ctr > 0|) */

@q ****** (6) @>
@
\LOG
\initials{LDF 2010.10.13.}
Added this section.
\ENDLOG
@<|Scan_Parse_Parameter_Type::fetch_prerequisites| definition@>=

   if (row_ctr > 1 && DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
            << endl 
            << "More than one match for `" << response.entry_name;
 
       if (!response.version.empty())
           cerr<< " " << response.version;

       cerr << "' (" << row_ctr << " matches)." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (row_ctr > 1)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_prerequisites| definition@>=



    if ((curr_row = mysql_fetch_row(result)) == 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
             << endl 
             << "`mysql_fetch_row' failed:"
             << endl
             << mysql_error(mysql_ptr)
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        temp_strm.str("");

        temp_strm << "SERVER PREREQUISITES NOT_FOUND FOR ENTRY <"
                  << response.entry_name << ">";

        if (response.version != "")
           temp_strm << " <" << response.version << ">";

        new_response.command = temp_strm.str();

        temp_strm.str("");

        pthread_mutex_lock(&response_deque_mutex);
        response_deque.push_front(new_response);
        pthread_mutex_unlock(&response_deque_mutex);

        server_finished = false;

        return 1;

    }  /* |if (curr_row = mysql_fetch_row(result) == 0)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_prerequisites| definition@>=

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
             << endl 
             << "`curr_row[0]' == " << curr_row[0]
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_prerequisites| definition@>=

   int curr_entry_id = strtol(curr_row[0], 0, 0);

   if (errno != 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
            << endl 
            << "`strtol' failed to convert `" << curr_row[0] << "' to "
            << "an integer:"
            << endl;

       perror("strtol:");

       cerr << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       return 1;

   }  /* |if (errno != 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_prerequisites| definition@>=

   curr_entry.entry_id = curr_entry_id;
   curr_entry.package_name = response.entry_name;
   curr_entry.package_version = response.version;

   if (DEBUG)
   {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
             << endl;

        curr_entry.show("curr_entry:");
        unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 


@q ****** (6) Query for prerequisites.  @>

@ Query for prerequisites.  
\initials{LDF 2010.03.04.}

@<|Scan_Parse_Parameter_Type::fetch_prerequisites| definition@>=

   mysql_free_result(result);

   sql_strm.str("");

   sql_strm << "select prerequisite_id, entry_id from Prerequisites "
            << "where entry_id = " << curr_entry_id 
            << " order by prerequisite_id";

   if (DEBUG)
   {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
             << endl 
             << "`sql_strm.str()' == " << sql_strm.str()
             << endl;
        unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);

@q ****** (6) @>

   if (status != 0)
   {
       lock_cerr_mutex();
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
            << endl 
            << "`submit_mysql_query' failed, returning " << status 
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       temp_strm.str("");

       temp_strm << "SERVER PREREQUISITES NOT_FOUND FOR ENTRY <"
                 << response.entry_name << ">";

       if (response.version != "")
          temp_strm << " <" << response.version << ">";

       new_response.command = temp_strm.str();

       temp_strm.str("");

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_front(new_response);
       pthread_mutex_unlock(&response_deque_mutex);

       server_finished = false;

       return 1;

   } /* |if (status != 0)| */

@q ****** (6) @>

   else if (DEBUG)
   {
       lock_cerr_mutex();
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
            << endl 
            << "`submit_mysql_query' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)| */

@q ****** (6) @>

   if (row_ctr == 0)
   {
       if (DEBUG)
       {
           lock_cerr_mutex();
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
                << endl 
                << "`submit_mysql_query' returned 0 rows." 
                << endl
                << "Exiting function with return value 2."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 

       if (result) 
          mysql_free_result(result);

       temp_strm.str("");

       temp_strm << "SERVER PREREQUISITES NOT_FOUND FOR ENTRY <"
                 << response.entry_name << ">";

       if (response.version != "")
          temp_strm << " <" << response.version << ">";

       new_response.command = temp_strm.str();

       temp_strm.str("");

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_front(new_response);
       pthread_mutex_unlock(&response_deque_mutex);

       server_finished = false;

       return 2;

   }  /* |if (row_ctr == 0)| */

@q ****** (6) @>

   else if (DEBUG) /* |row_ctr > 0|  */
   {
       lock_cerr_mutex();
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
            << endl 
            << "`submit_mysql_query' returned " << row_ctr << " rows." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)| (|row_ctr > 0|) */

@q ****** (6) @>

@ |Scan_Parse_Parameter_Type::fetch_prerequisites| currently doesn't use |field_ctr|, 
but we might as well pass it to it, anyway.  It may be useful for something someday.
\initials{LDF 2010.03.05.}

@<|Scan_Parse_Parameter_Type::fetch_prerequisites| definition@>=

    status = sub_fetch_prerequisites(result, row_ctr, field_ctr, curr_entry);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
             << endl
             << "`sub_fetch_prerequisites' failed, returning " << status
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       temp_strm.str("");

       temp_strm << "SERVER PREREQUISITES NOT_FOUND FOR ENTRY <"
                 << response.entry_name << ">";

       if (response.version != "")
          temp_strm << " <" << response.version << ">";

       new_response.command = temp_strm.str();

       temp_strm.str("");

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_front(new_response);
       pthread_mutex_unlock(&response_deque_mutex);

       server_finished = false;

       return 1;

    }  /* |if (status != 0)|  */

    else if (DEBUG)  /* |status == 0|  */
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
             << endl
             << "`sub_fetch_prerequisites' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)| (|status == 0|)  */ 

    if (result)
       mysql_free_result(result);
   
    result = 0;

@q ****** (6) @>

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
             << endl;
        curr_entry.show("curr_entry:");
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

@q ****** (6) @>

    if (curr_entry.prerequisites.size() > 0)
    {
@q ******* (7) @>

        if (DEBUG)
        {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
                << endl
                << "`curr_entry' (" << curr_entry.package_name << ") "
                << "has prerequisites."
                << endl;
           unlock_cerr_mutex();

        }  /* |if (DEBUG)|  */ 

@q ******* (7) @>


        temp_strm.str("");

        temp_strm << "SERVER PREREQUISITES FOR ENTRY "
              << "<" << response.entry_name << "> ";

        if (response.version != "")
           temp_strm << "<" << response.version << "> ";

        temp_strm << "FOUND ";

        status = curr_entry.extract_prerequisites(this, temp_strm);

        if (DEBUG)
        {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
                << endl
                << "`curr_entry.extract_prerequisites' returned "
                << status << "."
                << endl
                << "`temp_strm.str()' == " << temp_strm.str()
                << endl;
           unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */ 

        new_response.command = temp_strm.str();


        pthread_mutex_lock(&response_deque_mutex);
        response_deque.push_front(new_response);
        pthread_mutex_unlock(&response_deque_mutex);

        server_finished = false;

        if (DEBUG) 
        { 
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
                << endl;
           new_response.show("new_response:");
           unlock_cerr_mutex(); 

        } /* |if (DEBUG)| */

@q ******* (7) @>

    }  /* |if (curr_entry.prerequisites.size() > 0)|  */

@q ****** (6) @>

    else /* |curr_entry.prerequisites.size() == 0|  */
    {
@q ******* (7) @>

        if (DEBUG)
        {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::fetch_prerequisites':"
                << endl
                << "`curr_entry' (" << curr_entry.package_name << ")"
                << "has no prerequisites."
                << endl;
           unlock_cerr_mutex();

        }  /* |if (DEBUG)|  */ 

@q ******* (7) @>

     }  /* |else| (|curr_entry.prerequisites.size() == 0|)  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_prerequisites| definition@>=

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::fetch_prerequisites' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)| */

   return 0;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::fetch_prerequisites| */

#endif /* |#if HAVE_LIBMYSQLCLIENT| */

@q **** (4) |sub_fetch_prerequisites|. @>

@ {\it sub\_fetch\_prerequisites\/}.
\initials{LDF 2010.03.04.}

\LOG
\initials{LDF 2010.03.04.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
sub_fetch_prerequisites(MYSQL_RES* result, 
                        unsigned int row_ctr, 
                        unsigned int field_ctr, 
                        Entry_Type& entry);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::sub_fetch_prerequisites| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::sub_fetch_prerequisites(MYSQL_RES* result, 
                                                   unsigned int row_ctr, 
                                                   unsigned int field_ctr, 
                                                   Entry_Type& entry)
{
@q ****** (6) @>

   int status;
   int DEBUG = false;  /* |true|  */

   MYSQL_ROW curr_row;

   MYSQL_RES* result_1 = 0;
   unsigned int row_ctr_1   = 0;
   unsigned int field_ctr_1 = 0;
   MYSQL_ROW curr_row_1;

   MYSQL_RES* result_2 = 0;
   unsigned int row_ctr_2   = 0;
   unsigned int field_ctr_2 = 0;
   MYSQL_ROW curr_row_2;

   stringstream sql_strm;

   int curr_prerequisite_id = 0;

   for (int i = 0; i < row_ctr; ++i)
   {
@q ******* (7) @>

       if ((curr_row = mysql_fetch_row(result)) == 0)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
                << endl 
                << "`mysql_fetch_row' failed:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           return 1;

       }  /* |if (curr_row = mysql_fetch_row(result) == 0)| */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::sub_fetch_prerequisites| definition@>=

       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
                << endl 
                << "`mysql_fetch_row(result)' succeeded:"
                << endl;

           if (curr_row[0])
               cerr << "`curr_row[0]' == " << curr_row[0];
           else 
               cerr << "`curr_row[0]' == NULL";

           cerr << endl;

           if (curr_row[1])
               cerr << "`curr_row[1]' == " << curr_row[1];
           else 
               cerr << "`curr_row[1]' == NULL";

           cerr << endl;

           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)| */

@q ******* (7) @>

       curr_prerequisite_id = strtol(curr_row[0], 0, 0);

       if (errno != 0)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
                << endl 
                << "`strtol' failed to convert `" << curr_row[0] << "' to "
                << "an integer:"
                << endl;

           perror("strtol:");

           cerr << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 


           return 1;

       }  /* |if (errno != 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::sub_fetch_prerequisites| definition@>=

      sql_strm.str("");

      sql_strm << "select package_name, package_version from Entries "
               << "where entry_id = " << curr_prerequisite_id;

      if (DEBUG)
      {

           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
                << endl 
                << "`sql_strm.str()' == " << sql_strm.str()
                << endl;
           unlock_cerr_mutex();         

      }  /* |if (DEBUG)|  */ 

@q ******* (7) @>

      status = submit_mysql_query(sql_strm.str(),
                                  result_1, 
                                  &row_ctr_1, 
                                  &field_ctr_1);
@q ******* (7) @>

      if (status != 0)
      {
          lock_cerr_mutex();
          cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
               << "ERROR!  In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
               << endl 
               << "`submit_mysql_query' failed, returning " << status 
               << endl
               << "Exiting function unsuccessfully with return value 1."
               << endl;
          unlock_cerr_mutex(); 

          if (result_1) 
             mysql_free_result(result_1);

          return 1;

      } /* |if (status != 0)| */

@q ******* (7) @>

      else if (DEBUG)
      {
          lock_cerr_mutex();
          cerr << "[Thread " << thread_ctr << "]:  "
               << "In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
               << endl 
               << "`submit_mysql_query' succeeded."
               << endl;
          unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)| */

@q ******* (7) @>

      if (row_ctr_1 == 0)
      {
          lock_cerr_mutex();
          cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
               << "WARNING!  In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
               << endl 
               << "`submit_mysql_query' returned 0 rows for the following query:" 
               << endl
               << sql_strm.str()
               << endl 
               << "Continuing."
               << endl;
          unlock_cerr_mutex(); 

          mysql_free_result(result_1);

          continue;
          
      }  /* |if (row_ctr_1 == 0)| */

@q ******* (7) @>

      else if (DEBUG) /* |row_ctr_1 > 0|  */
      {
          lock_cerr_mutex();
          cerr << "[Thread " << thread_ctr << "]:  "
               << "In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
               << endl 
               << "`submit_mysql_query' returned " << row_ctr_1 << " rows." 
               << endl;
          unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)| (|row_ctr_1 > 0|) */

@q ******* (7) @>

      if ((curr_row_1 = mysql_fetch_row(result_1)) == 0)
      {
          lock_cerr_mutex(); 
          cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
               << "ERROR!  In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
               << endl 
               << "`mysql_fetch_row' failed (`curr_row_1'):"
               << endl
               << mysql_error(mysql_ptr)
               << endl 
               << "Exiting function unsuccessfully with return value 1."
               << endl;
          unlock_cerr_mutex(); 

          return 1;

      }  /* |if (curr_row_1 = mysql_fetch_row(result_1) == 0)| */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::sub_fetch_prerequisites| definition@>=

      else if (DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << "[Thread " << thread_ctr << "]:  "
               << "In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
               << endl 
               << "`mysql_fetch_row' succeeded:"
               << endl;

           if (curr_row_1[0])
               cerr << "`curr_row_1[0]' == " << curr_row_1[0];
           else 
               cerr << "`curr_row_1[0]' == NULL";

           cerr << endl;

           if (curr_row_1[1])
               cerr << "`curr_row_1[1]' == " << curr_row_1[1];
           else 
               cerr << "`curr_row_1[1]' == NULL";

           cerr << endl;

          unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)| */

@q ******* (7) @>

      string temp_str;

      if (curr_row_1[1] && strlen(curr_row_1[1]) > 0)
         temp_str = curr_row_1[1];
      else 
         temp_str = "";

      entry.prerequisites.push_back(Entry_Type(curr_prerequisite_id, 
                                               curr_row_1[0], 
                                               temp_str));

@q ******* (7) Inner |for| loop.  @>
@ Inner |for| loop.  

@<|Scan_Parse_Parameter_Type::sub_fetch_prerequisites| definition@>=

      for (int i = 0; i < row_ctr_1; ++i)
      {

@q ******** (8) @>

         sql_strm.str("");

         sql_strm << "select prerequisite_id, entry_id from Prerequisites "
                  << "where entry_id = " << curr_prerequisite_id 
                  << " order by prerequisite_id";


         if (DEBUG)
         {
              lock_cerr_mutex(); 
              cerr << "[Thread " << thread_ctr << "]:  "
                   << "In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
                   << endl 
                   << "`sql_strm.str()' == " << sql_strm.str()
                   << endl;
              unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */ 

         status = submit_mysql_query(sql_strm.str(), result_2, &row_ctr_2, &field_ctr_2);

@q ******** (8) @>

         if (status != 0)
         {
             lock_cerr_mutex();
             cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                  << "ERROR!  In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
                  << endl 
                  << "`submit_mysql_query' failed, returning " << status 
                  << endl
                  << "Exiting function unsuccessfully with return value 1."
                  << endl;
             unlock_cerr_mutex(); 

             if (result_2) 
                mysql_free_result(result_2);

             mysql_free_result(result_1);

             return 1;

         } /* |if (status != 0)| */

@q ******** (8) @>

         else if (DEBUG)
         {
             lock_cerr_mutex();
             cerr << "[Thread " << thread_ctr << "]:  "
                  << "In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
                  << endl 
                  << "`submit_mysql_query' succeeded."
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |else if (DEBUG)| */

@q ******** (8) @>

         if (row_ctr == 0)
         {
             if (DEBUG)
             {
                 lock_cerr_mutex();
                 cerr << "[Thread " << thread_ctr << "]:  "
                      << "In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
                      << endl 
                      << "`submit_mysql_query' returned 0 rows." 
                      << endl
                      << "Continuing."
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */ 

             if (result_2) 
                mysql_free_result(result_2);

             continue;

         }  /* |if (row_ctr == 0)| */

@q ******** (8) @>

         else if (DEBUG) /* |row_ctr > 0|  */
         {
             lock_cerr_mutex();
             cerr << "[Thread " << thread_ctr << "]:  "
                  << "In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
                  << endl 
                  << "`submit_mysql_query' returned " << row_ctr << " rows." 
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |else if (DEBUG)| (|row_ctr > 0|) */

@q ******** (8) @>

         status = sub_fetch_prerequisites(result_2, 
                                          row_ctr_2, 
                                          field_ctr_2, 
                                          entry.prerequisites.back());



@q ******** (8) @>

          if (status != 0)
          {
              lock_cerr_mutex(); 
              cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                   << "ERROR!  In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
                   << endl 
                   << "Recursive call to `sub_fetch_prerequisites' failed, returning "
                   << status
                   << endl
                   << "Exiting function unsuccessfully with return value 1."
                   << endl;
              unlock_cerr_mutex(); 

              mysql_free_result(result_2);
              mysql_free_result(result_1);

              return 1;

          } /* |if (status != 0)|  */

@q ******** (8) @>

          else if (DEBUG)  /* |status == 0|  */
          {
              lock_cerr_mutex(); 
              cerr << "[Thread " << thread_ctr << "]:  "
                   << "In `Scan_Parse_Parameter_Type::sub_fetch_prerequisites':"
                   << endl 
                   << "Recursive call to `sub_fetch_prerequisites' succeeded."
                   << endl;
              unlock_cerr_mutex(); 
 
          }  /* |else if (DEBUG)| (|status == 0|)  */ 

@q ******** (8) @>

          mysql_free_result(result_2);

          curr_prerequisite_id = 0;

@q ******** (8) @>


      }  /* inner |for|  */

      mysql_free_result(result_1);

@q ******* (7) @>

    }  /* outer |for|  */

   return 0;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::sub_fetch_prerequisites| definition  */

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Request prerequisites. @>

@ Request prerequisites.
\initials{LDF 2010.03.05.}

This function is called by the client.
\initials{LDF 2010.03.05.}

\LOG
\initials{LDF 2010.03.05.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
request_prerequisites(string package_name, string package_version = "");

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::request_prerequisites| definition@>=

int
Scan_Parse_Parameter_Type::request_prerequisites(string package_name, string package_version)
{
@q ****** (6) @>

   int status;
   int DEBUG = false;  /* |true|  */

   if (prerequisite_list[prerequisite_list.size() - 1] != ';')
      prerequisite_list += ";";

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::request_prerequisites'."
            << endl;

       cerr << "`package_name' == " << package_name
            << endl 
            << "`package_version' == " << package_version
            << endl 
            << "`prerequisite_list' == " << prerequisite_list 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::request_prerequisites| definition@>=

   
   stringstream temp_strm;
   string curr_str;

   Response_Type response;
   response.type  = Response_Type::COMMAND_ONLY_TYPE;

   string curr_name;
   string curr_version;

   string::size_type start = 0;
   string::size_type end = 0;

   int i = 1;

   string temp_str;

   for(;;)
   {
@q ******* (7) @>

       curr_name    = "";
       curr_version = "";

       start = prerequisite_list.find(";");
       end   = prerequisite_list.find(":");

       if (end == string::npos || start == string::npos || start == end)
          break;

       curr_name = prerequisite_list.substr(start + 1, end - 1);

       while(isblank(curr_name[curr_name.size() - 1]))
          curr_name.erase(curr_name.size() - 1);

       prerequisite_list.erase(start, end);

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::request_prerequisites':"
                << endl
                << "`curr_name' == " << curr_name
                << endl
                << "`prerequisite_list' == " << prerequisite_list
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 

       start = prerequisite_list.find(":");
       end   = prerequisite_list.find(";");

       if (end == string::npos || start == string::npos || start == end)
          break;

       curr_version = prerequisite_list.substr(start + 1, end - 1);

       while(isblank(curr_version[curr_version.size() - 1]))
          curr_version.erase(curr_version.size() - 1);

       prerequisite_list.erase(start, end);
            
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::request_prerequisites':"
                << endl
                << "`curr_version' == " << curr_version
                << endl
                << "`prerequisite_list' == " << prerequisite_list
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 


       curr_str = "";
       temp_strm.str("");

@q ******* (7) @>
@
\LOG
\initials{LDF 2011.03.30.}
\initials{LDF 2011.06.29.}
@:??@> ??:  I had a problem using double-quotation marks to delimit the package name 
and (optional) version of prerequisites:  Two of them were included in the string 
which was ultimately used to query the database.  I think this may have been because 
of the three backslashes surrounded by double-quotation marks in the rule for 
``Delimited value string 2'' (\char`\"$\ldots$\char`\")
in the Flex scanner for \.{optdbsrv} (defined in \filename{scanner.web}).
\par
I solved the problem by using |<>| below to delimit the strings instead.  

\initials{LDF 2012.02.01.}
Added code for fetching ``authorization''.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::request_prerequisites| definition@>=


       temp_strm << "FETCH INSTALLATION_SCRIPT FOR ENTRY " 
                 << "<" << curr_name << ">";

       if (curr_version != "")
         temp_strm << " <" << curr_version << ">";
       
       temp_strm << " ORDER " << i++;

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "`temp_strm.str()' == " << temp_strm.str() 
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

       response.command = temp_strm.str();


       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_back(response);
       pthread_mutex_unlock(&response_deque_mutex);

       curr_str = temp_strm.str();
       curr_str.replace(strlen("FETCH") + 1, 
                 strlen("INSTALLATION_SCRIPT"), 
                 "DOWNLOAD_INFO");

       if (DEBUG)
       {
            cerr << "`curr_str' == " << curr_str << endl;

       }  /* |if (DEBUG)|  */

       response.command = curr_str;


       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_back(response);
       pthread_mutex_unlock(&response_deque_mutex);

       curr_str = temp_strm.str();
       curr_str.replace(strlen("FETCH") + 1, 
                 strlen("INSTALLATION_SCRIPT"), 
                 "AUTHORIZATION");

       if (DEBUG)
       {
            cerr << "`curr_str' == " << curr_str << endl;

       }  /* |if (DEBUG)|  */

       response.command = curr_str;


       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_back(response);
       pthread_mutex_unlock(&response_deque_mutex);


@q ******* (7) @>

   }  /* |for|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::request_prerequisites| definition@>=

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::request_prerequisites' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)| */

   return 0;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::request_prerequisites| */

@q **** (4) Send data to peer.@>

@ send data to peer.
\initials{LDF 2010.01.21.}

\LOG
\initials{LDF 2010.01.21.}
Added this function.

\initials{LDF 2012.03.20.}
Moved the definition of this function from this file (\filename{scprpmtp.web}) 
to \filename{spptsdtp.web}.
\ENDLOG

@q ***** (5) Declaration @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
int
send_data_to_peer(Response_Type& response, bool delete_local_file = false);

@q **** (4) Validate distinguished name. @>

@ Validate distinguished name.
\initials{LDF 2010.02.11.}

This function is called when the client-side user has used a proxy credential
for authentication/authorization.
\initials{LDF 2012.05.09.}

\LOG
\initials{LDF 2010.02.11.}
Added this function.

\initials{LDF 2010.04.21.}
Added code for checking the \filename{grid-mapfile} for Globus Toolkit, if the 
distinguished name is not found in the database.  The default location for 
\filename{grid-mapfile} is \filename{/etc/grid-security/}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
validate_distinguished_name(Response_Type& response);

#endif /* |#if HAVE_LIBMYSQLCLIENT| */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::validate_distinguished_name| definition@>=

#if HAVE_LIBMYSQLCLIENT
int
Scan_Parse_Parameter_Type::validate_distinguished_name(Response_Type& response)
{
@q ****** (6) @>

   int status;
   int DEBUG = false;  /* |true|  */

   MYSQL_RES* result = 0;
   unsigned int row_ctr       = 0;
   unsigned int field_ctr     = 0;
   
   MYSQL_ROW curr_row;
   Response_Type new_response;
   new_response.type = Response_Type::COMMAND_ONLY_TYPE;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `validate_distinguished_name'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::validate_distinguished_name| definition@>=

   stringstream sql_strm;

   Distinguished_Name_Type distinguished_name;
   distinguished_name.set(response.distinguished_name_str);

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `validate_distinguished_name':"
            << endl 
            << "`response.distinguished_name_str' == " << response.distinguished_name_str
            << endl;
       distinguished_name.show("distinguished_name:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

@q ****** (6) @>

    sql_strm << "select user_id, Validity_notBefore, Validity_notAfter "
             << "from Certificates where organization = '" 
             << distinguished_name.organization << "'"
             << " and organizationalUnitName = '" 
             << distinguished_name.organizationalUnitName << "'"
             << " and commonName = '" << distinguished_name.commonName << "'"
             << " and countryName = '" << distinguished_name.countryName << "'";

    if (DEBUG)
    {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `validate_distinguished_name':"
            << endl 
            << "`sql_strm.str()' == " << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

       if (result)
          mysql_free_result(result);

       new_response.command = "SERVER DISTINGUISHED_NAME NOT_FOUND";

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_front(new_response);
       pthread_mutex_unlock(&response_deque_mutex);

       server_finished = false;

       return 1;

    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ******* (7) @>
@ 
@<|Scan_Parse_Parameter_Type::validate_distinguished_name| definition@>=

    if (row_ctr ==  0)
    {
        if (DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "`Scan_Parse_Parameter_Type::validate_distinguished_name':"
                 << endl 
                 << "No rows returned.  Checking `grid-mapfile'."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */ 

        if (result)
           mysql_free_result(result);

        status = check_grid_mapfile(response.distinguished_name_str);

        if (status <= 0)
        {
            lock_cerr_mutex();
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "WARNING!  In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
                 << endl 
                 << "Distinguished name not found in `grid-mapfile'."
                 << endl
                 << "`user_name' == " << user_name
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            new_response.command = "SERVER DISTINGUISHED_NAME NOT_FOUND";


            pthread_mutex_lock(&response_deque_mutex);
            response_deque.push_front(new_response);
            pthread_mutex_unlock(&response_deque_mutex);

            server_finished = false;

            return 1;


        }  /* |if (status <= 0)|  */     

        else /* |status > 0|  */
        {

            user_id = status;

            if (DEBUG)
            {
               lock_cerr_mutex();
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
                    << endl 
                    << "Found distinguished name in `grid-mapfile'.  `user_id' == "
                    << user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */ 

        }  /* |else| (|status > 0|)  */ 

    } /* |if (row_ctr ==  0)| */


@q ******* (7) @>
@ 
@<|Scan_Parse_Parameter_Type::validate_distinguished_name| definition@>=

    else if ((curr_row = mysql_fetch_row(result)) == 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
             << endl 
             << "`mysql_fetch_row' failed:"
             << endl
             << mysql_error(mysql_ptr)
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        return 1;

    }  /* |else if ((curr_row = mysql_fetch_row(result)) == 0)|  */


@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::validate_distinguished_name| definition@>=

    else if (curr_row != 0)
    {
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
                 << endl 
                 << "Showing `curr_row':"
                 << endl;
    
            for (unsigned int i = 0; i < field_ctr; ++i)
            {
               cerr << "Field " << i << ":  ";

               if (curr_row[i] == 0)
                  cerr << "NULL";
               else 
                  cerr << curr_row[i];
      
               cerr << endl;

            }

            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */ 

        sscanf(curr_row[0], "%d", &user_id);

@q ******** (8) Check validity.  @>


@ Check validity.
\initials{LDF 2010.04.27.}

\LOG
\initials{LDF 2010.04.27.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::validate_distinguished_name| definition@>=

        string curr_validity_not_before_str;
        string curr_validity_not_after_str;

        time_t curr_validity_not_before = 0;
        time_t curr_validity_not_after  = 0;

        struct tm tm;
        
        if (curr_row[1])
        {

             curr_validity_not_before_str = curr_row[1];

             if(strptime(curr_validity_not_before_str.c_str(), "%Y-%m-%d %H:%M:%S", &tm))
                curr_validity_not_before = mktime(&tm); 
 
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << "[Thread " << thread_ctr << "]:  "
                      << "In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
                      << endl 
                      << "Validity_notBefore:  "
                      << "`curr_row[1]' == " << curr_row[1]
                      << endl 
                      << "`curr_validity_not_before' == " << curr_validity_not_before
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */

        }  /* |if (curr_row[1])|  */

        else if (DEBUG)
        {
                 lock_cerr_mutex(); 
                 cerr << "[Thread " << thread_ctr << "]:  "
                      << "In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
                      << endl 
                      << "Validity_notBefore == `curr_row[1]' == NULL."
                      << endl;
                 unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */ 

        if (curr_row[2])
        {

             curr_validity_not_after_str = curr_row[2];

             if(strptime(curr_validity_not_after_str.c_str(), "%Y-%m-%d %H:%M:%S", &tm))
                curr_validity_not_after = mktime(&tm); 

             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << "[Thread " << thread_ctr << "]:  "
                      << "In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
                      << endl 
                      << "Validity_notAfter:  "
                      << "`curr_row[2]' == " << curr_row[2]
                      << endl 
                      << "`curr_validity_not_after' == " << curr_validity_not_after
                      << endl;
                 unlock_cerr_mutex(); 

             } /* |if (DEBUG)|  */

        }  /* |if (curr_row[2])|  */

        else if (DEBUG)
        {
                 lock_cerr_mutex(); 
                 cerr << "[Thread " << thread_ctr << "]:  "
                      << "In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
                      << endl 
                      << "Validity_notAfter == `curr_row[2]' == NULL."
                      << endl;
                 unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */ 

@q ********* (9) @>

@ If |curr_validity_not_before <= 0| or |curr_validity_not_after <= 0|, 
it doesn't matter if |time| failed.
\initials{LDF 2010.04.27.}

@<|Scan_Parse_Parameter_Type::validate_distinguished_name| definition@>=

        time_t now = time(0);

        if (now == -1 && (curr_validity_not_before > 0 || curr_validity_not_after > 0))
        {

            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
                 << endl 
                 << "`time' failed, returning -1:"
                 << endl;
            perror("time:");
            cerr << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

           mysql_free_result(result);

           return 1;

        }  /* |if|  */

@q ********* (9) @>

        if (curr_validity_not_before > 0 && now < curr_validity_not_before)
        {
            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
                 << endl 
                 << "Certificate isn't valid yet:"
                 << endl 
                 << "`curr_validity_not_before' == " << curr_validity_not_before
                 << endl 
                 << "`now' == " << now
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

           mysql_free_result(result);

           return 1;


        }  /* |if (curr_validity_not_before > 0 &&  now < curr_validity_not_before)|  */

@q ********* (9) @>

        else if (curr_validity_not_after > 0 && now > curr_validity_not_after)
        {
            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
                 << endl 
                 << "Certificate isn't valid anymore:"
                 << endl 
                 << "`curr_validity_not_after' == " << curr_validity_not_after
                 << endl 
                 << "`now' == " << now
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

           mysql_free_result(result);

           return 1;

        }  /* |if (curr_validity_not_after > 0 &&  now > curr_validity_not_after)|  */


@q ********* (9) @>

        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
                 << endl 
                 << "Certificate is valid."
                 << endl 
                 << "`curr_validity_not_before' == " << curr_validity_not_before
                 << endl 
                 << "`now' ==                      " << now
                 << endl 
                 << "`curr_validity_not_after' ==  " << curr_validity_not_after
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */ 

@q ********* (9) @>

        mysql_free_result(result);
        result = 0;

@q ******** (8) @>

    }  /* |else if (curr_row != 0)|  */

@q ******* (7) @>

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::validate_distinguished_name| definition@>=

    new_response.command = "SERVER DISTINGUISHED_NAME VALIDATED";

    pthread_mutex_lock(&response_deque_mutex);
    response_deque.push_front(new_response);
    pthread_mutex_unlock(&response_deque_mutex);

    server_finished = false;

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::validate_distinguished_name':"
            << endl;
       new_response.show("new_response:");
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::validate_distinguished_name| definition@>=

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::validate_distinguished_name' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::validate_distinguished_name|  */

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */


@q **** (4) Add prerequisite.                                                               @>
@q **** (4) This version is called in |Scan_Parse_Parameter_Type::write_entries|            @>
@q **** (4) and in the following version of |Scan_Parse_Parameter_Type::add_prerequisite|.  @>

@ Add prerequisite.
This version is called in |Scan_Parse_Parameter_Type::write_entries|
and in the following version of |Scan_Parse_Parameter_Type::add_prerequisite|.
\initials{LDF 2010.02.26.}

\noindent
Return values:
\vskip.25\baselineskip
\halign{#:\quad&#\hfil\cr
0&Success\cr
1&SQL query, |mysql_fetch_row| or |strtol| failed\cr
2&No entry that matches this prerequisite\cr
3&Ambiguous match for prerequisite\cr
4&Duplicate prerequisite\cr}

If and only if there are no \.{user} entries, then the 
\.{public} entries are checked.  In either case, if there are multiple entries 
for the prerequisite, the one with the most recent timestamp in 
the |last_modified| field is used, unless the match is ambiguous:  
This can occur if no version number was specified and the results have different 
version numbers.

\LOG
\initials{LDF 2010.02.26.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
add_prerequisite(int curr_entry_id, const Entry_Type&);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::add_prerequisite(int curr_entry_id, const Entry_Type& curr_entry)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    int status = 0;

    stringstream sql_strm;

    MYSQL_RES* result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    unsigned int curr_user_id 
       = (effective_user_id > 0) ? effective_user_id : user_id;

    bool user_entries_not_found = false;

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl;

       cerr << "`curr_entry_id' == " << curr_entry_id 
            << endl
            << "`user_id' == " << user_id 
            << endl
            << "`curr_user_id' == " << curr_user_id 
            << endl;

       curr_entry.show("curr_entry:");

       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */


@q ****** (6) Put SQL query string together.  @>

@ Put SQL query string together.  
\initials{LDF 2010.03.01.}

\LOG
\initials{LDF 2010.03.01.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

   sql_strm << "select entry_id, package_name, package_version from Entries "
            << "where user_id = " << curr_user_id << " and package_name = '" 
            << curr_entry.package_name << "'";

   if (!curr_entry.package_version.empty())
      sql_strm << " and package_version = '" << curr_entry.package_version << "'";

   sql_strm << " order by last_modified desc";
   
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl
            << "`sql_strm.str()' == "
            << endl
            << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
   
@q ****** (6) Submit SQL query.  @>

@ Submit SQL query.  
\initials{LDF 2010.03.01.}

@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, & field_ctr);

@q ******* (7) Failure  @>

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl
            << "`submit_mysql_query' failed, returning " << status
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return 1;

   }  /* |if (status != 0)|  */

@q ******* (7) Success  @>

   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl
            << "`submit_mysql_query' succeeded."
            << endl 
            << "row_ctr == " << row_ctr 
            << endl
            << "field_ctr == " << field_ctr 
            << endl;
       unlock_cerr_mutex(); 
 
  }  /* |if (DEBUG)|  */ 

@q ******* (7) |row_ctr == 0|:  No entry that matches the prerequisite.  @>
@q ******* (7) Check \.{public} entries.                                 @>

@ |row_ctr == 0|:  No \.{user} entry that matches the prerequisite.  
Check \.{public} entries.                                
\initials{LDF 2010.03.01.}

\LOG
\initials{LDF 2010.03.01.}
Added this section.

\initials{LDF 2010.09.15.}
Added code for checking \.{public} entries.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

   if (row_ctr == 0)
   {
@q ******** (8) @>

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
                << endl
                << "`row_ctr == 0"
                << endl 
                << "No `user' entry that matches this prerequisite.  "
                << "Checking `public' entries."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 

       user_entries_not_found = true;

       mysql_free_result(result);

       sql_strm.str("");

       sql_strm << "select entry_id, package_name, package_version from Entries "
                << "where package_name = '" 
                << curr_entry.package_name << "'";

       if (!curr_entry.package_version.empty())
          sql_strm << " and package_version = '" << curr_entry.package_version << "'";

       sql_strm << " and private = false order by last_modified desc";

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
                << endl
                << "`sql_strm.str()' == "
                << endl
                << sql_strm.str()
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 
   
@q ******** (8) Submit SQL query.  @>

@ Submit SQL query.  
\initials{LDF 2010.09.15.}

@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

       status = submit_mysql_query(sql_strm.str(), result, &row_ctr, & field_ctr);

@q ********* (9) Failure  @>

       if (status != 0)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
                << endl
                << "`submit_mysql_query' failed, returning " << status
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           if (result) 
              mysql_free_result(result);

           return 1;

       }  /* |if (status != 0)|  */

@q ********* (9) Success  @>

       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
                << endl
                << "`submit_mysql_query' succeeded."
                << endl 
                << "row_ctr == " << row_ctr 
                << endl
                << "field_ctr == " << field_ctr 
                << endl;
           unlock_cerr_mutex(); 
 
       }      /* |if (DEBUG)|  */ 

@q ********* (9) |row_ctr == 0|:  No \.{public} entry that matches the prerequisite.  @>

@ |row_ctr == 0|:  No \.{public} entry that matches the prerequisite.  
\initials{LDF 2010.09.15.}

\LOG
\initials{LDF 2010.09.15.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

       if (row_ctr == 0)
       {
@q ********** (10) @>

           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
                    << endl
                    << "`row_ctr == 0"
                    << endl 
                    << "No `public' entry that matches this prerequisite."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */ 

@q ********** (10) @>

           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "WARNING!  In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
                << endl
                << "`row_ctr == 0"
                << endl 
                << "No `user' or `public' entry that matches this prerequisite."
                << endl
                << "Not inserting a row in the `Prerequisites' table."
                << endl
                << "Exiting function successfully with return value 2."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           return 2;

@q ********** (10) @>

       }  /* |if (row_ctr == 0)|  */

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

       else if (DEBUG) /* |row_ctr > 0|  (Inner) */
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
                << endl
                << "`public' entry or entries found:"
                << endl 
                << "`row_ctr == " << row_ctr
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)| (|row_ctr > 0|)  */

@q ******** (8) @>

   }  /* |if (row_ctr == 0)|  (Outer) */

@q ******* (7) @>
 
   else if (DEBUG) /* |row_ctr > 0|  (Outer)  */
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl
            << "`user' entry or entries found:"
            << endl 
            << "`row_ctr == " << row_ctr
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)| (|row_ctr > 0|)  */

@q ******* (7) Check for ambiguous match, if |curr_entry.package_version.empty()|.  @>

@ Check for ambiguous match, if |curr_entry.package_version.empty()|.
Loop through the results:  if the version numbers differ,  then the match is ambiguous.
Otherwise, use the first result, which will be the one with the most recent timestamp in 
the |last_modified| field.
\initials{LDF 2010.09.15.}

\LOG
\initials{LDF 2010.09.15.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

   if (row_ctr > 1 && curr_entry.package_version.empty())
   {

      vector<string> temp_row_1;    

      string curr_id;
      string curr_package;
      string curr_version;

      for (int i = 0; i < row_ctr; ++i)
      {
          if ((curr_row = mysql_fetch_row(result)) == 0)
          {
              lock_cerr_mutex(); 
              cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                   << "ERROR!  In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
                   << endl 
                   << "`mysql_fetch_row' failed:"
                   << endl
                   << mysql_error(mysql_ptr)
                   << endl 
                   << "Exiting function unsuccessfully with return value 1."
                   << endl;
              unlock_cerr_mutex(); 

              mysql_free_result(result);

              return 1;

          }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */


#if 0 
          cerr << "curr_version == " << curr_version << endl;
          cerr << "curr_row[2] == " << curr_row[2] << endl;
#endif 

@
\LOG
\initials{LDF 2010.10.08.}
@:BUG FIX@> BUG FIX:  Now checking whether |curr_row[2] == 0| before 
assigning to |curr_version| from it.
\ENDLOG

@:TODO@> !! TODO:  Add error handling for the cases that |curr_row[0]| 
and/or |curr_row[1]| is null.  However, they never should be, so this
isn't urgent.
\initials{LDF 2010.10.08.}

@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

          if (i == 0)
          {
              curr_id = curr_row[0];
              curr_package = curr_row[1];
              curr_version = (curr_row[2] == 0) ? "" : curr_row[2];
          }
@
\LOG
\initials{LDF 2010.10.08.}
Added this conditional.  If |curr_entry.package_version.empty()| and 
one or more entries with this |package_name| but no |package_version| 
exists, then the most recent one will be used.  Otherwise, the most recent 
entry with a version number will be used.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

          if (curr_row[2] == 0)
             break;

@
@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

      }  /* |for|  */

      if (curr_row[2] != 0)
      {
         strcpy(curr_row[0], curr_id.c_str());       /* Put the first results back 
                                                        into |curr_row|  
                                                        \initials{LDF 2010.09.15.} */
         strcpy(curr_row[1], curr_package.c_str());
         strcpy(curr_row[2], curr_version.c_str());
      }

   }  /* |if (row_ctr > 1 && curr_entry.package_version.empty())|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

   else if ((curr_row = mysql_fetch_row(result)) == 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl 
            << "`mysql_fetch_row' failed:"
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       return 1;

   }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl 
            << "`curr_row[0]' == " << curr_row[0]
            << endl 
            << "`curr_row[1]' == " << curr_row[1]
            << endl;
       if (curr_row[2])
           cerr << "`curr_row[2]' == " << curr_row[2];
       else 
           cerr << "`curr_row[2]' == NULL";
       cerr << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

@q ******* (7) Convert |entry_id| of prerequisite to an |int|.  @>

@ Convert |entry_id| of prerequisite to an |int|.  
\initials{LDF 2010.03.01.}


@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

   int prereq_entry_id = strtol(curr_row[0], 0, 0);

   if (errno != 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl 
            << "`strtol' failed to convert `" << curr_row[0] << "' to "
            << "an integer:"
            << endl;

       perror("strtol:");

       cerr << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       return 1;

   }  /* |if (errno != 0)|  */

@q ******* (7) Check for existing row in Prerequisites table.  @>

@ Check for existing row in Prerequisites table.  
\initials{LDF 2010.03.01.}

\LOG
\initials{LDF 2010.03.01.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

   sql_strm.str("");
   mysql_free_result(result);

   sql_strm << "select entry_id, prerequisite_id from Prerequisites "
            << "where entry_id = " << curr_entry_id << " and prerequisite_id = " 
            << prereq_entry_id;

   if (DEBUG)
   {
      lock_cerr_mutex(); 
      cerr << "[Thread " << thread_ctr << "]:  "
          << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
          << endl
          << "`sql_strm.str()' == " 
          << endl 
          << sql_strm.str()
          << endl;
      unlock_cerr_mutex(); 
 
   }  /* |if (DEBUG)|  */ 

@q ******** (8) Submit SQL query.  @>

@ Submit SQL query.  
\initials{LDF 2010.03.04.}

@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);

@q ********* (9) Failure  @>

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl
            << "`submit_mysql_query' (SELECT) failed, returning " 
            << status   
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return 1;

   }  /* |if (status != 0)|  */

@q ********* (9) Success  @>

   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl
            << "`submit_mysql_query' succeeded (SELECT)."
            << endl;
       unlock_cerr_mutex(); 
 
  }  /* |if (DEBUG)|  */ 

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=


  if (row_ctr > 0)
  {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "WARNING!  In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl
            << "Duplicate entry in `Prerequisites' table:"
            << endl
            << "`entry_id' == " << curr_entry_id
            << endl
            << "`prereq_entry_id' == " << prereq_entry_id
            << endl 
            << "Not inserting row.  Exiting function successfully with "
            << "return value 4."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       return 4;

  } /* |if (row_ctr > 0)|  */

@q ******* (7) Not a duplicate.  Insert row into PREREQUISITES table. @>

@ Not a duplicate.  Insert row into \.{PREREQUISITES} table.
\initials{LDF 2010.03.01.}

\LOG
\initials{LDF 2010.03.01.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

   sql_strm.str("");
   mysql_free_result(result);

   sql_strm << "insert into Prerequisites (entry_id, prerequisite_id) values "
            << "(" << curr_entry_id << ", " << prereq_entry_id << ")";


   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl
            << "`sql_strm.str()' == " 
            << endl
            << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

@q ******** (8) Submit SQL query.  @>

@ Submit SQL query.  
\initials{LDF 2010.03.01.}

@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

   status = submit_mysql_query(sql_strm.str(), result, 0, 0);

@q ********* (9) Failure  @>

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl
            << "`submit_mysql_query' failed, returning " << status
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return 1;

   }  /* |if (status != 0)|  */

@q ********* (9) Success  @>

   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 1):"
            << endl
            << "`submit_mysql_query' succeeded."
            << endl;
       unlock_cerr_mutex(); 
 
  }  /* |if (DEBUG)|  */ 


@q ********* (9) @>

@q ******** (8) @>

@q ******* (7) @>

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::add_prerequisite'  (Version 1) successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

   return 0;

}  /* |Scan_Parse_Parameter_Type::add_prerequisite|  */

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Add prerequisite.  @>
@q **** (4) This version is called in |yyparse| @>

@ Add prerequisite.
This version is called in |yyparse|.  It calls the version of |add_prerequisite| 
defined above.
\initials{LDF 2010.03.16.}

\LOG
\initials{LDF 2010.03.16.}
Added this function.

\initials{LDF 2010.03.18.}
Changed the order of the arguments and made them all required.  The previous order 
(|package_name|, |prerequisite_name|, |package_version|, |prerequisite_version|, with 
the |_version| arguments optional) was confusing.  It's no longer necessary, since 
I'm about to replace the four parser rules that call this function with a single 
one.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
add_prerequisite(string package_name, 
                 string package_version,
                 string prerequisite_name,
                 string prerequisite_version);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::add_prerequisite(string package_name, 
                                            string package_version,
                                            string prerequisite_name, 
                                            string prerequisite_version)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    int status = 0;

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::add_prerequisite' (Version 2)."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

    Response_Type response; 
    
    response.type = Response_Type::COMMAND_ONLY_TYPE;       

    stringstream temp_strm;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

    vector<Entry_Type> ev;

    status = get_entries(ev, package_name, package_version);

    if (status != 0)
    {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 2):"
            << endl
            << "`Scan_Parse_Parameter_Type::get_entries' failed, returning "
            << status
            << endl
            << "`package_name' == " << package_name
            << endl
            << "`package_version' == " << package_version
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1; 

    } /* |if (status != 0)| */

    else if (DEBUG)
    {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 2):"
            << endl
            << "`Scan_Parse_Parameter_Type::get_entries' succeeded, returning 0."
            << endl 
            << "`ev.size()' == " << ev.size()
            << endl;
    
       for (vector<Entry_Type>::const_iterator iter = ev.begin();
            iter != ev.end();
            ++iter)
          iter->show();

       unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */

@q ****** (6) Check for ambiguity with respect to the package.  @>

@ Check for ambiguity with respect to the package.  If |package_version| 
is empty and more than one row is returned, then the match is ambiguous and 
it's not possible to determine to which one the prerequisite should be added.  
In this case, no prerequisite is added and a message is sent to the client.
\initials{LDF 2010.09.15.}

\LOG
\initials{LDF 2010.09.10.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

    if (ev.size() > 1 && package_version.empty())
    {

            temp_strm.str(""); 

            temp_strm << "MULTIPLE ENTRIES FOR <" 
                      << package_name 
                      << "> NOT ADDING PREREQUISITE <"
                      << prerequisite_name << ">";

            if (!prerequisite_version.empty())
               temp_strm << " <" << prerequisite_version << ">";

            response.command = temp_strm.str();

            pthread_mutex_lock(&response_deque_mutex);
            response_deque.push_front(response);
            pthread_mutex_unlock(&response_deque_mutex);

            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "]:  "
                     << "In `Scan_Parse_Parameter_Type::add_prerequisite (Version 2)':"
                     << endl 
                     << "`temp_strm.str()' == " << temp_strm.str()
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */ 

            return 0;

    }  /* |if (ev.size() > 1 && package_version.empty())|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

    Entry_Type f;

    f.package_name     = prerequisite_name;
    f.package_version  = prerequisite_version;

    for (vector<Entry_Type>::const_iterator iter = ev.begin();
         iter != ev.end();
         ++iter)
    {
@q ******* (7) @>
    
        status = add_prerequisite(iter->entry_id, f);

@q ******* (7) @>

        if (status == 2)
        {

            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  "
                 << "In `Scan_Parse_Parameter_Type::add_prerequisite (Version 2)':"
                 << endl 
                 << "Call to other version of `Scan_Parse_Parameter_Type::add_prerequisite' "
                 << "failed, returning 2:"
                 << endl
                 << "No entry that matches the prerequisite `" << prerequisite_name << "'";

            if (!prerequisite_version.empty())
               cerr << " `" << prerequisite_version << "'." << endl;
            else 
               cerr << "." << endl;

            cerr << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            temp_strm.str(""); 

            temp_strm << "FAILED TO ADD PREREQUISITE <" << prerequisite_name << ">";

            if (!prerequisite_version.empty())
               temp_strm << " <" <<prerequisite_version << ">";
         
            temp_strm << " FOR ENTRY <" << package_name << ">";

            if (!package_version.empty())
               temp_strm << " <" <<package_version << ">";

            response.command = temp_strm.str();

            pthread_mutex_lock(&response_deque_mutex);
            response_deque.push_front(response);
            pthread_mutex_unlock(&response_deque_mutex);

            return 1;

        } /* |else if (status == 2)| */

@q ******* (7) @>

        else if (status == 3)
        {

            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "WARNING!  "
                 << "In `Scan_Parse_Parameter_Type::add_prerequisite (Version 2)':"
                 << endl 
                 << "Call to other version of `Scan_Parse_Parameter_Type::add_prerequisite' "
                 << "failed, returning 3:"
                 << endl
                 << "Prerequisite `" << prerequisite_name << "' is ambiguous.  Not adding."
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            temp_strm.str(""); 

            temp_strm << "AMBIGUOUS PREREQUISITE <" << prerequisite_name << ">";
         
            temp_strm << " FOR ENTRY <" << package_name << ">";

            if (!package_version.empty())
               temp_strm << " <" <<package_version << ">";

            temp_strm << " NOT ADDING";

            response.command = temp_strm.str();

            pthread_mutex_lock(&response_deque_mutex);
            response_deque.push_front(response);
            pthread_mutex_unlock(&response_deque_mutex);

            return 1;

        } /* |else if (status == 2)| */

@q ******* (7) @>

        else if (status == 4)
        {

            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "WARNING!  "
                 << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 2):"
                 << endl 
                 << "Call to other version of `Scan_Parse_Parameter_Type::add_prerequisite' "
                 << "failed, returning 4:"
                 << endl
                 << "Duplicate prerequisite.  Not adding to `Prerequisites' table."
                 << endl
                 << "Exiting function successfully with return value 2."
                 << endl;
            unlock_cerr_mutex(); 

            temp_strm.str(""); 

            temp_strm << "DUPLICATE PREREQUISITE <" << prerequisite_name << ">";

            if (!prerequisite_version.empty())
               temp_strm << " <" <<prerequisite_version << ">";
         
            temp_strm << " FOR ENTRY <" << package_name << ">";

            if (!package_version.empty())
               temp_strm << " <" <<package_version << ">";

            response.command = temp_strm.str();

            pthread_mutex_lock(&response_deque_mutex);
            response_deque.push_front(response);
            pthread_mutex_unlock(&response_deque_mutex);

            return 2;

        } /* |else if (status == 4)| */

@q ******* (7) @>

        else if (status != 0)
        {

            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  "
                 << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 2):"
                 << endl 
                 << "Call to other version of `Scan_Parse_Parameter_Type::add_prerequisite' "
                 << "failed, returning " << status << "."
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            temp_strm.str(""); 

            temp_strm << "FAILED TO ADD PREREQUISITE <" << prerequisite_name << ">";

            if (!prerequisite_version.empty())
               temp_strm << " <" <<prerequisite_version << ">";
         
            temp_strm << " FOR ENTRY <" << package_name << ">";

            if (!package_version.empty())
               temp_strm << " <" <<package_version << ">";

            response.command = temp_strm.str();

            pthread_mutex_lock(&response_deque_mutex);
            response_deque.push_front(response);
            pthread_mutex_unlock(&response_deque_mutex);

            return 1;

        }  /* |else if (status != 0)|  */
    
@q ******* (7) @>

        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::add_prerequisite' (Version 2):"
                 << endl 
                 << "Call to other version of `Scan_Parse_Parameter_Type::add_prerequisite' "
                 << "succeeded, returning 0."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */

@q ******* (7) @>


    }  /* |for|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>=

    temp_strm.str(""); 

    temp_strm << "ADDED PREREQUISITE <" << prerequisite_name << ">";

    if (!prerequisite_version.empty())
       temp_strm << " <" <<prerequisite_version << ">";
    
    temp_strm << " FOR ENTRY <" << package_name << ">";

    if (!package_version.empty())
       temp_strm << " <" <<package_version << ">";

    response.command = temp_strm.str();

    pthread_mutex_lock(&response_deque_mutex);
    response_deque.push_front(response);
    pthread_mutex_unlock(&response_deque_mutex);

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::add_prerequisite'  (Version 2) "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

   return 0;

}  /* |Scan_Parse_Parameter_Type::add_prerequisite|  */


#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Get entries. @>

@ Get entries.
\initials{LDF 2010.03.16.}

\LOG
\initials{LDF 2010.03.16.}
Added this function.

\initials{LDF 2010.09.09.}
Changed the name of this function from |get_entry| to |get_entries| and
changed its functionality accordingly.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
get_entries(vector<Entry_Type>& ev, 
            string package_name, 
            string package_version = "");

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::get_entries| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::get_entries(vector<Entry_Type>& ev, 
                                       string package_name, 
                                       string package_version)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    int status = 0;

    stringstream sql_strm;

    MYSQL_RES* result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::get_entries':"
            << endl;

       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

    unsigned int curr_user_id 
       = (effective_user_id > 0) ? effective_user_id : user_id;

@q ****** (6) Put SQL query string together.  @>

@ Put SQL query string together.  
\initials{LDF 2010.03.16.}

\LOG
\initials{LDF 2010.10.13.}
Now sorting by |version_ctr| and |last_modified| instead of |version_ctr| alone.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::get_entries| definition@>=

   sql_strm << "select entry_id, package_version from Entries "
            << "where user_id = " << curr_user_id << " and package_name = '" 
            << package_name << "'";

   if (package_version != "")
      sql_strm << " and package_version = '" << package_version << "'";

   sql_strm << " order by version_ctr desc, last_modified desc";
   
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::get_entries':"
            << endl
            << "`sql_strm.str()' == "
            << endl
            << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
   
@q ****** (6) Submit SQL query.  @>

@ Submit SQL query.  
\initials{LDF 2010.03.01.}

@<|Scan_Parse_Parameter_Type::get_entries| definition@>=

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, & field_ctr);

@q ******* (7) Failure  @>

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::get_entries':"
            << endl
            << "`submit_mysql_query' failed, returning " << status
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return 1;

   }  /* |if (status != 0)|  */

@q ******* (7) Success  @>

   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::get_entries':"
            << endl
            << "`submit_mysql_query' succeeded."
            << endl 
            << "row_ctr == " << row_ctr 
            << endl
            << "field_ctr == " << field_ctr 
            << endl;
       unlock_cerr_mutex(); 
 
  }  /* |if (DEBUG)|  */ 

@q ******* (7) |row_ctr == 0|:  No matching entry.  @>

@ |row_ctr == 0|:  No matching entry.
\initials{LDF 2010.03.16.}

@<|Scan_Parse_Parameter_Type::get_entries| definition@>=

   if (row_ctr == 0)
   {

       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "WARNING!  In `Scan_Parse_Parameter_Type::get_entries':"
            << endl
            << "`row_ctr == 0"
            << endl 
            << "No matching entry for " << package_name << " and user_id == " 
            << curr_user_id << "."
            << endl
            << "Exiting function successfully with return value 2."
            << endl;

       unlock_cerr_mutex(); 

       mysql_free_result(result);

       return 2;

   }  /* |if (row_ctr == 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_entries| definition@>=

   else if (DEBUG) /* |row_ctr > 0|  */
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::get_entries':"
            << endl
            << "`row_ctr == " << row_ctr
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)| (|row_ctr > 0|)  */


@q ******* (7) @>
@
\LOG
\initials{LDF 2010.10.13.}
Added this section.
\ENDLOG
@<|Scan_Parse_Parameter_Type::get_entries| definition@>=

   if (row_ctr > 1 && DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::get_entries':"
            << endl 
            << "More than one match for `" << package_name;
 
       if (!package_version.empty())
           cerr<< " " << package_version;

       cerr << "' (" << row_ctr << " matches)." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (row_ctr > 1)|  */


@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_entries| definition@>=

   Entry_Type null_entry;
   Entry_Type e;

   for (int i = 0; i < row_ctr;  ++i)
   {
@q ******** (8) @>

       if ((curr_row = mysql_fetch_row(result)) == 0)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::get_entries':"
                << endl 
                << "`mysql_fetch_row' failed:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           return 1;

       }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::get_entries| definition@>=

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::get_entries':"
                << endl 
                << "`curr_row[0]' == " << curr_row[0]
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

       e = null_entry;

       e.entry_id = strtol(curr_row[0], 0, 0);

       if (errno != 0)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::get_entries':"
                << endl 
                << "`strtol' failed to convert `" << curr_row[0] << "' to "
                << "an integer:"
                << endl;

           perror("strtol:");

           cerr << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           e.entry_id = 0;
 
           ev.push_back(e);

           mysql_free_result(result);

           return 1;

       }  /* |if (errno != 0)|  */
 
       e.package_name    = package_name;

       if (!package_version.empty())
          e.package_version = package_version;
       else if (curr_row[1] && strlen(curr_row[1]) > 0)
          e.package_version = curr_row[1];

       ev.push_back(e);

@q ******** (8) @>

   }  /* |for|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_entries| definition@>=

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::get_entries' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

   return 0;

}  /* |Scan_Parse_Parameter_Type::get_entries|  */


#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Check grid-mapfile. @>

@ Check grid-mapfile.
\initials{LDF 2010.04.21.}

\LOG
\initials{LDF 2010.04.21.}
Added this function.

\initials{LDF 2010.06.30.}
Added argument |bool break_on_found| with the default |false|.
Added code for setting |return_user_id| when |Distinguished_Name_Type distinguished_name| 
is found in the database.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
check_grid_mapfile(string distinguished_name_str, 
                   X509_Cert_Type* cert = 0, 
                   string* user_name = 0,
                   bool break_on_found = false);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::check_grid_mapfile(string distinguished_name_str, 
                                              X509_Cert_Type* cert,
                                              string* user_name,
                                              bool break_on_found)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    MYSQL_RES* result = 0;
    unsigned int row_ctr       = 0;
    unsigned int field_ctr     = 0;
   
    MYSQL_ROW curr_row;

    stringstream sql_strm;

    int status = 0;

    Distinguished_Name_Type distinguished_name;

    string dn;

    struct tm tmp;
    struct tm* tmp_ptr = &tmp;    
    char outstr[256];

    bool new_user = false;

@q ****** (6) @>

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::check_grid_mapfile'."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

      status = check_database_tables();

      if (DEBUG)
      {
          lock_cerr_mutex();
          cerr << "`Scan_Parse_Parameter_Type::check_database_tables' returned "
               << status << "." << endl;
          unlock_cerr_mutex(); 

      }  /* |if (DEBUG)|  */

      if (status < 0)
      {
          lock_cerr_mutex();
          cerr << "ERROR!  In `Scan_Parse_Parameter_Type::check_grid_mapfile':  "
               << "`Scan_Parse_Parameter_Type::check_database_tables' failed, "
               << "returning " << status << "."
               << endl
               << "Will try to continue."
               << endl;
          unlock_cerr_mutex(); 
      }
      else if (DEBUG)
      {
          lock_cerr_mutex();
          cerr << "In `Scan_Parse_Parameter_Type::check_grid_mapfile':  "
               << "`Scan_Parse_Parameter_Type::check_database_tables' succeeded, returning "
               << status << "."
               << endl;
          unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

    if (!distinguished_name_str.empty())
    {
        distinguished_name.set(distinguished_name_str);        

        if (DEBUG)
        {
            lock_cerr_mutex(); 
            distinguished_name.show();
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */ 

    }  /* |if (!distinguished_name_str.empty())|  */

@q ****** (6) @>

    else if (cert != 0)
    {

        distinguished_name = *cert;

        if (DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::check_grid_mapfile':"
                 << endl 
                 << "`string distinguished_name_str' argument is the empty string "
                 << "and `X509_Cert_Type* cert' argument is non-NULL."
                 << endl;

            cert->show("cert:");
            distinguished_name.show("distinguished_name:");
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */    

    }  /* |else if (cert != 0)|  */


@q ****** (6) @>

    else /* |distinguished_name_str.empty() && cert == 0|  */
    {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR! In `Scan_Parse_Parameter_Type::check_grid_mapfile':"
            << endl 
            << "`string distinguished_name_str' argument is the empty string "
            << "and `X509_Cert_Type* cert' argument is NULL."
            << endl 
            << "Can't do anything.  Exiting function unsuccessfully with return value -1."
            << endl;
       unlock_cerr_mutex(); 

       return -1; 

    }  /* |else| (|distinguished_name_str.empty() && cert == 0|)  */

@q ****** (6) Lock database tables `Users' and `Certificates'.  @>

@ Lock database tables `Users' and `Certificates'.  
\initials{LDF 2012.05.11.}

\LOG
\initials{LDF 2012.05.11.}
@:BUG FIX@> BUG FIX:  Added this section with the call to 
|Scan_Parse_Parameter_Type::lock_tables|.  Previously, the |pthread_mutex_t| variables
|db_users_mutex| and |db_certificates_mutex| were locked and unlocked, but this did not 
prevent other MySQL client applications from accessing these tables.
\ENDLOG

@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

   vector<string> lock_table_vector;

   lock_table_vector.push_back("Users");
   lock_table_vector.push_back("Certificates");

   status = lock_tables(&lock_table_vector);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::check_grid_mapfile':"
            << endl
            << "Failed to lock database tables `Users' and `Certificates'."
            << endl
            << "Exiting function unsuccessfully with return value -1."
            << endl;
       unlock_cerr_mutex(); 

       return -1;

   }  /* |if (status != 0)|  */

   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::check_grid_mapfile':"
            << endl
            << "Locked database tables `Users' and `Certificates' successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::check_grid_mapfile':"
            << endl;

       if (cert == 0)
          cerr << "`X509_Cert_Type* cert' argument == 0" 
               << endl;
       else 
          cerr << "`X509_Cert_Type* cert' argument != 0" 
               << endl;

       if (distinguished_name_str.empty())
          cerr << "`distinguished_name_str' argument is the empty string." 
               << endl;
       else 
          cerr << "`distinguished_name_str' argument is a non-empty string." 
               << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

   if (DEBUG)
   {

       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::check_grid_mapfile':"
            << endl
            << "`grid_mapfile_filename' == " << grid_mapfile_filename
            << endl;
       unlock_cerr_mutex(); 
        

   }  /* |if (DEBUG)|  */ 

   ifstream grid_mapfile_strm;
   grid_mapfile_strm.open(grid_mapfile_filename.c_str());

   if (!grid_mapfile_strm.is_open())
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::check_grid_mapfile':"
            << endl
            << "Failed to open grid-mapfile `" << grid_mapfile_filename << "'."
            << endl
            << "Exiting function unsuccessfully with return value -1."
            << endl;
       unlock_cerr_mutex(); 

       unlock_tables();

       return -1;

   }  /* |if (!grid_mapfile_strm.is_open())|  */

   else if (DEBUG)
   {
    
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::check_grid_mapfile':"
            << endl
            << "Opened grid-mapfile `" << grid_mapfile_filename << "' successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
 
@q ****** (6) Scan the grid-mapfile.  @>

@ Scan the grid-mapfile.  
\initials{LDF 2010.04.21.}

@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

@q ******* (7) @>

   char curr_line[512];  /* 512 characters ought to be enough.  \initials{LDF 2010.04.22.}  */

   int return_user_id = -1;

   int user_id = 0;
   int certificate_id = 0;

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

   Distinguished_Name_Type curr_distinguished_name;

   string temp_str;
   string::size_type s;

   string curr_user_name;

   string keyword;
   string value;

   while (grid_mapfile_strm)
   {

@q ******** (8) @>

       grid_mapfile_strm.getline(curr_line, 512);

       if (strlen(curr_line) == 0)
          break;

       dn = curr_line;

       curr_distinguished_name.set(dn, &curr_user_name);

@q ******** (8) @>

       if (DEBUG)
       {
            lock_cerr_mutex(); 
            cerr << "dn == " << dn 
                 << endl;
            curr_distinguished_name.show();
            cerr << "curr_user_name == " << curr_user_name << endl;
            unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 

@q ******** (8) @>
@
\LOG
\initials{LDF 2012.05.10.}
@:BUG FIX@> BUG FIX:  Added this section.  Previously, an existing row in the 
\.{Users} table was not found, if there was no corresponding row in the \.{Certificates}
table.
\ENDLOG

@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

       if (result)
       {
          mysql_free_result(result);
          result = 0;
       }

       sql_strm.str("");

       sql_strm << "select user_id from Users where user_name = '" << curr_user_name << "'";

       if (DEBUG)
       {
           lock_cerr_mutex();
           cerr << "sql_strm.str() == " << sql_strm.str() << endl;
           unlock_cerr_mutex();

       }  /* |if (DEBUG)|  */ 

       status = submit_mysql_query(sql_strm.str(),
                                   result, 
                                   &row_ctr, 
                                   &field_ctr);

       if (status)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                << status << "."
                << endl
                << "Exiting function unsuccessfully with return value -1."
                << endl;
           unlock_cerr_mutex(); 

          if (result) 
             mysql_free_result(result);

          grid_mapfile_strm.close();
          unlock_tables();

          return -1;

       }  /* |if (status)|  */

@q ******** (8) @>

       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

@q ******** (8) @>

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                << endl 
                << "row_ctr == " << row_ctr 
                << endl
                << "field_ctr == " << field_ctr 
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

@q ******** (8) @>

       if (row_ctr > 0)
       {
@q ********* (9) @>

           curr_row = mysql_fetch_row(result);
 
           if (curr_row == 0)
           {

               lock_cerr_mutex(); 
               cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                    << "ERROR!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                    << endl 
                    << "`mysql_fetch_row' failed, returning 0." 
                    << endl
                    << "Exiting function unsuccessfully with return value -1."
                    << endl;
               unlock_cerr_mutex(); 

               mysql_free_result(result);

               grid_mapfile_strm.close();
               unlock_tables();

               return -1;

           }  /* |if (curr_row == 0)|  */

           else if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                    << endl 
                    << "`mysql_fetch_row' succeeded."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |else if (DEBUG)|  */ 

           if (curr_row[0] == 0 || strlen(curr_row[0]) == 0)
           {
               lock_cerr_mutex(); 
               cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                    << "ERROR!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                    << endl 
                    << "`curr_row[0]' is NULL or empty.  This shouldn't be possible."
                    << endl
                    << "Exiting function unsuccessfully with return value -1."
                    << endl;
               unlock_cerr_mutex(); 

               mysql_free_result(result);

               grid_mapfile_strm.close();
               unlock_tables();
   
               return -1;

           }  /* |if (curr_row[0] == 0 || strlen(curr_row[0]) == 0)|  */

           user_id = atoi(curr_row[0]);

           if (DEBUG)
           {
               lock_cerr_mutex();
               cerr << "Found `user_id'.  `user_id' == " << user_id << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */ 
       
@q ********* (9) @>

           if (result)
           {
             mysql_free_result(result);
             result = 0;
           }

       }  /* |if (row_ctr > 0)|  */
       
@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

       else  /* |row_ctr == 0|  */
       {

@q ********* (9) Get next value for |Users.user_id|.  @>

@ Get next values for |Users.user_id|.
\initials{LDF 2012.05.10.}

\LOG
\initials{LDF 2012.05.10.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

           if (result)
           {
              mysql_free_result(result);
              result = 0;
           }

           sql_strm.str("");

           sql_strm << "select user_id from Users order by user_id desc limit 1";

           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                    << endl 
                    << "`sql_strm.str()' == "
                    << endl 
                    << sql_strm.str()
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */

@q ********** (10) @>

           status = submit_mysql_query(sql_strm.str(),
                                       result, 
                                       &row_ctr, 
                                       &field_ctr);

           if (status)
           {
               lock_cerr_mutex(); 
               cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                    << "WARNING!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                    << endl 
                    << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                    << status << "."
                    << endl
                    << mysql_error(mysql_ptr)
                    << endl 
                    << "Exiting function unsuccessfully with return value -1."
                    << endl;
               unlock_cerr_mutex(); 

              if (result) 
                 mysql_free_result(result);

              grid_mapfile_strm.close();
              unlock_tables();

              return -1;


           }  /* |if (status)|  */

           else if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                    << endl 
                    << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */

           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                    << endl 
                    << "row_ctr == " << row_ctr 
                    << endl
                    << "field_ctr == " << field_ctr 
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */

@q ********** (10) @>

           if (row_ctr == 0)  
           {
               lock_cerr_mutex(); 
               cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                    << "ERROR!  In `Scan_Parse_Parameter_Type::check_gridmap_file':  "
                    << "Failed to find `Users.user_id' This shouldn't ever happen."
                    << endl 
                    << "Exiting function unsuccessfully with return value -1."
                    << endl;
               unlock_cerr_mutex(); 

               if (result)
                  mysql_free_result(result);


               grid_mapfile_strm.close();
               unlock_tables();

               return -1;

           }     /* |if (row_ctr == 0)| */

@q ********** (10) @>

           if ((curr_row = mysql_fetch_row(result)) == 0)
           {
               lock_cerr_mutex(); 
               cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                    << "ERROR!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                    << endl 
                    << "`mysql_fetch_row' failed:"
                    << endl
                    << mysql_error(mysql_ptr)
                    << endl 
                    << "Exiting function unsuccessfully with return value -1."
                    << endl;
               unlock_cerr_mutex(); 

               if (result)
                  mysql_free_result(result);

               grid_mapfile_strm.close();
               unlock_tables();

               return -1;

           }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ********** (10) @>

           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                    << endl 
                    << "`curr_row[0]' == " << curr_row[0]
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */


@q ********** (10) @>

           if (curr_row[0] && strlen(curr_row[0]) > 0)
           {
              sscanf(curr_row[0], "%d", &user_id);

              new_user = true;

              ++user_id;

              mysql_free_result(result);
              result = 0;

           }

@q ********** (10) @>

           else
           {
               lock_cerr_mutex(); 
               cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                    << "ERROR!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                    << endl 
                    << "`curr_row[0]' is NULL or empty.  "
                    << "Can't set `user_id'."
                    << endl                       
                    << "Exiting function unsuccessfully with return value -1."
                    << endl;
               unlock_cerr_mutex(); 

               mysql_free_result(result);

               grid_mapfile_strm.close();
               unlock_tables();

               return -1;

           }  /* |else|  */
                     
@q ********** (10) @>
    
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                    << endl 
                    << "Next `user_id' == " << user_id
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */ 

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

           if (result)
           {
               mysql_free_result(result);
               result = 0;
           }

           sql_strm.str("");

           sql_strm << "insert into Users (user_id, user_name) values ("
                    << user_id << ", '" << curr_user_name << "')";

           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "sql_strm.str() == " << sql_strm.str() << endl;
               unlock_cerr_mutex(); 
 
           }  /* |if (DEBUG)|  */ 

           status = submit_mysql_query(sql_strm.str(),
                                       result);

           if (status)
           {
               lock_cerr_mutex(); 
               cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                    << "ERROR!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                    << endl 
                    << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                    << status << "."
                    << endl
                    << "Exiting function unsuccessfully with return value -1."
                    << endl;
               unlock_cerr_mutex(); 

              if (result) 
                 mysql_free_result(result);

              grid_mapfile_strm.close();
              unlock_tables();

              return -1;

           }  /* |if (status)|  */

           else if (DEBUG)
           {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr << "]:  "
                        << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                        << endl 
                        << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                        << endl
                        << "Added row to `Users' database:  `user_id' == " << user_id
                        << ", `user_name' == " << curr_user_name << "."
                        << endl;
                   unlock_cerr_mutex(); 

           }      /* |if (DEBUG)|  */

           mysql_free_result(result);
           result = 0;
           sql_strm.str("");

@q ********* (9) @>

       }  /* |else| (|row_ctr == 0|)  */

@q ******** (8) Check whether entry already exists in the {\bf Certificates} @>
@q ******** (8) database table.                                              @>

@ Check whether entry already exists in the {\bf Certificates} and database table.
\initials{LDF 2012.05.10.}

\LOG
\initials{LDF 2010.04.22.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

       if (result)
       {
          mysql_free_result(result);
          result = 0;
       }
       sql_strm.str("");

       sql_strm << "select certificate_id, user_id "
                << "from Certificates where "
                << "commonName = '" << curr_distinguished_name.commonName 
                << "' and "  
                << "organization = '" << curr_distinguished_name.organization 
                << "' and "  
                << "organizationalUnitName = '" 
                << curr_distinguished_name.organizationalUnitName
                << "' and "  
                << "countryName = '" << curr_distinguished_name.countryName << "'";


@q ******** (8) @>

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "sql_strm.str() == " << sql_strm.str() << endl;
           unlock_cerr_mutex(); 
 
       }  /* |if (DEBUG)|  */ 

@q ******** (8) @>

       status = submit_mysql_query(sql_strm.str(),
                                   result, 
                                   &row_ctr, 
                                   &field_ctr);

       if (status)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                << status << "."
                << endl
                << "Exiting function unsuccessfully with return value -1."
                << endl;
           unlock_cerr_mutex(); 

          if (result) 
             mysql_free_result(result);

          grid_mapfile_strm.close();
          unlock_tables();   

          return -1;

       }  /* |if (status)|  */

@q ******** (8) @>

       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

@q ******** (8) @>

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                << endl 
                << "row_ctr == " << row_ctr 
                << endl
                << "field_ctr == " << field_ctr 
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

 
@q ******** (8) @>

       if (row_ctr == 0)  
       {
@q ********* (9) @>

           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::check_gridmap_file':  "
                << "No database entries for this X.509 certificate.  Will add."
                << endl;

           unlock_cerr_mutex(); 


@q ********* (9) Get next value for |Certificates.certificate_id|.  @>

@ Get next value for |Certificates.certificate_id|.
\initials{LDF 2010.04.22.}
\initials{LDF 2012.05.10.}

@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

   if (result) 
   {
       mysql_free_result(result);
       result = 0;
   }

   sql_strm.str("");

   sql_strm << "select certificate_id from Certificates order "
            << "by certificate_id desc limit 1";


   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
            << endl 
            << "`sql_strm.str()' == "
            << endl 
            << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */


   status = submit_mysql_query(sql_strm.str(),
                               result, 
                               &row_ctr, 
                               &field_ctr);

   if (status)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "WARNING!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
            << status << ":"
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Exiting function unsuccessfully with return value -1."
            << endl;
       unlock_cerr_mutex(); 

      if (result) 
         mysql_free_result(result);

      grid_mapfile_strm.close();
      unlock_tables();
   
      return -1;

   }  /* |if (status)|  */

   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
            << endl 
            << "row_ctr == " << row_ctr 
            << endl
            << "field_ctr == " << field_ctr 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

   if (row_ctr == 0)  
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::check_gridmap_file':  "
            << "Failed to find `Certificates.certificate_id'.  This shouldn't ever happen."
            << endl 
            << "Exiting function unsuccessfully with return value -1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
          mysql_free_result(result);

       grid_mapfile_strm.close();
       unlock_tables();

       return -1;

   }     /* |if (row_ctr == 0)| */

   if ((curr_row = mysql_fetch_row(result)) == 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
            << endl 
            << "`mysql_fetch_row' failed:"
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Exiting function unsuccessfully with return value -1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
          mysql_free_result(result);

       grid_mapfile_strm.close();
       unlock_tables();

       return -1;

   }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
            << endl 
            << "`curr_row[0]' == " << curr_row[0]
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

   if (curr_row[0])
   {
      sscanf(curr_row[0], "%d", &certificate_id);

      ++certificate_id;

      mysql_free_result(result);
      result = 0;

   }

   else
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
            << endl 
            << "`curr_row[0]' is NULL.  "
            << "Can't set `certificate_id'."
            << endl                       
            << "Exiting function unsuccessfully with return value -1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       grid_mapfile_strm.close();
       unlock_tables();

       return -1;

   }  /* |else|  */
                 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
            << endl 
            << "Next `certificate_id' == " << certificate_id
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

@q ********* (9) Insert row into the {\bf Certificates} database table.  @>

@ Insert entries into the {\bf Certificates} database table.
\initials{LDF 2010.04.21.}
\initials{LDF 2012.05.10.}

@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

           if (result)
           {
              mysql_free_result(result);
              result = 0;
           }

          sql_strm.str("");

          sql_strm << "insert into Certificates (certificate_id, user_id, "
                   << "issuer_cert_id, is_ca, is_proxy, serialNumber, "
                   << "organization, organizationalUnitName, commonName, "
                   << "countryName, localityName, stateOrProvinceName, "
                   << "Validity_notBefore, Validity_notAfter) "
                   << "values (" 
                   << certificate_id << ", " 
                   << user_id << ", "
                   << 1 << ", "
                   << "'false', "
                   << "'false', ";

          if (cert && cert->commonName == curr_distinguished_name.commonName)
             sql_strm << cert->serialNumber << ", ";
          else
             sql_strm << "NULL, ";

          sql_strm << "'" << curr_distinguished_name.organization << "', "
                   << "'" << curr_distinguished_name.organizationalUnitName << "', "
                   << "'" << curr_distinguished_name.commonName << "', "
                   << "'" << curr_distinguished_name.countryName << "', "
                   << "NULL, " 
                   << "NULL, ";

          memset(outstr, 0, 256);

          if (cert && cert->commonName == curr_distinguished_name.commonName)
          {
            if (cert->Validity_notBefore > 0)
            {
               gmtime_r(&(cert->Validity_notBefore), tmp_ptr);     
               if (!(   tmp_ptr == 0 
                     || strftime(outstr, sizeof(outstr), "%Y-%m-%d %H:%M:%S UTC", tmp_ptr) == 0)) 
                  sql_strm << "'" << outstr << "', ";
 
            }
            else 
               sql_strm << "NULL, ";

            memset(outstr, 0, 256);

            if (cert->Validity_notAfter > 0)
            {
               gmtime_r(&(cert->Validity_notAfter), tmp_ptr);     
               if (!(   tmp_ptr == 0 
                     || strftime(outstr, sizeof(outstr), "%Y-%m-%d %H:%M:%S UTC", tmp_ptr) == 0)) 
                  sql_strm << "'" << outstr << "'";
 
            }
            else 
               sql_strm << "NULL";

          }

          else
             sql_strm << "NULL, NULL";

          sql_strm << ")";

          if (DEBUG)
          {
              lock_cerr_mutex(); 
              cerr << "sql_strm.str() == " << sql_strm.str() << endl;
              unlock_cerr_mutex(); 
 
          }  /* |if (DEBUG)|  */ 


          status = submit_mysql_query(sql_strm.str(),
                                      result);

          if (status)
          {
              lock_cerr_mutex(); 
              cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                   << "ERROR!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                   << endl 
                   << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                   << status << "."
                   << endl
                   << "Exiting function unsuccessfully with return value -1."
                   << endl;
              unlock_cerr_mutex(); 

             if (result) 
                mysql_free_result(result);

             grid_mapfile_strm.close();
             unlock_tables();

             return -1;

          }  /* |if (status)|  */

          else if (DEBUG)
          {
              lock_cerr_mutex(); 
              cerr << "[Thread " << thread_ctr << "]:  "
                   << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                   << endl 
                   << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                   << endl;
              unlock_cerr_mutex(); 

          }  /* |if (DEBUG)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

          if (curr_distinguished_name == distinguished_name)
          {

              if (DEBUG)
              {
                  lock_cerr_mutex(); 
                  cerr << "`curr_distinguished_name' == `distinguished_name'."
                       << endl;
                  unlock_cerr_mutex(); 

               }  /* |if (DEBUG)|  */  

               return_user_id = user_id; 
               
               if (user_name)
                   *user_name = curr_user_name;

          } /* |if (curr_distinguished_name == distinguished_name)| */

          else if (DEBUG) 
          {
              lock_cerr_mutex(); 
              cerr << "`curr_distinguished_name' != `distinguished_name'."
                   << endl;

              unlock_cerr_mutex(); 
          }

          if (result)
          {
             mysql_free_result(result);
             result = 0;
          }

@q ********* (9) @>

       }  /* |if (row_ctr == 0)|  */

@q ******** (8) Row exists in Certificates table.  @>

@ Row exists in \.{Certificates} table.  
\initials{LDF Undated.}

@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

       else /* |row_ctr > 0|  */
       {
@q ********* (9) @>

           if (DEBUG)
           {
              lock_cerr_mutex(); 
              cerr << "[Thread " << thread_ctr << "]:  "
                   << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                   << endl 
                   << "Database entries found for this Distinguished Name.  Checking fields."
                   << endl;
              unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */ 

@q ********* (9) Error checking.  @>

@ Error checking.  A mismatch of |curr_row[1]| and |user_id| should never occur.  If it does,
then the \.{Users} database table has probably been corrupted.
\initials{LDF 2012.05.11.}

@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

           if (curr_row[1] && strlen(curr_row[1]))
           {
@q ********** (10) @>

               if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr << "]:  "
                        << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                        << endl 
                        << "`curr_row[1]' == " << curr_row[1]
                        << endl;
                   unlock_cerr_mutex(); 
               }  /* |if (DEBUG)|  */ 

@q ********** (10) @>

               if (atoi(curr_row[1]) != user_id)
               {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr << "]:  "
                        << "ERROR!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                        << endl 
                        << "`user_id' mismatch:  `curr_row[1]' == " << curr_row[1]
                        << endl 
                        << "`user_id' == " << user_id
                        << endl
                        << "This shouldn't be possible."
                        << endl
                        << "Will try to continue, but database administrator "
                        << "should check rows `Entries' in table belonging to this user."
                        << endl;
                   unlock_cerr_mutex(); 

               }  /* |if (atoi(curr_row[1]) != user_id)|  */
 
@q ********** (10) @>

               else if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr << "]:  "
                        << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                        << endl 
                        << "`user_id' match:  `curr_row[1]' == " << curr_row[1]
                        << endl 
                        << "`user_id' == " << user_id
                        << endl;
                   unlock_cerr_mutex(); 

               }  /* |else if (DEBUG)|  */ 

@q ********** (10) @>

           }  /* |if (curr_row[1] && strlen(curr_row[1]))|  */

@q ********* (9) @>

           else
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "WARNING!  In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                    << endl 
                    << "`curr_row[1]' is NULL or empty."
                    << endl
                    << "This shouldn't be possible."
                    << endl;
               unlock_cerr_mutex(); 
           }

@q ********* (9) @>

           if (curr_distinguished_name == distinguished_name)
           {
@q ********** (10) @>

              sscanf(curr_row[0], "%d", &return_user_id);
              
              if (user_name)
                 *user_name = curr_row[1];

@q ********** (10) @>

              if (DEBUG) 
              {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr << "]:  "
                        << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                        << endl 
                        << "`curr_distinguished_name' == `distinguished_name'" 
                        << endl
                        << "`return_user_id' == " << return_user_id 
                        << endl;

                    if (user_name)
                       cerr << "`*user_name' == " << *user_name
                            << endl;
                    else
                       cerr << "`user_name' == NULL"
                            << endl;
                    unlock_cerr_mutex(); 

              }  /* |if (DEBUG)|  */

@q ********** (10) @>

              if (break_on_found)
                 break;

@q ********** (10) @>

           }  /* |if (curr_distinguished_name == distinguished_name)|  */

@q ********* (9) @>

           else if (DEBUG) 
           {
              lock_cerr_mutex();
              cerr << "[Thread " << thread_ctr << "]:  "
                   << "In `Scan_Parse_Parameter_Type::check_gridmap_file':"
                   << endl  
                   << "`curr_distinguished_name' != `distinguished_name'" << endl;
              unlock_cerr_mutex(); 

           }  /* |else if (DEBUG) |  */

@q ********* (9) @>

           if (result)
           {
              mysql_free_result(result);
              result = 0;
           }

@q ********* (9) @>

       }  /* |else| (|row_ctr > 0|)  */

@q ******** (8) @>

       curr_distinguished_name.clear();

   } /* |while (grid_mapfile_strm)|  */
   
@q ******* (7) @>

@q ****** (6) @>

@ Here, the return value of |unlock_tables| is tested.  For the error exits above,
it's not tested, since this function exits with an error, anyway. 
|Scan_Parse_Parameter_Type::unlock_tables| also issues an error message,
so it's not really necessary for this function to issue a message that 
|Scan_Parse_Parameter_Type::unlock_tables| failed, unless that's the reason
this function fails, as here.
\initials{LDF 2012.05.11.}

\LOG
\initials{LDF 2012.05.11.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

   status = unlock_tables();

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::check_grid_mapfile':"
            << endl
            << "Failed to unlock database tables `Users' and `Certificates'."
            << endl
            << "Exiting function unsuccessfully with return value -1."
            << endl;
       unlock_cerr_mutex(); 

       return -1;

   }  /* |if (status != 0)|  */

   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::check_grid_mapfile':"
            << endl
            << "Unlocked database tables `Users' and `Certificates' successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>=

   if (return_user_id > 0)
   {
       if (DEBUG) 
       { 
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "Exiting `Scan_Parse_Parameter_Type::check_grid_mapfile' successfully "
                << "with return value " << return_user_id << "."
                << endl;
           unlock_cerr_mutex(); 

       } /* |if (DEBUG)| */

   }  /* |if (return_user_id > 0)|  */

   else
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::check_grid_mapfile':  "
            << "Failed to find or create valid `user_id'."
            << endl
            << "`*user_name' == " << *user_name
            << endl  
            << "Exiting function unsuccessfully with return value " << return_user_id << "."
            << endl;
       unlock_cerr_mutex(); 
   }

   grid_mapfile_strm.close();

   return return_user_id;

}  /* |Scan_Parse_Parameter_Type::check_grid_mapfile|  */

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Check delegation. @>

@ Check delegation.
\initials{LDF 2010.06.30.}

\LOG
\initials{LDF 2010.06.30.}
Added this function.

\initials{LDF 2012.05.08.}
Changed.  See log comments below.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
check_delegation(char* dn_str);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::check_delegation| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::check_delegation(char* dn_str)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    MYSQL_RES* result = 0;
    unsigned int row_ctr       = 0;
    unsigned int field_ctr     = 0;
   
    MYSQL_ROW curr_row;

    stringstream sql_strm;

    int status = 0;

    int delegate;

    unsigned int curr_user_id = user_id;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::check_delegation| definition@>=


    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::check_delegation'."
            << endl;
   
       cerr << "dn_str == " << dn_str << endl;

       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::check_delegation| definition@>=

    Distinguished_Name_Type dn;
 
    status = dn.set(dn_str);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::check_delegation':"
             << endl 
             << "`Distinguished_Name_Type.set' failed, returning " << status
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        return 1;

    }  /* |if (status != 0)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::check_delegation':"
             << endl 
             << "`Distinguished_Name_Type.set' succeeded."
             << endl;
        
        dn.show("dn:");

        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */         

    status = lookup(dn);

    if (status <= 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::check_delegation':"
             << endl 
             << "`Scan_Parse_Parameter_Type::lookup' failed, returning " << status
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        return 1;

    }  /* |if (status != 0)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::check_delegation':"
             << endl 
             << "`Scan_Parse_Parameter_Type::lookup' succeeded, returning "
             << status
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */         

    curr_user_id = status;

@q ****** (6) @>
@
\LOG
\initials{LDF 2012.05.08.}
Changed the following SQL query to account for the use of \.{Privileges.superuser} 
and \.{Privileges.delegate}.  Formerly, a value of -1 in 
\.{Delegates.effective\_user\_id} was used to indicate that the user 
referred to by \.{Delegates.delegate\_id} (i.e., |user_id| in this function) could act
as a delegate for any other user.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::check_delegation| definition@>=

    sql_strm << "select P.user_id, D.effective_user_id, P.superuser, P.delegate "
             << "from Delegates as D "
             << "left join Privileges as P on P.user_id = " << user_id << " and "
             << "(D.delegate_id = " << user_id << " and D.effective_user_id = " 
             << curr_user_id  << " or P.superuser = 1)";


    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::check_delegation':"
            << endl 
            << "`sql_strm.str()' == "
            << endl
            << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */
  
    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::check_delegation':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return 1;


    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::check_delegation':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::check_delegation':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) |user_id| can't act as a delegate for |curr_user_id|.  @>

@ |user_id| can't act as a delegate for |curr_user_id|.
\initials{LDF 2010.06.30.}
\initials{LDF 2011.04.27.}

@<|Scan_Parse_Parameter_Type::check_delegation| definition@>=

    if (row_ctr == 0)  /* |user_id| can't act as a delegate for |curr_user_id|.  */
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::check_delegation':  "
             << "`" << user_name << "' (" << user_id << ") can't act as a delegate "
             << "for user `" << curr_user_id << "'."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        return 1;

    }  /* |if (row_ctr == 0)| */

@q ****** (6) @>
@
\LOG
\initials{LDF 2012.05.08.}
Added the following |for| loop.  It is necessary, because the use of ``left join'' in 
the SQL query causes there to always be at least one row returned, if there are any rows
at all in the \.{Delegates} table.  If a row does not satisfy the conditions, |curr_row[0]| 
will be NULL.  This must be checked in the loop.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::check_delegation| definition@>=

    else /* |row_ctr > 0|  */
    {

@q ******* (7) @>

      bool success = false;

      for (int i = 0; i < row_ctr; ++i)
      {
@q ******** (8) @>

          if ((curr_row = mysql_fetch_row(result)) == 0)
          {
              lock_cerr_mutex(); 
              cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                   << "ERROR!  In `Scan_Parse_Parameter_Type::check_delegation':"
                   << endl 
                   << "`mysql_fetch_row' failed:"
                   << endl
                   << mysql_error(mysql_ptr)
                   << endl 
                   << "`" << user_name << "' (" << user_id << ") can't act as a delegate "
                   << "for user `" << curr_user_id << "'."
                   << endl 
                   << "Exiting function unsuccessfully with return value 1."
                   << endl;
              unlock_cerr_mutex(); 

              mysql_free_result(result);

              return 1;

          }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

          if (curr_row[0] != 0 && strlen(curr_row[0]) > 0)
          {
              effective_user_id = curr_user_id;
              success = true;
              break;

          }

@q ******** (8) @>

      }  /* |for|  */

@q ******* (7) @>

      if (success == false)
      {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::check_delegation':"
                << endl 
                << "`" << user_name << "' (" << user_id << ") can't act as a delegate "
                << "for user `" << curr_user_id << "'."
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

          if (result)
          {
             mysql_free_result(result);
             result = 0;
          }  

          return 1;

      }

@q ******* (7) @>

       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::check_delegation':  "
                << "`" << user_name << "' can act as a delegate for user " 
                << curr_user_id << "."
                << endl
                << "effective_user_id == " << effective_user_id << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::check_delegation| definition@>=

       if (result)
       {
          mysql_free_result(result);
          result = 0;
       }
 
@q ******* (7) @>

    }  /* |else| (|row_ctr > 0|)  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::check_delegation| definition@>=

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::check_delegation' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

    return 0;

}  /* |Scan_Parse_Parameter_Type::check_delegation|  */

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */


@q **** (4) Show entries. @>

@ Show entries.
\initials{LDF 2010.05.21.}

\LOG
\initials{LDF 2012.01.13.}
Moved definition of this function to \filename{spptshen.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
show_entries(Response_Type& response, char buffer[]);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */


@q **** (4) Show certificates. @>

@ Show certificates.
\initials{LDF 2010.10.27.}

\vskip\baselineskip
\halign{#:\quad&#\hfil\cr
%
{\bf Error codes returned to the client}\span\cr
\noalign{\vskip.5\baselineskip}
0&No certificates found to show\cr
\omit&This shouldn't be possible\cr
%
1&MySQL API function error\cr
%
2&User not permitted to view other users' certificates\cr
\omit&In this case, function will continue and try to show user's own certificate\cr
%
3&|mkstemp| failed to open temporary file.\cr
%
4&This function succeeds, but |buffer| and |response.local_filename| are both
non-empty (set by |exchange_data_with_client|)\cr
%
5&This function succeeds, but |buffer| and |response.local_filename| are both
empty (set by |exchange_data_with_client|)\cr
%
6&This function failed with return value $\ne 2$ and |response.command| is empty.
(set by |exchange_data_with_client|).\cr
\omit&This should never occur\cr
}

\LOG
\initials{LDF 2010.10.27.}
Added this function.

\initials{LDF 2012.05.09.}
Simplified the commands returned to \.{optdbcli}.  Now using fewer different ones, but with
an integer error code.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
show_certificates(Response_Type &response, char buffer[]);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::show_certificates(Response_Type &response, char buffer[])
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    int status = 0;

    MYSQL_RES* result          = 0;
    unsigned int row_ctr       = 0;
    unsigned int field_ctr     = 0;
   
    MYSQL_ROW curr_row;

    stringstream sql_strm;

    stringstream temp_strm;

    unsigned int curr_user_id = (effective_user_id > 0) ? effective_user_id : user_id;

    bool html = (response.output_format == Response_Type::OUTPUT_FORMAT_HTML) ? true : false;

    bool permitted = false;



@q ****** (6) @>

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::show_certificates'."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */


@q ****** (6) If all certificates should be shown, check whether the effective user @>
@q ****** (6) is permitted to view them.                                            @>

@ If all certificates should be shown, check whether the effective user 
is permitted to view them.                                           
\initials{LDF 2010.11.04.}

\LOG
\initials{LDF 2010.11.04.}
Added this section.

\initials{LDF 2011.12.12.}
@:BUG FIX@> BUG FIX:  Changed this code to account for changes in the database.
\.{delegate} is no longer a field in the \.{Users} table.  Instead, there is a
\.{Delegates} table.

\initials{LDF 2012.05.02.}
Now using \.{Privileges} table instead of \.{Delegates}.
\ENDLOG

@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

     if (response.certificates_all)
     {
@q ******* (7) @>

        sql_strm << "select superuser, show_certificates, add_globus_site_admin, "
                 << "delete_globus_site_admin from "
                 << "Privileges where user_id = " << curr_user_id << " ";

        if (DEBUG) 
        { 
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::show_certificates':"
                << endl
                << "`sql_strm.str()' == " << sql_strm.str()
                << endl;
           unlock_cerr_mutex(); 

        } /* |if (DEBUG)| */

        status = submit_mysql_query(sql_strm.str(),
                                    result, 
                                    &row_ctr, 
                                    &field_ctr);
@q ******* (7) @>

        if (status)
        {
            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::show_certificates':"
                 << endl 
                 << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                 << status << "."
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            if (result) 
               mysql_free_result(result);

            response.command = "SERVER SHOW CERTIFICATES FAILED 1";

            response.local_filename = "";
            memset(buffer, 0, MAX_BUFFER + 1);

            return 1;

        }  /* |if (status)|  */


@q ******* (7) @>

        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::show_certificates':"
                 << endl 
                 << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */

@q ******* (7) @>

        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::show_certificates':"
                 << endl 
                 << "row_ctr == " << row_ctr 
                 << endl
                 << "field_ctr == " << field_ctr 
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=
        
        if (row_ctr == 0)
        {
             permitted = false;
             goto NO_SHOW_ALL_CERTS;
        }


        if ((curr_row = mysql_fetch_row(result)) == 0)
        {
            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::show_certificates':"
                 << endl 
                 << "`mysql_fetch_row' failed:"
                 << endl
                 << mysql_error(mysql_ptr)
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            if (result)
               mysql_free_result(result);

            response.command = "SERVER SHOW CERTIFICATES FAILED 1";

            response.local_filename = "";
            memset(buffer, 0, MAX_BUFFER + 1);

            return 1;

        }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

        if (DEBUG)
        {
            if (curr_row[0])
               cerr << "curr_row[0] == " << curr_row[0] << endl;
            else
               cerr << "curr_row[0] == NULL" << endl;

            if (curr_row[1])
               cerr << "curr_row[1] == " << curr_row[1] << endl;
            else
               cerr << "curr_row[1] == NULL" << endl;

            if (curr_row[2])
               cerr << "curr_row[2] == " << curr_row[2] << endl;
            else
               cerr << "curr_row[2] == NULL" << endl;

            if (curr_row[3])
               cerr << "curr_row[3] == " << curr_row[3] << endl;
            else
               cerr << "curr_row[3] == NULL" << endl;

            if (row_ctr > 4)
            {
                if (curr_row[4])
                   cerr << "curr_row[4] == " << curr_row[4] << endl;
                else
                   cerr << "curr_row[4] == NULL" << endl;
            } 

        }  /* |if (DEBUG)|  */ 

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

        for (int i = 0; i < 4; ++i)
        {
            if (curr_row[i] != 0 && strlen(curr_row[i]) > 0 && atoi(curr_row[0]) == 1)
            {

                if (DEBUG)
                {
                    cerr << "curr_row[" << i << "] == " << curr_row[i] << endl
                         << "User is permitted to view certificates."
                         << endl
                         << "Breaking."
                         << endl;

                }  /* |if (DEBUG)|  */ 

                permitted = true;
                break;

            }  /* |if|  */

        }  /* |for|  */


NO_SHOW_ALL_CERTS:

        if (!permitted)
        {

            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "WARNING!  In `Scan_Parse_Parameter_Type::show_certificates':"
                 << endl 
                 << "Ineligible user.  Not showing certificates for other users."
                 << endl
                 << "Continuing."
                 << endl;
            unlock_cerr_mutex(); 
 
            Response_Type new_response;
            new_response.type = Response_Type::COMMAND_ONLY_TYPE;

            new_response.command = "SERVER SHOW CERTIFICATES FAILED 2";

            pthread_mutex_lock(&response_deque_mutex);
            response_deque.push_back(new_response);
            pthread_mutex_unlock(&response_deque_mutex);


            if (result)
            {
               mysql_free_result(result);
               result = 0;
            }   

            response.certificates_all  = false;
            response.certificate_user  = true;

        }  /* |if (!permitted)|  */


@q ******* (7) @>

     }  /* |if (response.certificates_all)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

  sql_strm.str("");

  sql_strm << "select certificate_id, user_id, issuer_cert_id, is_ca, "
           << "is_proxy, serialNumber, organization, organizationalUnitName, "
           << "commonName, countryName, localityName, stateOrProvinceName, "
           << "Validity_notBefore, Validity_notAfter from Certificates ";

  if (response.certificate_user)
     sql_strm << "where user_id = " << curr_user_id << " ";

  sql_strm << "order by certificate_id";

  if (DEBUG) 
  { 
     lock_cerr_mutex(); 
     cerr << "[Thread " << thread_ctr << "]:  "
          << "In `Scan_Parse_Parameter_Type::show_certificates':"
          << endl
          << "`sql_strm.str()' == " << sql_strm.str()
          << endl;
     unlock_cerr_mutex(); 

  } /* |if (DEBUG)| */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

@q ******* (7) @>

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::show_certificates':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result) 
           mysql_free_result(result);

        if (response.certificates_all)
           response.command = "SERVER SHOW CERTIFICATES FAILED 1";
        else 
           response.command = "SERVER SHOW CERTIFICATE FAILED 1";

        response.local_filename = "";
        memset(buffer, 0, MAX_BUFFER + 1);

        return 1;

    }  /* |if (status)|  */

@q ******* (7) @>

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::show_certificates':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ******* (7) @>

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::show_certificates':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */


@q ******* (7) @>

    bool dump_to_file = false;
    ofstream out_strm;
    
    if (row_ctr == 0)
    {

        if (response.certificates_all)
           response.command = "SERVER SHOW CERTIFICATES FAILED 0";
        else 
           response.command = "SERVER SHOW CERTIFICATE FAILED 0";

        response.local_filename = "";
        memset(buffer, 0, MAX_BUFFER + 1);

        if (result)
           mysql_free_result(result);

        return 2;

    }  /* |if (row_ctr == 0)|  */


@q ****** (6) @>
@
Here, the message to be sent to the client is stored in |buffer| instead of storing it 
in |response.command|.  This is because of what |exchange_data_with_client| 
(in \filename{connect.web}) does after this function returns.  
@:TODO@> !! TODO:  Take a look at this and see whether it would make sense to 
change this.  
\initials{LDF 2010.10.27.}

@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

    else /* |row_ctr > 0|  */
    {

       temp_strm.str("");

       /*  !! TODO:  LDF 2010.10.27.  Collect the data from the database and send it 
           to the client.  The parser rule in the client must call |accept_data|.  */

       if (html)
       {
          temp_strm << "</pre>" 
                    << "<table border=1 summary=\"Certificate";

          if (!response.certificate_user)
              temp_strm << "s";

          temp_strm << "\">" << endl
                    << "<caption><b>Certificate";

          if (!response.certificate_user)
              temp_strm << "s";

           temp_strm << "</b></caption>"
                     << endl << "</table>" << endl;
       }

       else
       {
           temp_strm << "*** Certificate";

           if (!response.certificate_user)
              temp_strm << "s";

           temp_strm << " ***" << endl << endl;

        }
 
       for (int i = 0; i < row_ctr; ++i)
        {
@q ********* (9) @>

            if ((curr_row = mysql_fetch_row(result)) == 0)
            {
                lock_cerr_mutex(); 
                cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                     << "ERROR!  In `Scan_Parse_Parameter_Type::show_certificates':"
                     << endl 
                     << "`mysql_fetch_row' failed:"
                     << endl
                     << mysql_error(mysql_ptr)
                     << endl 
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;
                unlock_cerr_mutex(); 

                mysql_free_result(result);


                if (response.certificates_all)
                   response.command = "SERVER SHOW CERTIFICATES FAILED 1";
                else 
                   response.command = "SERVER SHOW CERTIFICATE FAILED 1";

                response.local_filename = "";
                memset(buffer, 0, MAX_BUFFER + 1);

                return 1;

            }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ********* (9) @>

            else /* |mysql_fetch_row(result)| succeeded  */
            {
@q ********** (10) @>

                if (DEBUG)
                {
       
                    lock_cerr_mutex(); 
                    cerr << "[Thread " << thread_ctr << "]:  "
                         << "In `Scan_Parse_Parameter_Type::show_certificates':"
                         << endl 
                         << "`mysql_fetch_row' succeeded."
                         << endl;
                    unlock_cerr_mutex(); 
 

                }  /* |if (DEBUG)|  */ 

@q ********** (10) @>

@ Normally, if |certificate_id == 0|, we won't bother to show it, because it should be
the ``null certificate''.  However, if there aren't any other certificates, this would result 
in nothing being output.  In this case, therefore, the ``null certificate'' will be shown.
Under normal circumstances, this should never occur.
\initials{LDF 2010.11.04.}

@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=
 
                if (curr_row[0])
                {
                    if (DEBUG)
                    {
                        cerr << "certificate_id  == " << curr_row[0] << endl;

                    }  /* |if (DEBUG)|  */ 

                    if (atoi(curr_row[0]) == 0 && row_ctr > 1)
                       continue;
         
                    if (html)
                       temp_strm << "<table border=1>" 
                                 << endl
                                 << "<tr><td>certificate_id";

                    else
                       temp_strm << setw(25) << std::left << "certificate_id:";

                    if (html)
                       temp_strm << "<td>";

                    temp_strm << curr_row[0];


                } /* |if (curr_row[0])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "certificate_id  == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 


                    temp_strm << "NULL";

                }  /* |else| (|curr_row[0] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

                if (html)
                   temp_strm << "<tr><td>user_id";
                else
                   temp_strm << setw(25) << std::left << "user_id:";

                if (html)
                   temp_strm << "<td>";

                if (curr_row[1])
                {
                    if (DEBUG)
                    {
                        cerr << "user_id  == " << curr_row[1] << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << curr_row[1];

                } /* |if (curr_row[1])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "user_id  == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << "NULL";

                }  /* |else| (|curr_row[1] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>

                if (html)
                   temp_strm << "<tr><td>issuer_cert_id";
                else
                   temp_strm << setw(25) << std::left << "issuer_cert_id:";

                if (html)
                   temp_strm << "<td>";

                if (curr_row[2])
                {
                    if (DEBUG)
                    {
                        cerr << "issuer_cert_id  == " << curr_row[2] << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << curr_row[2];

                } /* |if (curr_row[2])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "issuer_cert_id  == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << "NULL";

                }  /* |else| (|curr_row[2] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>

                if (html)
                   temp_strm << "<tr><td>is_ca";
                else
                   temp_strm << setw(25) << std::left << "is_ca:";

                if (html)
                   temp_strm << "<td>";

                if (curr_row[3])
                {
                    if (DEBUG)
                    {
                        cerr << "is_ca == " << curr_row[3] << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << curr_row[3];

                } /* |if (curr_row[3])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "is_ca == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << "NULL";

                }  /* |else| (|curr_row[3] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>

                if (html)
                   temp_strm << "<tr><td>is_proxy";
                else
                   temp_strm << setw(25) << std::left << "is_proxy:";

                if (html)
                   temp_strm << "<td>";

                if (curr_row[4])
                {
                    if (DEBUG)
                    {
                        cerr << "is_proxy == " << curr_row[4] << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << curr_row[4];

                } /* |if (curr_row[4])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "is_proxy == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << "NULL";

                }  /* |else| (|curr_row[4] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>

                if (html)
                   temp_strm << "<tr><td>serialNumber";
                else
                   temp_strm << setw(25) << std::left << "serialNumber:";

                if (html)
                   temp_strm << "<td>";

                if (curr_row[5])
                {
                    if (DEBUG)
                    {
                        cerr << "serialNumber == " << curr_row[5] << endl;

                    }  /* |if (DEBUG)|  */ 

                    char temp_str[64];
                    memset(temp_str, 0, 64);

                    temp_strm << hex << atoll(curr_row[5]) << dec << " (hexadecimal)";

                } /* |if (curr_row[5])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "serialNumber == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << "NULL";

                }  /* |else| (|curr_row[5] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>

                if (html)
                   temp_strm << "<tr><td>organization";
                else
                   temp_strm << setw(25) << std::left << "organization:";

                if (html)
                   temp_strm << "<td>";

                if (curr_row[6])
                {
                    if (DEBUG)
                    {
                        cerr << "organization == " << curr_row[6] << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << curr_row[6];

                } /* |if (curr_row[6])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "organization == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << "NULL";

                }  /* |else| (|curr_row[6] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>

                if (html)
                   temp_strm << "<tr><td>organizationalUnitName";
                else
                   temp_strm << setw(25) << std::left << "organizationalUnitName:";

                if (html)
                   temp_strm << "<td>";

                if (curr_row[7])
                {
                    if (DEBUG)
                    {
                        cerr << "organizationalUnitName == " << curr_row[7] << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << curr_row[7];

                } /* |if (curr_row[7])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "organizationalUnitName == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << "NULL";

                }  /* |else| (|curr_row[7] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>

                if (html)
                   temp_strm << "<tr><td>commonName";
                else
                   temp_strm << setw(25) << std::left << "commonName:";

                if (html)
                   temp_strm << "<td>";

                if (curr_row[8])
                {
                    if (DEBUG)
                    {
                        cerr << "commonName == " << curr_row[8] << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << curr_row[8];

                } /* |if (curr_row[8])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "commonName == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << "NULL";

                }  /* |else| (|curr_row[8] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>

                if (html)
                   temp_strm << "<tr><td>countryName";
                else
                   temp_strm << setw(25) << std::left << "countryName:";

                if (html)
                   temp_strm << "<td>";

                if (curr_row[9])
                {
                    if (DEBUG)
                    {
                        cerr << "countryName == " << curr_row[9] << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << curr_row[9];

                } /* |if (curr_row[9])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "countryName == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << "NULL";

                }  /* |else| (|curr_row[9] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>

                if (html)
                   temp_strm << "<tr><td>localityName";
                else
                   temp_strm << setw(25) << std::left << "localityName:";

                if (html)
                   temp_strm << "<td>";

                if (curr_row[10])
                {
                    if (DEBUG)
                    {
                        cerr << "localityName == " << curr_row[10] << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << curr_row[10];

                } /* |if (curr_row[10])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "localityName == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << "NULL";

                }  /* |else| (|curr_row[10] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>

                if (html)
                   temp_strm << "<tr><td>stateOrProvinceName";
                else
                   temp_strm << setw(25) << std::left << "stateOrProvinceName:";

                if (html)
                   temp_strm << "<td>";

                if (curr_row[11])
                {
                    if (DEBUG)
                    {
                        cerr << "stateOrProvinceName == " << curr_row[11] << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << curr_row[11];

                } /* |if (curr_row[11])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "stateOrProvinceName == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << "NULL";

                }  /* |else| (|curr_row[11] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>

                if (html)
                   temp_strm << "<tr><td>Validity_notBefore";
                else
                   temp_strm << setw(25) << std::left << "Validity_notBefore:";

                if (html)
                   temp_strm << "<td>";

                if (curr_row[12])
                {
                    if (DEBUG)
                    {
                        cerr << "Validity_notBefore == " << curr_row[12] << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << curr_row[12];

                } /* |if (curr_row[12])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "Validity_notBefore == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << "NULL";

                }  /* |else| (|curr_row[12] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>

                if (html)
                   temp_strm << "<tr><td>Validity_notAfter";
                else
                   temp_strm << setw(25) << std::left << "Validity_notAfter:";

                if (html)
                   temp_strm << "<td>";

                if (curr_row[13])
                {
                    if (DEBUG)
                    {
                        cerr << "Validity_notAfter == " << curr_row[13] << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << curr_row[13];

                } /* |if (curr_row[13])|  */

                else
                {
                    if (DEBUG)
                    {
                        cerr << "Validity_notAfter == NULL" << endl;

                    }  /* |if (DEBUG)|  */ 

                    temp_strm << "NULL";

                }  /* |else| (|curr_row[13] == 0|)  */

                temp_strm << endl;

@q ********** (10) @>

            }  /* |else| (|mysql_fetch_row(result)| succeeded)  */

@q ********* (9) @>

            if (html)
               temp_strm << "</table>";

            temp_strm << endl << endl;

@q ********* (9) @>
@ After the loop, \.{<pre>} and a newline character or two are added to the end 
of the text that's sent to the client, so we dump it to a file even |temp_strm.str()| 
contains a number of characters somewhat smaller than |MAX_BUFFER|.  Currently, 
|MAX_BUFFER - 10| is used. 
\initials{LDF 2010.11.04.}

@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

            if (!dump_to_file && temp_strm.str().size() >= MAX_BUFFER - 10)  
            {

                char temp_filename[] = "/tmp/EEXXXXXX";

                int temp_fd = mkstemp(temp_filename);

                temp_fd = -1;

                if (temp_fd == -1)
                {

                    lock_cerr_mutex(); 
                    cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                         << "ERROR!  In `Scan_Parse_Parameter_Type::show_certificates':"
                         << endl 
                         << "`mkstemp' failed.  Can't open temporary file."
                         << endl
                         << "Exiting function unsuccessfully with return value 1."
                         << endl;
                    unlock_cerr_mutex(); 

                    mysql_free_result(result);

                    memset (buffer, 0, MAX_BUFFER + 1);      
                    response.local_filename = "";
 
                    if (response.certificates_all)
                       response.command = "SERVER SHOW CERTIFICATES FAILED 3";
                    else
                       response.command = "SERVER SHOW CERTIFICATE FAILED 3";

                    return 1;

                }  /* |if (temp_fd == -1)|  */

                temp_file_vector.push_back(string(temp_filename));

                close(temp_fd);

                response.local_filename  = temp_filename;

                out_strm.open(response.local_filename.c_str());

                dump_to_file = true;
              
            }  /* |if|  */

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

            if (dump_to_file)
            {
                out_strm << temp_strm.str() << endl;
                temp_strm.str("");
            }


@q ********* (9) @>


        }  /* |for|  */

        if (dump_to_file)
        {
           if (html)
              out_strm << endl << "<pre>" << endl;

           out_strm << endl;

           out_strm.close();
        }
        else 
        {

           if (html)
              temp_strm << endl << "<pre>";

           temp_strm << endl;
        }

        memset (buffer, 0, MAX_BUFFER + 1);      
        if (!dump_to_file)
           strcpy(buffer, temp_strm.str().c_str());
                   
        response.command = "SERVER SENDING CERTIFICATE INFO";

    }  /* |else| (|row_ctr > 0|)  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

    if (result)
       mysql_free_result(result);

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::show_certificates' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

    return 0;

@q ****** (6) @>

}  /* |Scan_Parse_Parameter_Type::show_certificates|  */

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */


@q **** (4) Lookup.  @>
@ Lookup.
\initials{LDF 2010.07.02.}

As of this data, this function is only called by
|Scan_Parse_Parameter_Type::check_delegation|.
\initials{LDF 2012.05.10.}

\LOG
\initials{LDF 2010.07.02.}
Added this function.

\initials{LDF 2011.04.27.}
Added code for setting |this->effective_user_name|.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
#if HAVE_LIBMYSQLCLIENT
int
lookup(const Distinguished_Name_Type& dn);
#endif

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::lookup| definition@>=
#if HAVE_LIBMYSQLCLIENT
int
Scan_Parse_Parameter_Type::lookup(const Distinguished_Name_Type& dn)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    stringstream temp_strm;

    string thread_str;

    int curr_user_id = -1;

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "Entering `Scan_Parse_Parameter_Type::lookup'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */   

@q ****** (6) @>

    int status;

    MYSQL_RES* result = 0;
    unsigned int row_ctr       = 0;
    unsigned int field_ctr     = 0;
   
    MYSQL_ROW curr_row;

    stringstream sql_strm;

@q ****** (6) @>
@
\LOG
\initials{LDF 2011.04.27.}
Removed unneeded column names from query.  \.{C.certificate\_id}, however, is only
needed for debugging purposes.

\initials{LDF 2012.05.10.}
@:BUG FIX@> BUG FIX:  Now ordering by \.{U.user\_id}.  There should only be one row,
but if there is more, this ensures that the lowest |user_id| is found.  This is just
extra insurance;  there should only be one row in the \.{Users} table for each
X.509 certificate.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::lookup| definition@>=

    sql_strm << "select C.certificate_id, U.user_id, U.user_name from "
             << "Certificates as C, Users as U where C.commonName = '" 
             << dn.commonName << "' and "
             << "C.organization = '" << dn.organization 
             << "' and C.organizationalUnitName = '"
             << dn.organizationalUnitName << "' and C.user_id = U.user_id "
             << "order by U.user_id";

    if (DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::lookup':  `sql_strm.str()' == "
             << sql_strm.str()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */   

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::lookup| definition@>=

    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::lookup':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value -1."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return -1;


    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::lookup':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::lookup| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::lookup':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::lookup| definition@>=

    
    if ((curr_row = mysql_fetch_row(result)) == 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::lookup':"
             << endl 
             << "`mysql_fetch_row' failed:"
             << endl
             << mysql_error(mysql_ptr)
             << endl 
             << "Exiting function unsuccessfully with return value -1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        return -1;

    }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::lookup| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::lookup':"
             << endl 
             << "`curr_row[0]' == " << curr_row[0]
             << endl 
             << "`curr_row[1]' == " << curr_row[1]
             << endl 
             << "`curr_row[2]' == " << curr_row[2]
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::lookup| definition@>=

    if (curr_row[1])
    {
       sscanf(curr_row[1], "%d", &curr_user_id);
  
       if (DEBUG)
       {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                  << "In `Scan_Parse_Parameter_Type::lookup':"
                  << endl 
                  << "`curr_user_id' == " << curr_user_id
                  << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */ 


    }  /* |if (curr_row[1])|  */
    else 
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
              << "ERROR!  In `Scan_Parse_Parameter_Type::lookup':"
              << endl 
              << "`curr_row[1]' == NULL."
              << endl 
              << "Exiting function unsuccessfully with return value -1."
              << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        return -1;

    }  /* |else|  */

@q ****** (6) @>
@ 
\LOG
\initials{LDF 2011.04.27.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::lookup| definition@>=

    if (curr_row[2])
    {
       effective_user_name = curr_row[2];
  
       if (DEBUG)
       {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                  << "In `Scan_Parse_Parameter_Type::lookup':"
                  << endl 
                  << "`effective_user_name' == " << effective_user_name
                  << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */ 

    }  /* |if (curr_row[2])|  */
    else 
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
              << "ERROR!  In `Scan_Parse_Parameter_Type::lookup':"
              << endl 
              << "`curr_row[2]' == NULL."
              << endl 
              << "Exiting function unsuccessfully with return value -1."
              << endl;
        unlock_cerr_mutex(); 

        mysql_free_result(result);

        return -1;

    }  /* |else|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::lookup| definition@>=

        mysql_free_result(result);

        return curr_user_id;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::lookup| definition  */

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) @>

@q **** (4) Delete entries.  @>

@ Delete entries.
\initials{LDF 2010.09.09.}

This function deletes all of the entries with |package_name| and |package_version| 
(if the latter is present) for the current user (identified by |curr_user_id|).  
Normally, it shouldn't be possible for there to be more than one entry for a 
given |package_name| with the same non-empty |package_version|.  
However, if there is, this function will delete all of them.  It also deletes all 
rows in the \.{Prerequisites} table where the |entry_id| or |prerequisite_id| corresponds 
to the values of |Entries.entry_id| found for |package_name|, |package_version| 
and |curr_user_id|.

\LOG
\initials{LDF 2010.09.09.}
Added this function.

\initials{LDF 2010.10.14.}
Changed the name of this function from |delete_entry| to |delete_entries|.
Made both arguments optional.  Changed code accordingly.

\initials{LDF 2012.05.11.}
@:BUG FIX@> BUG FIX:  Now calling |Scan_Parse_Parameter_Type::lock_table| and 
|Scan_Parse_Parameter_Type::unlock_tables| instead of locking and unlocking mutexes.
The latter method did not prevent other MySQL client applications from accessing 
the database tables.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
delete_entries(string package_name = "", string package_version = "");
#endif 

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>=

#if HAVE_LIBMYSQLCLIENT
int
Scan_Parse_Parameter_Type::delete_entries(string package_name, 
                                          string package_version)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    int status = 0;

    stringstream sql_strm;
    stringstream sql_strm_1;

    MYSQL_RES* result = 0;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    unsigned int curr_user_id 
       = (effective_user_id > 0) ? effective_user_id : user_id;

    int curr_entry_id;

    Response_Type response; 
    response.type = Response_Type::COMMAND_ONLY_TYPE;       

    stringstream temp_strm;    

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>=
    
    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::delete_entries':"
            << endl;

       cerr << "`user_id' == " << user_id 
            << endl
            << "`curr_user_id' == " << curr_user_id 
            << endl;

       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>=

    sql_strm << "select entry_id from Entries where user_id = "
             << curr_user_id;


    if (!package_name.empty())
       sql_strm << " and package_name = '"
                << package_name << "'";

    if (!package_version.empty())
       sql_strm << " and package_version = '" << package_version << "'";

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl
            << "`sql_strm.str()' == "
            << endl
            << sql_strm.str()
            << endl;

       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::delete_entries':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       temp_strm.str("");
       temp_strm << "FAILED TO DELETE ";

       if (!package_name.empty())
       {
          temp_strm << "ENTRY "
                 << " <" << package_name << ">";

          if (!package_version.empty())
             temp_strm << " <" << package_version << ">";
       }
       else
          temp_strm << "ENTRIES";

       response.command = temp_strm.str();

       server_finished = false;

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_back(response);
       pthread_mutex_unlock(&response_deque_mutex);


       return 1;

    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_entries':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ******** (8) @>

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_entries':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>=

   if (row_ctr == 0)
   {
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::delete_entries':"
                << endl 
                << "No entries to delete.  Exiting function successfully with "
                << "return value 0."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 

       mysql_free_result(result);

       temp_strm.str("");

       temp_strm << "FAILED TO DELETE ";

       if (!package_name.empty())
       {
          temp_strm << "ENTRY "
                 << " <" << package_name << ">";

          if (!package_version.empty())
             temp_strm << " <" << package_version << ">";
       }
       else
          temp_strm << "ENTRIES";

       response.command = temp_strm.str();

       server_finished = false;

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_back(response);
       pthread_mutex_unlock(&response_deque_mutex);

       return 0;

   }  /* |if (row_ctr == 0)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>=

   sql_strm.str("");

   sql_strm << "delete from Entries where entry_id = ";

   sql_strm_1 << "delete from Prerequisites where entry_id = ";

   for (int i = 0; i < row_ctr; ++i)
   {
@q ******* (7) @>

       if (i > 0)
       {
          sql_strm << " or entry_id = ";
          sql_strm_1 << " or entry_id = ";
       }

       if ((curr_row = mysql_fetch_row(result)) == 0)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::delete_entries':"
                << endl 
                << "`mysql_fetch_row' failed:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           if (result)
              mysql_free_result(result);

           temp_strm.str("");

           temp_strm << "FAILED TO DELETE ";

           if (!package_name.empty())
           {
              temp_strm << "ENTRY "
                     << " <" << package_name << ">";

              if (!package_version.empty())
                 temp_strm << " <" << package_version << ">";
           }
           else
              temp_strm << "ENTRIES";

           response.command = temp_strm.str();

           server_finished = false;

           pthread_mutex_lock(&response_deque_mutex);
           response_deque.push_back(response);
           pthread_mutex_unlock(&response_deque_mutex);

           return 1;

       }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::delete_entries':"
                << endl 
                << "`curr_row[0]' == " << curr_row[0]
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

       if (curr_row[0])
       {
          sql_strm << curr_row[0];
          sql_strm_1 << curr_row[0] << " or prerequisite_id = " << curr_row[0];

       }  /* |if (curr_row[0])|  */
       else 
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::delete_entries':"
                 << endl 
                 << "`curr_row[0]' == NULL."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
           unlock_cerr_mutex(); 

           if (result)
              mysql_free_result(result);

           temp_strm.str("");

           temp_strm << "FAILED TO DELETE ";

           if (!package_name.empty())
           {
              temp_strm << "ENTRY "
                     << " <" << package_name << ">";

              if (!package_version.empty())
                 temp_strm << " <" << package_version << ">";
           }
           else
              temp_strm << "ENTRIES";

           response.command = temp_strm.str();

           server_finished = false;

           pthread_mutex_lock(&response_deque_mutex);
           response_deque.push_back(response);
           pthread_mutex_unlock(&response_deque_mutex);

           return 1;

       }  /* |else|  */

@q ******* (7) @>

   }  /* |for|  */

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`sql_strm.str()' == " << sql_strm.str() 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */




@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>=

   status = lock_table("Entries");

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "WARNING!  In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`Scan_Parse_Parameter_Type::lock_table' failed, returning " 
            << status << "."
            << endl
            << "Failed to lock `Entries' table.  Will try to continue."
            << endl;
       unlock_cerr_mutex(); 
   }
   else if (DEBUG)
   {

       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`Scan_Parse_Parameter_Type::lock_tables' succeeded."
            << endl
            << "Locked `Entries' table successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>=


   status = submit_mysql_query(sql_strm.str(),
                               result);

   if (status)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "WARNING!  In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

      if (result) 
         mysql_free_result(result);

      unlock_tables();

      temp_strm.str("");

      temp_strm << "FAILED TO DELETE ";

      if (!package_name.empty())
      {
         temp_strm << "ENTRY "
                << " <" << package_name << ">";

         if (!package_version.empty())
            temp_strm << " <" << package_version << ">";
      }
      else
         temp_strm << "ENTRIES";

      response.command = temp_strm.str();

      server_finished = false;

      pthread_mutex_lock(&response_deque_mutex);
      response_deque.push_back(response);
      pthread_mutex_unlock(&response_deque_mutex);

      return 1;

   }  /* |if (status)|  */

   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

   sql_strm.str("");

   if (result)
   {
      mysql_free_result(result);
      result = 0;
   }

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>=

   status = unlock_tables();

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "WARNING!  In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`Scan_Parse_Parameter_Type::unlock_tables' failed, returning " 
            << status << ".  Will try to continue."
            << endl;
       unlock_cerr_mutex(); 
   }
   else if (DEBUG)
   {

       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`Scan_Parse_Parameter_Type::unlock_tables' succeeded."
            << endl;
       unlock_cerr_mutex(); 


   }  /* |else if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>=

   status = lock_table("Prerequisites");

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "WARNING!  In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`Scan_Parse_Parameter_Type::lock_table' failed, returning " 
            << status << "."
            << endl
            << "Failed to lock `Prerequisites' table.  Will try to continue."
            << endl;
       unlock_cerr_mutex(); 
   }
   else if (DEBUG)
   {

       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`Scan_Parse_Parameter_Type::lock_tables' succeeded."
            << endl
            << "Locked `Prerequisites' table successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>=

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`sql_strm_1.str()' == " << sql_strm_1.str() 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */


   status = submit_mysql_query(sql_strm_1.str(),
                               result);

   if (status)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "WARNING!  In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

      if (result) 
         mysql_free_result(result);

      unlock_tables();

      temp_strm.str("");

      temp_strm << "FAILED TO DELETE ";

      if (!package_name.empty())
      {
         temp_strm << "ENTRY "
                << " <" << package_name << ">";

         if (!package_version.empty())
            temp_strm << " <" << package_version << ">";
      }
      else
         temp_strm << "ENTRIES";

      response.command = temp_strm.str();

      server_finished = false;

      pthread_mutex_lock(&response_deque_mutex);
      response_deque.push_back(response);
      pthread_mutex_unlock(&response_deque_mutex);

      return 1;

   }  /* |if (status)|  */

   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

@q ****** (6) @>

   sql_strm_1.str("");

   if (result)
   {
      mysql_free_result(result);
      result = 0;
   }

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>=

   status = unlock_tables();

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "WARNING!  In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`Scan_Parse_Parameter_Type::unlock_tables' failed, returning " 
            << status << ".  Will try to continue."
            << endl;
       unlock_cerr_mutex(); 
   }
   else if (DEBUG)
   {

       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::delete_entries':"
            << endl 
            << "`Scan_Parse_Parameter_Type::unlock_tables' succeeded."
            << endl;
       unlock_cerr_mutex(); 


   }  /* |else if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>=

   temp_strm.str("");

   temp_strm << "DELETED ";

   if (!package_name.empty())
   {
      temp_strm << "ENTRY "
             << " <" << package_name << ">";

      if (!package_version.empty())
         temp_strm << " <" << package_version << ">";
   }
   else
      temp_strm << "ENTRIES";

   response.command = temp_strm.str();

   server_finished = false;

   pthread_mutex_lock(&response_deque_mutex);
   response_deque.push_back(response);
   pthread_mutex_unlock(&response_deque_mutex);

   temp_strm.str("");

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>=

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::delete_entries' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

    return 0;


}  /* End of |Scan_Parse_Parameter_Type::delete_entries| definition  */

#endif 

@q **** (4) Mark entries.  @>

@ Mark entries.
\initials{LDF 2012.01.13.}

\LOG
\initials{LDF 2012.01.13.}
Added this function.

\initials{LDF 2012.05.14.}
Added code for catching the case that an entry has already been marked or unmarked
and sending an appropriate response with an error code to the client.

\initials{LDF 2012.05.14.}
Moved the definition of this function to \filename{spptenfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
mark_entries(bool deleted = true, 
             string package_name = "", 
             string package_version = "");
#endif 



@q **** (4) Delete prerequisites.  @>

@ Delete prerequisites.
\initials{LDF 2010.09.09.}

\LOG
\initials{LDF 2010.09.09.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
delete_prerequisites(bool delete_all,
                     string package_name, 
                     string package_version, 
                     string prerequisite_name = "", 
                     string prerequisite_version = "");
#endif 

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::delete_prerequisites| definition@>=

#if HAVE_LIBMYSQLCLIENT
int
Scan_Parse_Parameter_Type::delete_prerequisites(bool delete_all,
                                                string package_name, 
                                                string package_version,
                                                string prerequisite_name, 
                                                string prerequisite_version)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    int status = 0;

    Response_Type response; 
    response.type = Response_Type::COMMAND_ONLY_TYPE;       

    stringstream temp_strm;    


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_prerequisites| definition@>=
    
    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::delete_prerequisites':"
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_prerequisites| definition@>=

    if (delete_all && (!prerequisite_name.empty() || !prerequisite_name.empty()))
    {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::delete_prerequisites':"
            << endl
            << "`delete_all' == true and `prerequisite_name' and/or "
            << "`prerequisite_version' isn't empty."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 
       

       temp_strm.str();

       temp_strm << "FAILED TO DELETE PREREQUISITES FOR ENTRY <" << package_name << ">";

       if (!package_version.empty())
          temp_strm << " <" << package_version << ">";

       response.command = temp_strm.str();

       server_finished = false;

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_back(response);
       pthread_mutex_unlock(&response_deque_mutex);

       return 1;

    }  /* |if (delete_all && (!prerequisite_name.empty() || !prerequisite_name.empty()))|  */


@q ****** (6) @>


    stringstream sql_strm;
    stringstream sql_strm_1;

    MYSQL_RES* result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    unsigned int curr_user_id 
       = (effective_user_id > 0) ? effective_user_id : user_id;

    int curr_entry_id;
    int curr_prerequisite_id;

    vector<int> entry_id_vector;
    vector<int> prerequisite_id_vector;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_prerequisites| definition@>=
    
    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "`user_id' == " << user_id 
            << endl
            << "`curr_user_id' == " << curr_user_id 
            << endl;

       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_prerequisites| definition@>=

    sql_strm.str("");

    sql_strm << "select entry_id from Entries where user_id = " 
             << curr_user_id
             << " and package_name = '" 
             << package_name << "'";

    if (!package_version.empty())
       sql_strm << " and package_version = '" << package_version << "'";

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
             << endl 
             << "`sql_strm.str()' == " << sql_strm.str()
             << endl;
        unlock_cerr_mutex();        

    }  /* |if (DEBUG)|  */ 


    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::delete_prerequisites':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);


       temp_strm.str();

       temp_strm << "FAILED TO DELETE ";

       if (delete_all)
          temp_strm << "PREREQUISITES ";
       else
       {
          temp_strm << "PREREQUISITE <" << prerequisite_name << ">";
 
          if (!prerequisite_version.empty())
             temp_strm << " <" << prerequisite_version << ">";
       }

       temp_strm << "FOR ENTRY <" << package_name << ">";

       if (!package_version.empty())
          temp_strm << " <" << package_version << ">";

       response.command = temp_strm.str();

       server_finished = false;


       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_back(response);
       pthread_mutex_unlock(&response_deque_mutex);

       return 1;


    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    if (row_ctr == 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
             << endl 
             << "`row_ctr' == 0.  No entries for which prerequisites can be deleted."
             << endl
             << "Exiting function successfully with return value 0."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);


       temp_strm.str();

       temp_strm << "FAILED TO DELETE ";

       if (delete_all)
          temp_strm << "PREREQUISITES ";
       else
       {
          temp_strm << "PREREQUISITE <" << prerequisite_name << ">";
 
          if (!prerequisite_version.empty())
             temp_strm << " <" << prerequisite_version << ">";
       }

       temp_strm << "FOR ENTRY <" << package_name << ">";

       if (!package_version.empty())
          temp_strm << " <" << package_version << ">";

       response.command = temp_strm.str();

       server_finished = false;

       pthread_mutex_lock(&response_deque_mutex);
       response_deque.push_back(response);
       pthread_mutex_unlock(&response_deque_mutex);

       return 1;

    }  /* |if (row_ctr == 0)|  */

@q ****** (6) @>

    for (int i = 0; i < row_ctr; ++i)
    {
@q ******* (7) @>

        if ((curr_row = mysql_fetch_row(result)) == 0)
        {
            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::delete_prerequisites':"
                 << endl 
                 << "`mysql_fetch_row' failed:"
                 << endl
                 << mysql_error(mysql_ptr)
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            if (result)
               mysql_free_result(result);


            temp_strm.str();

            temp_strm << "FAILED TO DELETE ";

            if (delete_all)
               temp_strm << "PREREQUISITES ";
            else
            {
               temp_strm << "PREREQUISITE <" << prerequisite_name << ">";
 
               if (!prerequisite_version.empty())
                  temp_strm << " <" << prerequisite_version << ">";
            }

            temp_strm << "FOR ENTRY <" << package_name << ">";

            if (!package_version.empty())
               temp_strm << " <" << package_version << ">";

            response.command = temp_strm.str();

            server_finished = false;

            pthread_mutex_lock(&response_deque_mutex);
            response_deque.push_back(response);
            pthread_mutex_unlock(&response_deque_mutex);

            return 1;

        }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ******* (7) @>

        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
                 << endl 
                 << "`curr_row[0]' == " << curr_row[0]
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */

@q ******* (7) @>

        if (curr_row[0])
        {
           sscanf(curr_row[0], "%d", &curr_entry_id);
 
           entry_id_vector.push_back(curr_entry_id);
 
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
                    << endl 
                    << "`curr_entry_id' == " << curr_entry_id
                    << endl;
               unlock_cerr_mutex(); 


           }  /* |if (DEBUG)|  */ 

        }  
        else 
        {
            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                  << "ERROR!  In `Scan_Parse_Parameter_Type::delete_prerequisites':"
                  << endl 
                  << "`curr_row[0]' == NULL."
                  << endl 
                  << "Exiting function unsuccessfully with return value 1."
                  << endl;
            unlock_cerr_mutex(); 

            if (result)
               mysql_free_result(result);


            temp_strm.str();

            temp_strm << "FAILED TO DELETE ";

            if (delete_all)
               temp_strm << "PREREQUISITES ";
            else
            {
               temp_strm << "PREREQUISITE <" << prerequisite_name << ">";
 
               if (!prerequisite_version.empty())
                  temp_strm << " <" << prerequisite_version << ">";
            }

            temp_strm << "FOR ENTRY <" << package_name << ">";

            if (!package_version.empty())
               temp_strm << " <" << package_version << ">";

            response.command = temp_strm.str();

            server_finished = false;

            pthread_mutex_lock(&response_deque_mutex);
            response_deque.push_back(response);
            pthread_mutex_unlock(&response_deque_mutex);

            return 1;

        }  /* |else|  */

@q ******* (7) @>

    }  /* |for|  */

@q ****** (6) @>

    if (DEBUG)
    {

        int i = 0;

        lock_cerr_mutex(); 

        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
             << endl;

        for (vector<int>::const_iterator iter = entry_id_vector.begin();
             iter != entry_id_vector.end();
             ++iter)

            cerr << "`entry_id_vector[" << i++ << "]' == " << *iter
                 << endl;
 
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    mysql_free_result(result);
   
@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_prerequisites| definition@>=

    sql_strm.str("");

    if (delete_all)
    {
        sql_strm << "delete from Prerequisites where entry_id = ";
       
        int i = 0;

        for (vector<int>::const_iterator iter = entry_id_vector.begin();
             iter != entry_id_vector.end();
             ++iter)
        {

           if (i++ > 0)
              sql_strm << " or entry_id = ";

           sql_strm << *iter;

        }

    }  /* |if (delete_all)|  */


    else  /* |delete_all == false|  */
    {

@q ******* (7) @>

       sql_strm.str("");

       sql_strm << "select entry_id from Entries where "
                << " package_name = '" 
                << prerequisite_name << "'";

       if (!prerequisite_version.empty())
          sql_strm << " and package_version = '" << prerequisite_version << "'";

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
                << endl 
                << "`sql_strm.str()' == " << sql_strm.str()
                << endl;
           unlock_cerr_mutex();        

       }  /* |if (DEBUG)|  */ 


       status = submit_mysql_query(sql_strm.str(),
                                   result, 
                                   &row_ctr, 
                                   &field_ctr);

       if (status)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "WARNING!  In `Scan_Parse_Parameter_Type::delete_prerequisites':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                << status << "."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

          if (result) 
             mysql_free_result(result);

          temp_strm.str();

          temp_strm << "FAILED TO DELETE ";

          if (delete_all)
             temp_strm << "PREREQUISITES ";
          else
          {
             temp_strm << "PREREQUISITE <" << prerequisite_name << ">";
 
             if (!prerequisite_version.empty())
                temp_strm << " <" << prerequisite_version << ">";
          }

          temp_strm << "FOR ENTRY <" << package_name << ">";

          if (!package_version.empty())
             temp_strm << " <" << package_version << ">";

          response.command = temp_strm.str();

          server_finished = false;

          pthread_mutex_lock(&response_deque_mutex);
          response_deque.push_back(response);
          pthread_mutex_unlock(&response_deque_mutex);

          return 1;


       }  /* |if (status)|  */

       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

@q ******* (7) @>

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
                << endl 
                << "row_ctr == " << row_ctr 
                << endl
                << "field_ctr == " << field_ctr 
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */


       for (int i = 0; i < row_ctr; ++i)
       {
@q ******** (8) @>

            if ((curr_row = mysql_fetch_row(result)) == 0)
            {
                lock_cerr_mutex(); 
                cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                     << "ERROR!  In `Scan_Parse_Parameter_Type::delete_prerequisites':"
                     << endl 
                     << "`mysql_fetch_row' failed:"
                     << endl
                     << mysql_error(mysql_ptr)
                     << endl 
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;
                unlock_cerr_mutex(); 

                if (result)
                   mysql_free_result(result);

                temp_strm.str();

                temp_strm << "FAILED TO DELETE ";

                if (delete_all)
                   temp_strm << "PREREQUISITES ";
                else
                {
                   temp_strm << "PREREQUISITE <" << prerequisite_name << ">";
 
                   if (!prerequisite_version.empty())
                      temp_strm << " <" << prerequisite_version << ">";
                }

                temp_strm << "FOR ENTRY <" << package_name << ">";

                if (!package_version.empty())
                   temp_strm << " <" << package_version << ">";

                response.command = temp_strm.str();

                server_finished = false;

                pthread_mutex_lock(&response_deque_mutex);
                response_deque.push_back(response);
                pthread_mutex_unlock(&response_deque_mutex);

                return 1;

            }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ******** (8) @>

            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "]:  "
                     << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
                     << endl 
                     << "`curr_row[0]' == " << curr_row[0]
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */

@q ******** (8) @>

            if (curr_row[0])
            {
               sscanf(curr_row[0], "%d", &curr_prerequisite_id);
 
               prerequisite_id_vector.push_back(curr_prerequisite_id);
 
               if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr << "]:  "
                        << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
                        << endl 
                        << "`curr_prerequisite_id' == " << curr_prerequisite_id
                        << endl;
                   unlock_cerr_mutex(); 


               }  /* |if (DEBUG)|  */ 

            }  
            else 
            {
                lock_cerr_mutex(); 
                cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                      << "ERROR!  In `Scan_Parse_Parameter_Type::delete_prerequisites':"
                      << endl 
                      << "`curr_row[0]' == NULL."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                unlock_cerr_mutex(); 

                if (result)
                   mysql_free_result(result);

                temp_strm.str();

                temp_strm << "FAILED TO DELETE ";

                if (delete_all)
                   temp_strm << "PREREQUISITES ";
                else
                {
                   temp_strm << "PREREQUISITE <" << prerequisite_name << ">";
 
                   if (!prerequisite_version.empty())
                      temp_strm << " <" << prerequisite_version << ">";
                }

                temp_strm << "FOR ENTRY <" << package_name << ">";

                if (!package_version.empty())
                   temp_strm << " <" << package_version << ">";

                response.command = temp_strm.str();

                server_finished = false;

                pthread_mutex_lock(&response_deque_mutex);
                response_deque.push_back(response);
                pthread_mutex_unlock(&response_deque_mutex);

                return 1;

            }  /* |else|  */

@q ******** (8) @>

       }  /* |for|  */

@q ******* (7) @>

       if (DEBUG)
       {

           int i = 0;

           lock_cerr_mutex(); 

           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
                << endl;

           for (vector<int>::const_iterator iter = prerequisite_id_vector.begin();
                iter != prerequisite_id_vector.end();
                ++iter)

               cerr << "`prerequisite_id_vector[" << i++ << "]' == " << *iter
                    << endl;
 
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 

       mysql_free_result(result);
   
@q ******* (7) @>

       sql_strm.str("");

       sql_strm << "delete from Prerequisites where (entry_id = ";

       int i = 0;

       for (vector<int>::const_iterator iter = entry_id_vector.begin();
             iter != entry_id_vector.end();
             ++iter)
       {

          if (i++ > 0)
             sql_strm << " or entry_id = ";

           sql_strm << *iter;

      }

      sql_strm << ") and (prerequisite_id = ";

      i = 0;
      
      for (vector<int>::const_iterator iter = prerequisite_id_vector.begin();
            iter != prerequisite_id_vector.end();
            ++iter)
      {

         if (i++ > 0)
            sql_strm << " or prerequisite_id = ";

          sql_strm << *iter;

      }

      sql_strm << ")";

@q ******* (7) @>

    }  /* |else| (|delete_all == false|)  */
    

@q ****** (6) @>

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
             << endl 
             << "`sql_strm.str()' == " << sql_strm.str()
             << endl;
        unlock_cerr_mutex();        

    }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_prerequisites| definition@>=

    long affected_rows = 0L;


    status = submit_mysql_query(sql_strm.str(),
                                result, 0, 0, &affected_rows);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::delete_prerequisites':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result) 
           mysql_free_result(result);

        temp_strm.str();

        temp_strm << "FAILED TO DELETE ";

        if (delete_all)
           temp_strm << "PREREQUISITES ";
        else
        {
           temp_strm << "PREREQUISITE <" << prerequisite_name << ">";
 
           if (!prerequisite_version.empty())
              temp_strm << " <" << prerequisite_version << ">";
        }

        temp_strm << "FOR ENTRY <" << package_name << ">";

        if (!package_version.empty())
           temp_strm << " <" << package_version << ">";

        response.command = temp_strm.str();

        server_finished = false;

        pthread_mutex_lock(&response_deque_mutex);
        response_deque.push_back(response);
        pthread_mutex_unlock(&response_deque_mutex);

        return 1;


    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_prerequisites':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl 
             << "`affected_rows' == " << affected_rows
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    if (affected_rows == 0)
    {

        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::delete_prerequisites':"
             << endl 
             << "No prerequisites to delete."
             << endl
             << "Exiting function successfully with return value 0."
             << endl;
        unlock_cerr_mutex(); 

        mysql_free_result(result);

        temp_strm.str();

        temp_strm << "FAILED TO DELETE ";

        if (delete_all)
           temp_strm << "PREREQUISITES ";
        else
        {
           temp_strm << "PREREQUISITE <" << prerequisite_name << ">";
 
           if (!prerequisite_version.empty())
              temp_strm << " <" << prerequisite_version << ">";
        }

        temp_strm << "FOR ENTRY <" << package_name << ">";

        if (!package_version.empty())
           temp_strm << " <" << package_version << ">";

        response.command = temp_strm.str();

        server_finished = false;

        pthread_mutex_lock(&response_deque_mutex);
        response_deque.push_back(response);
        pthread_mutex_unlock(&response_deque_mutex);

        return 0;

    }  /* |if (affected_rows == 0)|  */


    mysql_free_result(result);
   
@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_prerequisites| definition@>=

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::delete_prerequisites' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */
  

    temp_strm.str();

    temp_strm << "DELETED ";

    if (delete_all)
       temp_strm << "PREREQUISITES ";
    else
    {
       temp_strm << "PREREQUISITE <" << prerequisite_name << ">";
 
       if (!prerequisite_version.empty())
          temp_strm << " <" << prerequisite_version << ">";
    }

    temp_strm << "FOR ENTRY <" << package_name << ">";

    if (!package_version.empty())
       temp_strm << " <" << package_version << ">";

    response.command = temp_strm.str();

    server_finished = false;

    pthread_mutex_lock(&response_deque_mutex);
    response_deque.push_back(response);
    pthread_mutex_unlock(&response_deque_mutex);

    return 0;


}  /* End of |Scan_Parse_Parameter_Type::delete_prerequisites| definition  */

#endif 

@q **** (4) Add Installation Script.  @>

@ Add Installation Script.
\initials{LDF 2010.09.30.}

\LOG
\initials{LDF 2010.09.30.}
Added this function.

\initials{LDF 2010.10.01.}
Added code for sending a response to the client in case of failure.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
add_installation_script(string curr_filename, 
                        string curr_package_name,
                        string curr_package_version = "",
                        int encrypted = 0);

#endif 

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::add_installation_script| definition@>=

#if HAVE_LIBMYSQLCLIENT
int
Scan_Parse_Parameter_Type::add_installation_script(string curr_filename, 
                                                   string curr_package_name,
                                                   string curr_package_version,
                                                   int encrypted)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::add_installation_script':"
            << endl;

       cerr  << "`curr_filename' == " << curr_filename
             << endl 
             << "`curr_package_name' == " << curr_package_name
             << endl 
             << "`curr_package_version' == " << curr_package_version
             << endl 
             << "`encrypted' == " << encrypted
             << endl; 

       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */


    int status = 0;

@q ****** (6) Error handling:  |curr_filename| is empty.  @>

@ Error handling:  |curr_filename| is empty.  
\initials{LDF 2010.10.06.}

@<|Scan_Parse_Parameter_Type::add_installation_script| definition@>=

    if (curr_package_name.empty())
    {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::add_installation_script':"
            << endl
            << "`curr_filename' is empty.  Can't add installation script."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 
       
    }  /* |if (curr_package_name.empty())|  */

@q ****** (6) Error handling:  |curr_package_name| is empty.  @>

@ Error handling:  |curr_package_name| is empty.  
\initials{LDF 2010.10.06.}

@<|Scan_Parse_Parameter_Type::add_installation_script| definition@>=

    if (curr_package_name.empty())
    {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::add_installation_script':"
            << endl
            << "`curr_package_name' is empty.  Can't add installation script."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 
       
    }  /* |if (curr_package_name.empty())|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_installation_script| definition@>=

    Entry_Type curr_entry;
    curr_entry.package_name = curr_package_name;
    curr_entry.package_version = curr_package_version;

    if (encrypted)
    {
        curr_entry.encrypted_flag = true;
        curr_entry.installation_script_encrypted = curr_filename;
    }
    else
       curr_entry.installation_script = curr_filename;

    emendations.push_back(curr_entry);

@q ****** (6) @>

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::add_installation_script' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

    return 0;

}  /* End of |Scan_Parse_Parameter_Type::add_installation_script| definition   */

#endif 

@q **** (4) Add Download Info.  @>

@ Add Download Info.
\initials{LDF 2011.06.08.}

\LOG
\initials{LDF 2011.06.08.}
Added this function.

\initials{LDF 2011.10.31.}
Removed |int encrypted| argument.  It's not needed, because this information is contained
in the value of the |int download_info_type| argument.
\par
Added code to account for non-encrypted 
download information.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
add_download_info(string curr_string, 
                  string curr_package_name,
                  string curr_package_version = "",
                  int download_info_type = 0);

#endif 

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::add_download_info| definition@>=

#if HAVE_LIBMYSQLCLIENT
int
Scan_Parse_Parameter_Type::add_download_info(string curr_string, 
                                             string curr_package_name,
                                             string curr_package_version,
                                             int download_info_type)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::add_download_info':"
            << endl;

       cerr  << "`curr_string' == " << curr_string
             << endl 
             << "`curr_package_name' == " << curr_package_name
             << endl 
             << "`curr_package_version' == " << curr_package_version
             << endl 
             << "`download_info_type' == " << download_info_type
             << endl; 

       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */


    int status = 0;

@q ****** (6) Error handling:  |curr_string| is empty.  @>

@ Error handling:  |curr_string| is empty.  
\initials{LDF 2010.10.06.}

@<|Scan_Parse_Parameter_Type::add_download_info| definition@>=

    if (curr_package_name.empty())
    {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::add_download_info':"
            << endl
            << "`curr_string' is empty.  Can't add download info."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;
       
    }  /* |if (curr_package_name.empty())|  */

@q ****** (6) Error handling:  |curr_package_name| is empty.  @>

@ Error handling:  |curr_package_name| is empty.  
\initials{LDF 2010.10.06.}

@<|Scan_Parse_Parameter_Type::add_download_info| definition@>=

    if (curr_package_name.empty())
    {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::add_download_info':"
            << endl
            << "`curr_package_name' is empty.  Can't add download info."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 
       
       return 1;

    }  /* |if (curr_package_name.empty())|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_download_info| definition@>=

    Entry_Type curr_entry;
    curr_entry.package_name = curr_package_name;
    curr_entry.package_version = curr_package_version;

    if (download_info_type == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE)
    {
        curr_entry.encrypted_flag = true;
        curr_entry.download_url_encrypted = curr_string;
    }

    else if (download_info_type == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE) 
    {
        curr_entry.encrypted_flag = true;
        curr_entry.download_command_encrypted = curr_string;
    }
    else if (download_info_type == Response_Type::DOWNLOAD_COMMAND_TYPE) 
    {

        curr_entry.encrypted_flag = false;
        curr_entry.download_command = curr_string;

    }
    else if (download_info_type == Response_Type::DOWNLOAD_URL_TYPE) 
    {

        curr_entry.encrypted_flag = false;
        curr_entry.download_url = curr_string;

    }

    emendations.push_back(curr_entry);

@q ****** (6) @>

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::add_download_info' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

    return 0;

}  /* End of |Scan_Parse_Parameter_Type::add_download_info| definition   */

#endif 

@q **** (4) Add Authorization.  @>

@ Add Authorization.
\initials{LDF 2011.11.22.}

\LOG
\initials{LDF 2011.11.22.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
add_authorization(string curr_string, 
                  string curr_package_name,
                  string curr_package_version = "");

#endif 

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::add_authorization| definition@>=

#if HAVE_LIBMYSQLCLIENT
int
Scan_Parse_Parameter_Type::add_authorization(string curr_string, 
                                             string curr_package_name,
                                             string curr_package_version)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::add_authorization':"
            << endl;

       cerr  << "`curr_string' == " << curr_string
             << endl 
             << "`curr_package_name' == " << curr_package_name
             << endl 
             << "`curr_package_version' == " << curr_package_version
             << endl; 

       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */


    int status = 0;

@q ****** (6) Error handling:  |curr_string| is empty.  @>

@ Error handling:  |curr_string| is empty.  
\initials{LDF 2010.10.06.}

@<|Scan_Parse_Parameter_Type::add_authorization| definition@>=

    if (curr_package_name.empty())
    {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::add_authorization':"
            << endl
            << "`curr_string' is empty.  Can't add authorization."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;
       
    }  /* |if (curr_package_name.empty())|  */

@q ****** (6) Error handling:  |curr_package_name| is empty.  @>

@ Error handling:  |curr_package_name| is empty.  
\initials{LDF 2010.10.06.}

@<|Scan_Parse_Parameter_Type::add_authorization| definition@>=

    if (curr_package_name.empty())
    {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::add_authorization':"
            << endl
            << "`curr_package_name' is empty.  Can't add authorization."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 
       
       return 1;

    }  /* |if (curr_package_name.empty())|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_authorization| definition@>=

    Entry_Type curr_entry;
    curr_entry.package_name = curr_package_name;
    curr_entry.package_version = curr_package_version;

    curr_entry.authorization = curr_string;

    emendations.push_back(curr_entry);

@q ****** (6) @>

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::add_authorization' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

    return 0;

}  /* End of |Scan_Parse_Parameter_Type::add_authorization| definition   */

#endif 

@q **** (4) Write Emendations.  @>

@ Write Emendations.
\initials{LDF 2010.10.01.}

\LOG
\initials{LDF 2010.10.01.}
Added this function.

\initials{LDF 2010.10.07.}
Finished writing this function.

\initials{LDF 2011.06.08.}
Added code to account for encrypted download commands and download URLs.

\initials{LDF 2011.10.31.}
Added code to account for unencrypted download commands and download URLs.

\initials{LDF 2011.11.22.}
Added code to account for authorization files.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
write_emendations(void);

#endif 

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::write_emendations| definition@>=

#if HAVE_LIBMYSQLCLIENT
int
Scan_Parse_Parameter_Type::write_emendations(void)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::write_emendations':"
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

    int status = 0;

    Response_Type response; 
    response.type = Response_Type::COMMAND_ONLY_TYPE;       

    stringstream temp_strm;   
    stringstream sql_strm;

    MYSQL_RES *result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    int curr_entry_id = 0;

    int curr_type;

@q ****** (6) @>
@
@:NOTE@> !! PLEASE NOTE::  |curr_type| has nothing to do with |response|!  
|response.type| remains |Response_Type::COMMAND_ONLY_TYPE| throughout this 
function.
\initials{LDF 2011.10.31.}

@<|Scan_Parse_Parameter_Type::write_emendations| definition@>=

   for (vector<Entry_Type>::iterator iter = emendations.begin();
        iter != emendations.end();
        ++iter)
   {
@q ******* (7) @>

       if (!iter->installation_script.empty())
          curr_type = Response_Type::INSTALLATION_SCRIPT_TYPE;
       else if (!iter->installation_script_encrypted.empty())
          curr_type = Response_Type::INSTALLATION_SCRIPT_ENCRYPTED_TYPE;

       else if (!iter->download_url.empty())
          curr_type = Response_Type::DOWNLOAD_URL_TYPE;
       else if (!iter->download_command.empty())
          curr_type = Response_Type::DOWNLOAD_COMMAND_TYPE;

       else if (!iter->download_url_encrypted.empty())
          curr_type = Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE;
       else if (!iter->download_command_encrypted.empty())
          curr_type = Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE;
       else if (!iter->authorization.empty())
          curr_type = Response_Type::AUTHORIZATION_TYPE;

      /* !! TODO: LDF 2011.06.08. Add error handling for other (invalid) types.  */

       if (DEBUG)
       {
           iter->show();
           cerr << "curr_type == " << curr_type << endl;

       }  /* |if (DEBUG)|  */ 

       sql_strm.str("");

       sql_strm << "select entry_id from Entries where user_id = ";

       if (effective_user_id > 0)
          sql_strm << effective_user_id;
 
       else
          sql_strm << user_id;

       sql_strm << " and package_name = '" << iter->package_name << "'";

       if (!iter->package_version.empty())
          sql_strm << " and package_version = '" << iter->package_version << "'";

       sql_strm << " order by last_modified desc";

       if (DEBUG) 
          cerr << "`sql_strm.str()' == " << sql_strm.str() << endl;

       status = submit_mysql_query(sql_strm.str(),
                                    result, 
                                    &row_ctr, 
                                    &field_ctr);

       if (status)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "WARNING!  In `Scan_Parse_Parameter_Type::write_emendations':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                << status << "."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

          if (result) 
             mysql_free_result(result);

          return 1;


       }  /* |if (status)|  */

       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::write_emendations':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

@q ******* (7) @>

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::write_emendations':"
                << endl 
                << "row_ctr == " << row_ctr 
                << endl
                << "field_ctr == " << field_ctr 
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */


@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::write_emendations| definition@>=

       if (row_ctr == 0)
       {
           mysql_free_result(result);
           result = 0;

           temp_strm.str("");

           temp_strm << "SERVER ENTRY <" << iter->package_name << "> ";

           if (!iter->package_version.empty())
              temp_strm << "<" << iter->package_version << "> ";

          temp_strm << "NOT_FOUND NOT ADDING ";

          if (   curr_type == Response_Type::INSTALLATION_SCRIPT_TYPE
              || curr_type == Response_Type::INSTALLATION_SCRIPT_ENCRYPTED_TYPE)

            temp_strm << "INSTALLATION_SCRIPT <" 
                      << iter->installation_script << ">";

           else if (curr_type == Response_Type::DOWNLOAD_COMMAND_TYPE)

             temp_strm << "DOWNLOAD_COMMAND <" 
                       << iter->download_command << ">";

           else if (curr_type == Response_Type::DOWNLOAD_URL_TYPE)

             temp_strm << "DOWNLOAD_URL <" 
                       << iter->download_url << ">";

           else if (curr_type == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE)

             temp_strm << "DOWNLOAD_COMMAND_ENCRYPTED <" 
                       << iter->download_command_encrypted << ">";

           else if (curr_type == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE)

             temp_strm << "DOWNLOAD_URL_ENCRYPTED <" 
                       << iter->download_url_encrypted << ">";


           else if (curr_type == Response_Type::AUTHORIZATION_TYPE)

             temp_strm << "AUTHORIZATION_TYPE <" 
                       << iter->authorization << ">";

            
           response.command = temp_strm.str();

           pthread_mutex_lock(&response_deque_mutex);
           response_deque.push_front(response);
           pthread_mutex_unlock(&response_deque_mutex);
           
           temp_strm.str("");

           continue;


       }  /* |if (row_ctr == 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::write_emendations| definition@>=

       else if (row_ctr > 1)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "WARNING!  In `Scan_Parse_Parameter_Type::write_emendations':"
                << endl 
                << "Multiple entries (" << row_ctr << "):  " 
                << iter->package_name;

           if (!iter->package_version.empty())
              cerr << " " << iter->package_version;


          if (   curr_type == Response_Type::INSTALLATION_SCRIPT_TYPE
              || curr_type == Response_Type::INSTALLATION_SCRIPT_ENCRYPTED_TYPE)

              cerr << endl << "Adding installation script to most recent one (`last_modified')."
                   << endl;


           else if (curr_type == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE)

              cerr << endl << "Adding download command to most recent one (`last_modified')."
                   << endl;

           else if (curr_type == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE)
            
              cerr << endl << "Adding download URL to most recent one (`last_modified')."
                   << endl;

           else if (curr_type == Response_Type::AUTHORIZATION_TYPE)
            
              cerr << endl << "Adding authorization to most recent one (`last_modified')."
                   << endl;

           unlock_cerr_mutex(); 


       }  /* |else if (row_ctr > 1)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::write_emendations| definition@>=

       else if (row_ctr == 1 && DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::write_emendations':"
                << endl 
                << "One entry found for "
                << iter->package_name;

           if (!iter->package_version.empty())
              cerr << " " << iter->package_version;

          if (   curr_type == Response_Type::INSTALLATION_SCRIPT_TYPE
              || curr_type == Response_Type::INSTALLATION_SCRIPT_ENCRYPTED_TYPE)

              cerr << endl << "Adding installation script."
                   << endl;

           else if (curr_type == Response_Type::DOWNLOAD_COMMAND_TYPE)

              cerr << endl << "Adding download command (unencrypted)."
                   << endl;

           else if (curr_type == Response_Type::DOWNLOAD_URL_TYPE)

              cerr << endl << "Adding download URL (unencrypted)."
                   << endl;

           else if (curr_type == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE)

              cerr << endl << "Adding download command (encrypted)."
                   << endl;

           else if (curr_type == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE)

              cerr << endl << "Adding download URL (encrypted)."
                   << endl;

           else if (curr_type == Response_Type::AUTHORIZATION_TYPE)

              cerr << endl << "Adding authorization."
                   << endl;


           unlock_cerr_mutex(); 

       }  /* |else if (row_ctr == 1 && DEBUG)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::write_emendations| definition@>=
   
       if ((curr_row = mysql_fetch_row(result)) == 0)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::write_emendations':"
                << endl 
                << "`mysql_fetch_row' failed:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Continuing."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);
           result = 0;

           temp_strm.str("");
           temp_strm << "SERVER ENTRY <" << iter->package_name << ">";

           if(!iter->package_version.empty())
              temp_strm << " <" << iter->package_version << ">";


          temp_strm << " NOT_FOUND NOT ADDING ";

          if (   curr_type == Response_Type::INSTALLATION_SCRIPT_TYPE
              || curr_type == Response_Type::INSTALLATION_SCRIPT_ENCRYPTED_TYPE)

              temp_strm << "INSTALLATION_SCRIPT "
                        << "<" << iter->installation_script << ">";

           else if (curr_type == Response_Type::DOWNLOAD_COMMAND_TYPE)

             temp_strm << "DOWNLOAD_COMMAND <" 
                       << iter->download_command << ">";

           else if (curr_type == Response_Type::DOWNLOAD_URL_TYPE)

             temp_strm << "DOWNLOAD_URL <" 
                       << iter->download_url << ">";

           else if (curr_type == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE)

             temp_strm << "DOWNLOAD_COMMAND_ENCRYPTED <" 
                       << iter->download_command_encrypted << ">";

           else if (curr_type == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE)

             temp_strm << "DOWNLOAD_URL_ENCRYPTED <" 
                       << iter->download_url_encrypted << ">";

           else if (curr_type == Response_Type::AUTHORIZATION_TYPE)

             temp_strm << "AUTHORIZATION <" 
                       << iter->authorization << ">";

           
           response.command = temp_strm.str();

           pthread_mutex_lock(&response_deque_mutex);
           response_deque.push_back(response);
           pthread_mutex_unlock(&response_deque_mutex);

           temp_strm.str("");

           continue;

       }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ******* (7) @>
@
\LOG
\initials{LDF 2011.06.08.}
Added code to account for encrypted installation scripts.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::write_emendations| definition@>=

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::write_emendations':"
                << endl 
                << "`curr_row[0]' == " << curr_row[0]
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

       if (curr_row[0])
       {
@q ******** (8) @>

          sscanf(curr_row[0], "%d", &curr_entry_id);

          if (DEBUG)
          {
             lock_cerr_mutex(); 
             cerr << "[Thread " << thread_ctr << "]:  "
                  << "In `Scan_Parse_Parameter_Type::write_emendations':"
                  << endl 
                  << "`curr_entry_id' == " << curr_entry_id
                  << endl;
             unlock_cerr_mutex(); 

          }  /* |if (DEBUG)|  */ 

          temp_strm.str("");

@q ******** (8) @>

          if (curr_type == Response_Type::INSTALLATION_SCRIPT_ENCRYPTED_TYPE)
   
             temp_strm << "SEND INSTALLATION_SCRIPT_ENCRYPTED <"
                       << iter->installation_script_encrypted << "> ";

@q ******** (8) @>

          else if (curr_type == Response_Type::INSTALLATION_SCRIPT_TYPE)

             temp_strm << "SEND INSTALLATION_SCRIPT <"
                       << iter->installation_script << "> ";

@q ******** (8) @>

@
\LOG
\initials{LDF 2011.10.31.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::write_emendations| definition@>=

          else if (   curr_type == Response_Type::DOWNLOAD_COMMAND_TYPE 
                   || curr_type == Response_Type::DOWNLOAD_URL_TYPE)
          {
@q ********* (9) @>

                if (result)
                   mysql_free_result(result);
                result = 0;

                sql_strm.str("");

                sql_strm << "update Entries set ";

                if (curr_type == Response_Type::DOWNLOAD_URL_TYPE)

                   sql_strm << "download_url = "
                            << "'" << iter->download_url<< "' ";

                else
                   sql_strm << "download_command = "
                            << "'" << iter->download_command<< "' ";

                sql_strm << "where entry_id = " << curr_entry_id;

                if (DEBUG) 
                {
                    lock_cerr_mutex(); 
                    cerr << "`sql_strm.str()' == " << sql_strm.str() << endl;
                    unlock_cerr_mutex(); 
                }

@q ********* (9) @>

                status = submit_mysql_query(sql_strm.str(), result, 0, 0);

@q ********* (9) @>

                if (status)
                {
                    lock_cerr_mutex(); 
                    cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                         << "WARNING!  In `Scan_Parse_Parameter_Type::write_emendations':"
                         << endl 
                         << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                         << status << "."
                         << endl
                         << "Continuing."
                         << endl;
                    unlock_cerr_mutex(); 

                   if (result) 
                      mysql_free_result(result);

                   result = 0;

                   temp_strm.str("");

                   temp_strm << "FAILED TO ADD ";

                   if (curr_type == Response_Type::DOWNLOAD_URL_TYPE)
                       temp_strm << "DOWNLOAD_URL ";
                   else
                       temp_strm << "DOWNLOAD_COMMAND ";


                }  /* |if (status)|  */

@q ********* (9) @>

                else 
                {

                    if (DEBUG)
                    {
                        lock_cerr_mutex(); 
                        cerr << "[Thread " << thread_ctr << "]:  "
                             << "In `Scan_Parse_Parameter_Type::write_emendations':"
                             << endl 
                             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                             << endl;
                        unlock_cerr_mutex(); 

                    }  /* |if (DEBUG)|  */

                    temp_strm.str("");

                    temp_strm << "ADDED ";

                    if (curr_type == Response_Type::DOWNLOAD_URL_TYPE)
                        temp_strm << "DOWNLOAD_URL ";
                    else
                        temp_strm << "DOWNLOAD_COMMAND ";


                }  /* |else|  */

@q ********* (9) @>

          }  /* |else|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::write_emendations| definition@>=

          else if (curr_type == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE)
          {
             temp_strm << "SEND DOWNLOAD_COMMAND_ENCRYPTED <" 
                       << iter->download_command_encrypted << ">";
          }

          else if (curr_type == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE)
          {
             temp_strm << "SEND DOWNLOAD_URL_ENCRYPTED <" 
                       << iter->download_url_encrypted << ">";
          }

          else if (curr_type == Response_Type::AUTHORIZATION_TYPE)
          {
             temp_strm << "SEND AUTHORIZATION <" 
                       << iter->authorization << ">";
          }


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::write_emendations| definition@>=


          temp_strm << "FOR ENTRY " << curr_entry_id
                     << " <" << iter->package_name << ">";

          if(!iter->package_version.empty())
              temp_strm << " <" << iter->package_version << ">";

          response.command = temp_strm.str();

          pthread_mutex_lock(&response_deque_mutex);
          response_deque.push_back(response);
          pthread_mutex_unlock(&response_deque_mutex);


          temp_strm.str("");

          if (result)
             mysql_free_result(result);
          result = 0;

@q ******** (8) @>

       }  /* |if (curr_row[0])|  */

@q ******* (7) @>

       else 
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::write_emendations':"
                 << endl 
                 << "`curr_row[0]' == NULL."
                 << endl 
                 << "Continuing."
                 << endl;
           unlock_cerr_mutex(); 

           temp_strm.str("");
           temp_strm << "SERVER ENTRY <" << iter->package_name << ">";

           if(!iter->package_version.empty())
              temp_strm << " <" << iter->package_version << ">";

          temp_strm << " NOT_FOUND NOT ADDING ";

          if (   curr_type == Response_Type::INSTALLATION_SCRIPT_TYPE
              || curr_type == Response_Type::INSTALLATION_SCRIPT_ENCRYPTED_TYPE)
   
              temp_strm << "INSTALLATION_SCRIPT "
                        << "<" << iter->installation_script << ">";

           else if (curr_type == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE)

             temp_strm << "DOWNLOAD_COMMAND_ENCRYPTED <" 
                       << iter->download_command_encrypted << ">";

           else if (curr_type == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE)

             temp_strm << "DOWNLOAD_URL_ENCRYPTED <" 
                       << iter->download_url_encrypted << ">";

           else if (curr_type == Response_Type::AUTHORIZATION_TYPE)

             temp_strm << "AUTHORIZATION <" 
                       << iter->authorization << ">";
            
           else if (curr_type == Response_Type::DOWNLOAD_COMMAND_TYPE)

             temp_strm << "DOWNLOAD_COMMAND <" 
                       << iter->download_command << ">";

           else if (curr_type == Response_Type::DOWNLOAD_URL_TYPE)

             temp_strm << "DOWNLOAD_URL <" 
                       << iter->download_url << ">";

           response.command = temp_strm.str();

           pthread_mutex_lock(&response_deque_mutex);
           response_deque.push_back(response);
           pthread_mutex_unlock(&response_deque_mutex);

           temp_strm.str("");

           mysql_free_result(result);
           result = 0;

           continue;

       }  /* |else|  */

@q ******* (7) @>

   }  /* |for|  */

   emendations.clear();

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::write_emendations| definition@>=

    if (DEBUG) 
    { 
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::write_emendations' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

    } /* |if (DEBUG)| */

    return 0;

}  /* End of |Scan_Parse_Parameter_Type::write_emendations| definition   */

#endif 

@q **** (4) Get Encrypted.  @>

@ Get Encrypted.
\initials{LDF 2011.01.27.}

\LOG
\initials{LDF 2011.01.27.}
Added this function.

\initials{LDF 2011.02.03.}
Added code for extracting the owner and key name from the database.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
get_encrypted(const int& entry_id, string* key_name = 0, string* owner = 0);

#endif 

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::get_encrypted| definition@>=

#if HAVE_LIBMYSQLCLIENT
int
Scan_Parse_Parameter_Type::get_encrypted(const int& entry_id, string* key_name, string* owner)
{

@q ****** (6) @>

    int status = 0;

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    stringstream sql_strm;

    MYSQL_RES *result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "Entering `Scan_Parse_Parameter_Type::get_encrypted'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_encrypted| definition@>=

    sql_strm << "select encrypted, owner from Entries where entry_id = '"
             << entry_id << "'";

    
    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::get_encrypted':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value -1."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       if (owner)
          *owner = "";
    
       if (key_name)
          *key_name = "";
 

       return -1;

    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_encrypted':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_encrypted':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) |entry_id| unknown.@>

@ |entry_id| unknown.
\initials{LDF 2011.01.27.}

@<|Scan_Parse_Parameter_Type::get_encrypted| definition@>=

    if (row_ctr == 0)  /* |entry_id| unknown  */
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_encrypted':  "
             << "`entry_id' is unknown."
             << endl 
             << "Exiting function unsuccessfully with return value -1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        if (owner)
          *owner = "";
    
        if (key_name)
          *key_name = "";

        return -1;

    }  /* |if (row_ctr == 0)| (|entry_id| unknown)  */

@
@<|Scan_Parse_Parameter_Type::get_encrypted| definition@>=

    else /* |row_ctr > 0| (|entry_id| known)  */
    {
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::get_encrypted':  "
                << "`entry_id' known."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

    }  /* |else| (|row_ctr > 0|, |entry_id| known)  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_encrypted| definition@>=

    if ((curr_row = mysql_fetch_row(result)) == 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_encrypted':"
             << endl 
             << "`mysql_fetch_row' failed:"
             << endl
             << mysql_error(mysql_ptr)
             << endl 
             << "Exiting function unsuccessfully with return value -1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        if (owner)
          *owner = "";
    
        if (key_name)
          *key_name = "";

        return -1;

    }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_encrypted| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_encrypted':"
             << endl 
             << "`curr_row[0]' == " << curr_row[0]
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    int encrypted;

    if (curr_row[0])
    {
@q ******* (7) @>

        encrypted = strtol(curr_row[0], 0, 0);

        if (encrypted && curr_row[1] == 0)
        {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "WARNING!  In `Scan_Parse_Parameter_Type::get_encrypted':"
                 << endl 
                 << "`encrypted' is non-null and `owner' is null."
                 << endl 
                 << "This shouldn't happen."
                 << endl 
                 << "Setting `*key_name' and/or `*owner' "
                 << "(if non-null) to the empty string and "
                 << "exiting function with return value "
                 << "`encrypted' == " << encrypted
                 << endl;
           unlock_cerr_mutex(); 

           if (owner)
              *owner = "";

           if (key_name)
              *key_name = "";

           mysql_free_result(result);

           return encrypted;

        }  /* |if (encrypted && curr_row[1] == 0)|  */
 
@q ******* (7) @>

        else if (encrypted && curr_row[1] != 0)
        {
@q ******** (8) @>

           if (owner)
              *owner = curr_row[1];

           sql_strm.str("");
           
           sql_strm << "select key_name from Public_Keys where key_name = '"
                    << curr_row[1] << "'";

           mysql_free_result(result);
        
           status = submit_mysql_query(sql_strm.str(),
                                       result, 
                                       &row_ctr, 
                                       &field_ctr);

           
           sql_strm.str("");
 
           if (status)
           {
               lock_cerr_mutex(); 
               cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                    << "WARNING!  In `Scan_Parse_Parameter_Type::get_encrypted':"
                    << endl 
                    << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                    << status << "."
                    << endl
                    << "Exiting function unsuccessfully with return value -1."
                    << endl;
               unlock_cerr_mutex(); 

               if (owner)
                  *owner = "";
    
               if (key_name)
                  *key_name = "";
 
              if (result) 
                 mysql_free_result(result);

              return -1;

           }  /* |if (status)|  */

           else if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "In `Scan_Parse_Parameter_Type::get_encrypted':"
                    << endl 
                    << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */

@q ******** (8) @>

           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "In `Scan_Parse_Parameter_Type::get_encrypted':"
                    << endl 
                    << "row_ctr == " << row_ctr 
                    << endl
                    << "field_ctr == " << field_ctr 
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */

@q ******** (8) |owner| unknown.@>

@ |owner| unknown.
\initials{LDF 2011.02.03.}

@<|Scan_Parse_Parameter_Type::get_encrypted| definition@>=

           if (row_ctr == 0)  /* |owner| unknown  */
           {
               lock_cerr_mutex(); 
               cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                    << "ERROR!  In `Scan_Parse_Parameter_Type::get_encrypted':  "
                    << "`owner' is unknown."
                    << endl 
                    << "Exiting function unsuccessfully with return value -1."
                    << endl;
               unlock_cerr_mutex(); 

               if (owner)
                  *owner = "";
    
               if (key_name)
                  *key_name = "";
 
               if (result)
                  mysql_free_result(result);

               return -1;

           }  /* |if (row_ctr == 0)| (|owner| unknown)  */

@
@<|Scan_Parse_Parameter_Type::get_encrypted| definition@>=

           else /* |row_ctr > 0| (|owner| known)  */
           {
              if (DEBUG)
              {
                  lock_cerr_mutex(); 
                  cerr << "[Thread " << thread_ctr << "]:  "
                       << "In `Scan_Parse_Parameter_Type::get_encrypted':  "
                       << "`owner' known."
                       << endl;
                  unlock_cerr_mutex(); 

              }  /* |if (DEBUG)|  */

           }  /* |else| (|row_ctr > 0|, |owner| known)  */

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::get_encrypted| definition@>=

           if ((curr_row = mysql_fetch_row(result)) == 0)
           {
               lock_cerr_mutex(); 
               cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                    << "ERROR!  In `Scan_Parse_Parameter_Type::get_encrypted':"
                    << endl 
                    << "`mysql_fetch_row' failed:"
                    << endl
                    << mysql_error(mysql_ptr)
                    << endl 
                    << "Exiting function unsuccessfully with return value -1."
                    << endl;
               unlock_cerr_mutex(); 

               if (owner)
                  *owner = "";
    
               if (key_name)
                  *key_name = "";

               if (result)
                  mysql_free_result(result);

               return -1;

           }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::get_encrypted| definition@>=

           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "]:  "
                    << "In `Scan_Parse_Parameter_Type::get_encrypted':"
                    << endl 
                    << "`curr_row[0]' == " << curr_row[0]
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */

@q ******** (8) @>

           if (key_name)
           {
              *key_name = curr_row[0];

              if (DEBUG)
              {
                  lock_cerr_mutex(); 
                  cerr << "[Thread " << thread_ctr << "]:  "
                        << "In `Scan_Parse_Parameter_Type::get_encrypted':"
                        << endl 
                        << "`*key_name' == " << *key_name << "."
                        << endl;
                  unlock_cerr_mutex(); 

              }  /* |if (DEBUG)|  */ 

           }  /* |if (key_name)|  */
         
@q ******** (8) @>
   
        }  /* |else if (encrypted && curr_row[1] != 0)|  */

@q ******* (7) @>

    }  /* |if (curr_row[0])|  */

@q ****** (6) @>

    else 
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
              << "ERROR!  In `Scan_Parse_Parameter_Type::get_encrypted':"
              << endl 
              << "`curr_row[0]' == NULL."
              << endl 
              << "Exiting function unsuccessfully with return value -1."
              << endl;
        unlock_cerr_mutex(); 

        if (owner)
          *owner = "";
    
        if (key_name)
          *key_name = "";

        mysql_free_result(result);

        return -1;

    }  /* |else|  */

@q ****** (6) @>

    return encrypted;


}  /* End of |Scan_Parse_Parameter_Type::get_encrypted| definition  */

#endif 


@q **** (4) Get Key Name.  @>

@ Get Key Name.
\initials{LDF 2011.01.27.}

\LOG
\initials{LDF 2012.01.13.}
Removed the definition of this function to \filename{spptkyfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
string
get_key_name(const string& owner);

#endif 

@q **** (4) Store Key_Pair.  @>

@ Store \.{Key\_Pair}.
\initials{LDF 2011.11.04.}

\LOG
\initials{LDF 2012.01.13.}
Removed the definition of this function to \filename{spptkyfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
store_key_pair(const char *filename);

#endif 


@q **** (4) Store Public Key.  @>

@ Store public key.

\LOG
\initials{LDF 2012.01.13.}
Removed the definition of this function to \filename{spptkyfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
store_public_key(const char *filename);

#endif 


@q **** (4) Fetch key pair. @>

@ Fetch key pair.
\initials{LDF 2011.11.10.}

\LOG
\initials{LDF 2012.01.13.}
Removed the definition of this function to \filename{spptkyfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
fetch_key_pair(Response_Type& response);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */


@q **** (4) Get key pair. @>

@ Get key pair.
\initials{LDF 2011.11.23.}

\LOG
\initials{LDF 2012.01.13.}
Removed the definition of this function to \filename{spptkyfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
get_key_pair(void);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Install key pair and set trust value.  @>

@ Install key pair and set trust value.
\initials{LDF 2011.11.14.}

\LOG
\initials{LDF 2012.01.13.}
Removed the definition of this function to \filename{spptkyfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
install_key_pair(const char *key_name, const char *filename);

@ {\bf get\_optinum\_installer\_gpg\_pubkey\_fingerprint}.  
\initials{LDF 2011.11.21.}

\LOG
\initials{LDF 2012.01.13.}
Removed the definition of this function to \filename{spptkyfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
int
get_optinum_installer_gpg_pubkey_fingerprint(void);


@q **** (4) Distribute key pair.  @>

@ Distribute key pair.
\initials{LDF 2011.11.21.}

\LOG
\initials{LDF 2012.01.13.}
Removed the definition of this function to \filename{spptkyfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
distribute_key_pair(Response_Type &response);

#endif /* |HAVE_LIBMYSQLCLIENT|  */


@q **** (4) Check public key.  @>

@ Check public key.
\initials{LDF 2011.12.12.}

This function is currently not used, but I'm leaving it here in case it 
may be useful sometime.
\initials{LDF 2011.12.12.}

\LOG
\initials{LDF 2012.01.13.}
Removed the definition of this function to \filename{spptkyfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
check_public_key(void);

#endif /* |HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Delete key pair.  @>

@ Delete key pair.
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2012.01.13.}
Removed the definition of this function to \filename{spptkyfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
delete_key_pair(void);

#endif /* |HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Delete public key.  @>

@ Delete public key.
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2012.01.13.}
Removed the definition of this function to \filename{spptkyfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
delete_public_key(void);

#endif /* |HAVE_LIBMYSQLCLIENT|  */


@q **** (4) Get session data.  @>

@ Get session data.
\initials{LDF 2012.01.03.}

\LOG
\initials{LDF 2012.01.03.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
get_session_data(void);

#endif /* |HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::get_session_data| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::get_session_data(void)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG); 

    int status = 0;

    if (DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "Entering `Scan_Parse_Parameter_Type::get_session_data'." 
             << endl;
        unlock_cerr_mutex(); 
    
    }  /* |if (DEBUG)|  */ 
    


@q ****** (6) Check whether session data has already been fetched.  @>

@ Check whether session data has already been fetched.  
\initials{LDF 2012.01.03.}

@<|Scan_Parse_Parameter_Type::get_session_data| definition@>=

    if (session_data != 0)
    {
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::get_session_data':"
                 << endl
                 << "Session data has already been fetched.  "
                 << "Not initializing or refetching."
                 << endl
                 << "Exiting function successfully with return value 0."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */   

        return 0;

    }  /* |if (session_data != 0)|  */
   
    else if (DEBUG)
    { 
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::get_session_data':"
                 << endl
                 << "Session data has not already been fetched.  "
                 << "Will initialize or fetch."
                 << endl;
            unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 

@q ****** (6) Initialize |session_data|.  @>

@ Initialize |session_data|.  
\initials{LDF 2012.01.03.}

\LOG
\initials{LDF 2012.01.03.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_session_data| definition@>=

    session_data = new Session_Data_Type;

    if (session_data == 0)
    {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::get_session_data':"
                 << endl
                 << "`new Session_Data_Type' failed.  Failed to initialize " 
                 << "`this->session_data'."
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            return 1;

    }  /* |if (session_data == 0)|  */

    else if (DEBUG)
    {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::get_session_data':"
                 << endl
                 << "`new Session_Data_Type' succeeded.  Initialized " 
                 << "`this->session_data' successfully."
                 << endl;
            unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_session_data| definition@>=

    stringstream sql_strm;

    int curr_user_id = (effective_user_id > 0) ? effective_user_id : user_id;

    MYSQL_RES *result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_session_data| definition@>=

    sql_strm << "select user_id, effective_user_id, "
             << "user_name, effective_user_name from Session_Data where "
             << "session_id = '" << session_id << "'";

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_session_data':" 
             << endl
             << "`sql_strm.str()' == " << sql_strm.str()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

@q ****** (6) @>

    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::get_session_data':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return 1;


    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_session_data':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_session_data':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) No session data.  Initialize new session data.  @>    
@ Initialize new session data.  
\initials{LDF 2012.01.03.}

\LOG
\initials{LDF 2012.01.03.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_session_data| definition@>=

    if (row_ctr == 0)
    {
@q ******* (7) @>

        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::get_session_data':"
                 << endl 
                 << "row_ctr == 0.  No session data for session "
                 << "`" << session_id << ".'"
                 << endl
                 << "Will initialize session data."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */

@q ******* (7) Add row to `Session_Data' table.  @>

@ Add row to \.{Session\_Ids} table.  
\initials{LDF 2012.01.03.}

\LOG
\initials{LDF 2012.01.03.}
Added this section.

\initials{LDF 2012.01.10.}
Now writing timestamp to database entry.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_session_data| definition@>=
 
       mysql_free_result(result);
       result = 0;

       sql_strm.str("");

       sql_strm << "insert into Session_Data (session_id, user_id, "
                << "effective_user_id, user_name, effective_user_name, "
                << "timestamp) values "
                << "('" << session_id << "', "
                << user_id << ", " << effective_user_id 
                << ", '" << user_name << "', '" << effective_user_name 
                << "', utc_timestamp())";

       if (DEBUG)
       {
           lock_cerr_mutex();
           cerr << "sql_strm.str() == " << sql_strm.str() << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 


       status = submit_mysql_query(sql_strm.str(),
                                   result, 
                                   0, 
                                   0);

       if (status)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "WARNING!  In `Scan_Parse_Parameter_Type::get_session_data':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                << status << "."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

          if (result) 
             mysql_free_result(result);

          return 1;


       }  /* |if (status)|  */

       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::get_session_data':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_session_data| definition@>=

       session_data->session_id = session_id;

/* !! TODO:  LDF 2012.01.03.  Add more data members to 
   |Session_Data_Type|.  Add code below for when session data is fetched
   from the database.
*/

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           session_data->show("session_data:");
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 

@q ******* (7) @>

    }  /* |if (row_ctr == 0)|  Session data doesn't already exist.  */

@q ****** (6) Session data exists already.  @>
@ Session data exists already.  
\initials{LDF 2012.01.03.}

\LOG
\initials{LDF 2012.01.03.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_session_data| definition@>=

   else /* |row_ctr > 0|  */
   {
@q ******* (7) @>

        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::get_session_data':"
                 << endl 
                 << "row_ctr == " << row_ctr << ".  "
                 << "Session data for session "
                 << "`" << session_id << "' already exists."
                 << endl
                 << "Will fetch session data."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */

@q ******* (7) Fetch session data.  @>

@ Fetch session data.  
\initials{LDF 2012.01.03.}

\LOG
\initials{LDF 2012.01.03.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_session_data| definition@>=


@q ******* (7) @>

   } /* |else| (|row_ctr > 0|)  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_session_data| definition@>=

    mysql_free_result(result);

    result = 0;

    sql_strm.str("");

@q ****** (6) @>

    if (DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_session_data':"
             << endl
             << "Exiting function successfully with return value 0." 
             << endl;
         unlock_cerr_mutex(); 
    
    }  /* |if (DEBUG)|  */ 

    return 0;  

}  /* End of |Scan_Parse_Parameter_Type::get_session_data| definition  */

#endif /* |HAVE_LIBMYSQLCLIENT|  */


@q **** (4) Fetch environment.  @>

@ Fetch environment.
\initials{LDF 2012.03.19.}

\LOG
\initials{LDF 2012.03.19.}
Added this function.  It's defined in \filename{spptenvf.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
fetch_environment_shellscripts(Response_Type &response);

#endif /* |HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Store environment.  @>

@ Store environment.
\initials{LDF 2012.03.16.}

\LOG
\initials{LDF 2012.03.16.}
Added this function.

\initials{LDF 2012.03.19.}
Moved the definition of this function from this file (\filename{scprpmtp.web})
to \filename{spptenvf.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
store_environment_shellscript(void);

#endif /* |HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Delete environment shellscripts.  @>


@q **** (4) Check Globus site admin.  @>
@ Check Globus site admin.  
\initials{LDF 2012.03.23.}

\LOG
\initials{LDF 2012.03.23.}
Added this function declaration.  The definition is in \filename{spptenvf.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
check_globus_site_admin(unsigned int user_id, string globus_site);

#endif /* |HAVE_LIBMYSQLCLIENT|  */

@ Delete environment shellscripts.
\initials{LDF 2012.03.21.}

\LOG
\initials{LDF 2012.03.21.}
Added this function.  The definition is in \filename{spptenvf.web}.

\initials{LDF 2012.03.26.}
Added optional |int id| argument with default 0 and made |string globus_site| 
argument optional, too, with default |""|.
\ENDLOG

@q ***** (5) Declaration  @>
@
@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
delete_environment_shellscripts(int id = 0, string globus_site = "");

#endif /* |HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Show environment shellscripts.  @>

@ Show environment shellscripts.
\initials{LDF 2012.03.21.}

\LOG
\initials{LDF 2012.03.21.}
Added this function.  The definition is in \filename{spptenvf.web}.
\ENDLOG

@q ***** (5) Declaration  @>
@
@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
show_environment_shellscripts(Response_Type &response, char buffer[]);

#endif /* |HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Enable or disable environment shellscripts.  @>

@ Enable or disable environment shellscripts.
\initials{LDF 2012.03.26.}

\LOG
\initials{LDF 2012.03.26.}
Added this function.  The definition is in \filename{spptenvf.web}.
\ENDLOG

@q ***** (5) Declaration  @>
@
@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
enable_environment_shellscript(unsigned int id, 
                               bool disable_flag = false);

#endif /* |HAVE_LIBMYSQLCLIENT|  */

@q **** (4) @>

@q **** (4) Add Globus site to database.@>

@ Add Globus site to database.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this function declaration.  The definition is in \filename{spptgsfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
add_globus_site(void);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Mark Globus site for deletion from database.@>

@ Mark Globus site for deletion from database.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.12.}
Added this function declaration.  The definition is in \filename{spptgsfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT

int
mark_globus_site(bool delete_gs, string globus_site, int enable_optional = 0);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */



@q **** (4) Show Globus sites.  @>

@ Show Globus sites.
\initials{LDF 2012.04.13.}

\LOG
\initials{LDF 2012.04.13.}
Added this function declaration.  The definition is in \filename{spptgsfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
show_globus_sites(Response_Type &response, char buffer[]);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Delete Globus sites.  @>

@ Delete Globus sites.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this function declaration.  The definition is in \filename{spptgsfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
delete_globus_sites(bool finally);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */


@q **** (4) Enable and Disable Globus sites.  @>

@ Enable and Disable Globus sites.
\initials{LDF 2012.04.30.}

\LOG
\initials{LDF 2012.04.30.}
Added the function declaration for |enable_globus_site| and the |inline| definition of
|disable_globus_site|.  The definition of |enable_globus_site| is in \filename{spptgsfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
enable_globus_site(string globus_site, bool enable = true);

inline int
disable_globus_site(string globus_site) 
{
   return enable_globus_site(globus_site, false);
}

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Check privileges.  @>

@ Check privileges.
\initials{LDF 2012.04.30.}

\LOG
\initials{LDF 2012.04.30.}
Added this function declaration.  The definition is in \filename{spptgsfn.web}.

\initials{LDF 2012.05.03.}
Added optional argument |int *save_globus_site_id|.  Default is 0.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
check_privileges(unsigned int &privilege_val, 
                 bool quit_on_success = false, 
                 string privilege = "", 
                 string globus_site = "",
                 int *save_globus_site_id = 0);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Edit Globus site.  @>

@ Edit Globus site.
\initials{LDF 2012.05.03.}

\LOG
\initials{LDF 2012.05.03.}
Added this function declaration.  The definition is in \filename{spptgsfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
edit_globus_site(string globus_site, int set_or_unset);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Edit Globus site administrator.  @>

@ Edit Globus site administrator.
\initials{LDF 2012.05.02.}

\LOG
\initials{LDF 2012.05.02.}
Added this function declaration.  The definition is in \filename{spptgsfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
edit_globus_site_admin(string globus_site,
                       int admin_user_id, 
                       int action);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Show privileges.  @>

@ Show privileges.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this function declaration.  The definition is in \filename{spptprvl.web}.
\ENDLOG

@q ***** (5) Declaration   @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
show_privileges(Response_Type &response, char buffer[]);

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Check database tables.  @>

@ Check database tables.  
\initials{LDF 2012.05.10.}

\LOG
\initials{LDF 2012.05.10.}
Added this function.  The definition is in \filename{spptdbfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
check_database_tables(void);
#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Lock and unlock database tables.  @>

@ Lock and unlock database tables.  
\initials{LDF 2012.05.11.}

\LOG
\initials{LDF 2012.05.11.}
Added these function declarations and the |inline| definitions of 
|Scan_Parse_Parameter_Type::unlock_tables|, 
|Scan_Parse_Parameter_Type::lock_tables(string)| and 
|Scan_Parse_Parameter_Type::lock_table(string)|.
The definition of |Scan_Parse_Parameter_Type::lock_tables|
is in \filename{spptdbfn.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

#if HAVE_LIBMYSQLCLIENT
int
lock_tables(vector<string> *table_vector, bool unlock = false, string table = "");

inline
int
lock_tables(string s) { return lock_tables(0, true, s);}

inline
int
lock_table(string s) { return lock_tables(0, true, s);}

inline
int
unlock_tables(void) { return lock_tables(0, true);}
#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q **** (4) @>

@q *** (3) @>

@q ** (2) GPG_Key_Pair_Type. @>

@ {\bf GPG\_Key\_Pair\_Type}.
\initials{LDF 2011.11.22.}

\LOG
\initials{LDF 2011.11.22.}
Added this |struct| declaration.

\initials{LDF 2012.02.14.}
Changed |GPG_Key_Pair_Type| from a |struct| to a |class|.
Added |friend| declarations for |Scan_Parse_Parameter_Type|
and |sub_distribute_key_pair|.
\ENDLOG 

@q *** (3) Declaration  @>
 
@<|class GPG_Key_Pair_Type| declaration@>=

class GPG_Key_Pair_Type
{

    friend class Scan_Parse_Parameter_Type;

    friend void* sub_distribute_key_pair(void *v);

    Scan_Parse_Parameter_Type *param;

    string globus_site;

    int return_value;

    unsigned int sub_thread_ctr;

    pthread_t ptid;

    @<|GPG_Key_Pair_Type| function declarations@>@;

};

@q **** (4) |typedef| for convenience.  @>
@ |typedef| for convenience.  
\initials{LDF 2011.11.22.}

@<|class GPG_Key_Pair_Type| declaration@>=

typedef GPG_Key_Pair_Type Gpg_Key_Pair_Type;

@q *** (3) Default Constructor.  @>
@ Default Constructor.
\initials{LDF 2011.11.22.}

\LOG
\initials{LDF 2011.11.22.}
Added this function.
\ENDLOG

@<|GPG_Key_Pair_Type| function declarations@>=

GPG_Key_Pair_Type(void);

@
@<|GPG_Key_Pair_Type| default constructor definition@>=

GPG_Key_Pair_Type::GPG_Key_Pair_Type(void)
{
    param = 0;
    return_value = 0;
    ptid = 0;
    sub_thread_ctr = 0;

    return;
}


@q *** (3) Show.  @>
@ Show.
\initials{LDF 2011.11.22.}

\LOG
\initials{LDF 2011.11.22.}
Added this function.
\ENDLOG

@<|GPG_Key_Pair_Type| function declarations@>=
void
show(string s = "", bool show_param = false);

@
@<|GPG_Key_Pair_Type::show| definition@>=

void
GPG_Key_Pair_Type::show(string s, bool show_param)
{

    if (s.empty())
       cerr << "GPG_Key_Pair_Type:" << endl;
    else
       cerr << s << endl;


    cerr << "return_value == " << return_value
         << endl 
         << "ptid == " << ptid
         << endl 
         << "sub_thread_ctr == " << sub_thread_ctr
         << endl;

    if (show_param)
       param->show();

    return;

}


@q **** (4) @>
@
@<Garbage@>=

@q **** (4) @>

@q *** (3) Putting `scprpmtp.web' together.  @>

@ Putting {\tt scprpmtp\PERIOD web} together.

@q **** (4) This is what's compiled.  @>
@ This is what's compiled.
@c
@<Include files@>@;@/
using namespace std;
@<External function declarations@>@;@/
@<|class Scan_Parse_Parameter_Type| declaration@>@;@/
@<Initialize |static| constant |Scan_Parse_Parameter_Type| member variables@>@;@/
@<|class GPG_Key_Pair_Type| declaration@>@;@/
@<|Scan_Parse_Parameter_Type| constructor definitions@>@;
@<|Scan_Parse_Parameter_Type| destructor definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_database_username| definitions@>@;@/
@<|Scan_Parse_Parameter_Type::submit_mysql_query| definition@>@;@/
@<|Scan_Parse_Parameter_Type::show| definition@>@;@/
@<|Scan_Parse_Parameter_Type::fetch_installation_script| definition@>@;@/
@<|Scan_Parse_Parameter_Type::fetch_download_info| definition@>@;@/
@<|Scan_Parse_Parameter_Type::fetch_prerequisites| definition@>@;@/
@<|Scan_Parse_Parameter_Type::sub_fetch_prerequisites| definition@>@;@/
@<|Scan_Parse_Parameter_Type::fetch_authorization| definition@>@;@/
@<|Scan_Parse_Parameter_Type::validate_distinguished_name| definition@>@;@/
@<|Scan_Parse_Parameter_Type::add_prerequisite| definition@>@;@/
@<|Scan_Parse_Parameter_Type::request_prerequisites| definition@>@;@/
@<|Scan_Parse_Parameter_Type::cond_append| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_entries| definition@>@;@/
@<|Scan_Parse_Parameter_Type::check_grid_mapfile| definition@>@;@/
@<|Scan_Parse_Parameter_Type::check_delegation| definition@>@;@/
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>@;@/
@<|Scan_Parse_Parameter_Type::lookup| definition@>@;@/
@<|Scan_Parse_Parameter_Type::delete_entries| definition@>@;@/
@<|Scan_Parse_Parameter_Type::delete_prerequisites| definition@>@;@/
@<|Scan_Parse_Parameter_Type::add_installation_script| definition@>@;@/
@<|Scan_Parse_Parameter_Type::add_download_info| definition@>@;@/
@<|Scan_Parse_Parameter_Type::add_authorization| definition@>@;@/
@<|Scan_Parse_Parameter_Type::write_emendations| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_encrypted| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_session_data| definition@>@;@/
@<|GPG_Key_Pair_Type| default constructor definition@>@;@/
@<|GPG_Key_Pair_Type::show| definition@>@;@/


#if 0 
@<Garbage@>@;@/
#endif 

@q **** (4) This is what's written to the header file `scprpmtp.h'.  @>

@ This is what's written to the header file \filename{scprpmtp.h}.

\LOG
\initials{LDF 2012.01.03.}
Added forward declaration of |struct Session_Data_Type|.

\initials{LDF 2012.02.14.}
Changed |Session_Data_Type| from a |struct| to a |class|.
\ENDLOG 

@(scprpmtp.h@>=
#ifndef SCPRPMTP_H
#define SCPRPMTP_H 1
using namespace std;
class X509_Cert_Type;
class Session_Data_Type;
@<|class Scan_Parse_Parameter_Type| declaration@>@;@/
@<|class GPG_Key_Pair_Type| declaration@>@;@/
#endif 

@q * (1) Emacs-Lisp code for use in indirect buffers  @>

@q (progn (cweb-mode) (outline-minor-mode))                          @>

@q * (1) Local variables for Emacs @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q abbrev-mode:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>

