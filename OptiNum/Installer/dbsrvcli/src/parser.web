@q parser.web@>
@q Created by Laurence D. Finston (LDF) 2008.07.06.@>

@q * (1) Top @>

@q * (1) Copyright and License.@>

@q This file is part of the OptiNum Grid Installer @>
@q Copyright (C) 2010, 2011, 2012, 2013 Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen @>

@q The OptiNum Grid Installer is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q The OptiNum Grid Installer is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License          @>
@q along with the OptiNum Grid Installer; if not, write to the Free Software                    @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gwdg.de@>

@q Laurence D. Finston                                                   @>
@q Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen  @>
@q Am Fassberg 11         					         @>
@q 37077 Goettingen              					 @>
@q Germany                           					 @>                                

@q Laurence.Finston@@gwdg.de (@@ stands for a single "at" sign.)@>

@q * (1) Parser.  @>
@* Server Parser.
\initials{LDF 2008.08.19.}

@q ** (2) Include files.@>
@ Include files.

@<Include files@>=

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <limits.h>

#include <algorithm>
#include <fstream>
#include <iomanip>
#include <ios>
#include <iostream>
#include <iterator>
#include <map>
#include <new>
#include <string>
#include <ctype.h>
#include <time.h>
#include <math.h>
#include <sstream>   
#include <stdarg.h>
#include <stdexcept>

#include <set>
#include <vector>
#include <deque>
#include <pthread.h>

#include <gcrypt.h> /* for |gcry_control| */
#include <gnutls/gnutls.h>

#if HAVE_CONFIG_H
#include "config.h"
#endif

#if IS_ROCKS_GOEGRID
#undef HAVE_LIBMYSQLCLIENT
#endif 

#if HAVE_LIBMYSQLCLIENT
#include <mysql.h>
#endif 

@ \filename{parser.h++} must be included because
\filename{scanner.h++} requires declarations that are in the former file.
\initials{LDF 2008.07.08.}

@<Include files@>=

#include "entries.h++"
#include "dstngnmt.h++"
#include "glblvrbl.h++"  
#include "glblfncs.h++"
#include "parser.h++"  
#include "scanner.h++"
#include "rspnstp.h++"
#include "glsinftp.h++"
#include "scprpmtp.h++"
#include "entries.h++"
#include "prsrfncs.h++"
#include "utilfncs.h++"

@q ** (2) Declarations of additional functions.@>
@ Declarations of additional functions.

@<Declarations of additional functions@>=

int 
yylex(YYSTYPE* lvalp, yyscan_t parameter);

int
yywrap(void);

int
yyerror(void* v, char const* s);

@q ** (2) Options.@>
@ Options.

@<Options@>=
@=%verbose@>@;@/
@=%pure-parser@>@;@/
@=%parse-param {yyscan_t parameter}@>@;@/
@=%lex-param {yyscan_t parameter}@>@;@/
@=%debug@>
@=%expect 3@>

@q ** (2) |union| declaration.@>
@ {\bf union} declaration.

@<|union| declaration@>=

@=%union {@>
 
  int int_value;
  unsigned int uint_value;
  float float_value;
  char string_value[256];

@=}@>

@q ** (2) Token and type declarations.@>
@ Token and type declarations.

@q *** (3) Punctuation.  @>
@ Punctuation.

\LOG
\initials{LDF 2011.12.25.}
Added token declaration for |SLASH_YY|.
\ENDLOG

@<Token and type declarations@>=

@=%token<int_value> HYPHEN_YY@>@;@/
@=%token<int_value> COLON_YY@>@;@/            
@=%token<int_value> SEMI_COLON_YY@>@;@/      
@=%token<int_value> SLASH_YY@>@;@/      
@=%token<int_value> EXCLAMATION_POINT_YY@>@;@/      

@q *** (3) Syntactic Sugar.  @>
@ Syntactic Sugar.
\initials{LDF 2010.01.15.}

\LOG
\initials{LDF 2010.01.15.}
Added this section with the token declaration for |FOR_YY|.

\initials{LDF 2010.09.30.}
Added the token declaration for |TO_YY|.

\initials{LDF 2011.10.27.}
Added the token declaration for |NOT_YY|.

\initials{LDF 2011.11.04.}
Added the token declaration for |ERROR_YY|.

\initials{LDF 2012.02.03.}
Added the token declaration for |NO_YY|.
\ENDLOG

@<Token and type declarations@>=

@=%token<int_value> FOR_YY@>@;@/       
@=%token<int_value> TO_YY@>@;@/       
@=%token<int_value> NOT_YY@>
@=%token<int_value> ERROR_YY@>
@=%token<int_value> NO_YY@>

@q *** (3) Start conditions for the scanner.  @>
@ Start conditions for the scanner.
\initials{LDF Undated.}

@<Token and type declarations@>=

@q *** (3) @>
@ Control.

\LOG
\initials{LDF 2010.01.15.}
Added the token declaration for |ENTRY_YY|.

\initials{LDF 2010.09.03.}
Added the token declaration for |DELETE_YY|.

\initials{LDF 2011.12.16.}
Added the token declarations for |FROM_YY| and |DATABASE_YY|.

\initials{LDF 2012.01.12.}
Added token declarations for |FINALLY_YY|,
|MARK_YY|, |AS_YY|, |DELETED_YY| and |UNDELETE_YY|.

\initials{LDF 2012.04.12.}
Added token declaration for |REPLACE_YY|.

\initials{LDF 2012.05.03.}
Added token declaration for |EDIT_YY|.
\ENDLOG 

@<Token and type declarations@>=

@=%token<int_value> ADD_YY@>   
@=%token<int_value> DELETE_YY@>   
@=%token<int_value> DELETED_YY@>   
@=%token<int_value> UNDELETE_YY@>   

@=%token<int_value> EDIT_YY@>   

@=%token<int_value> REPLACE_YY@>   

@=%token<int_value> ENTRY_YY@>   
@=%token<int_value> START_ENTRY_YY@>   
@=%token<int_value> END_ENTRY_YY@>   
@=%token<int_value> END_YY@>   

@=%token<int_value> RECEIVE_YY@>   
@=%token<int_value> FILE_YY@>   
@=%token<int_value> SUCCEEDED_YY@>   
@=%token<int_value> FAILED_YY@>   

@=%token<int_value> MARK_YY@>   
@=%token<int_value> AS_YY@>   

@=%token<int_value> FINALLY_YY@>   

@=%token<string_value> STRING_YY@>@;@/   

@ 
\LOG
\initials{LDF 2010.01.15.}
Added the token declaration for |FETCH_YY|.

\initials{LDF 2010.03.04.}
Added the token declaration for |PREREQUISITES_YY|.

\initials{LDF 2010.03.05.}
Added the token declaration for |ORDER_YY|.

\initials{LDF 2010.03.19.}
Added the token declaration for |ENVIRONMENT_YY|.

\initials{LDF 2010.03.26.}
Added the token declaration for |DOWNLOAD_COMMAND_YY|.

\initials{LDF 2010.03.26.}
Added the token declaration for |DOWNLOAD_INFO_YY|.

\initials{LDF 2010.05.21.}
Added token declarations for |SHOW_YY|, |ALL_YY|, |ENTRIES_YY|,
|AND_YY|, |PUBLIC_YY| and |USER_YY|.

\initials{LDF 2010.05.25.}
Added token declarations for |SET_YY|, |PRIVATE_YY| and |PUBLIC_YY|.

\initials{LDF 2010.05.26.}
Added the token declaration for |INFO_YY|.

\initials{LDF 2010.06.30.}
Added the token declaration for |EFFECTIVE_USER_YY|.

\initials{LDF 2010.09.08.}
Added token declaration for |WITH_YY|.

\initials{LDF 2010.09.23.}
Added token declaration for |HTML_YY|.

\initials{LDF 2010.10.15.}
Removed token declaration for |WITH_YY|.  Added token declarations for 
|WITH_PREREQUISITES_YY| and |WITH_INSTALLATION_SCRIPT_YY|.

\initials{LDF 2010.10.27.}
Added token declarations for |CERTIFICATE_YY| and |CERTIFICATES_YY|.

\initials{LDF 2011.01.26.}
Added token declaration for |ENCRYPTED_YY|.

\initials{LDF 2011.01.27.}
Added token declaration for |OWNER_YY|.

\initials{LDF 2011.04.20.}
Added token declarations for |INSTALLATION_SCRIPT_ENCRYPTED_YY|, 
|DOWNLOAD_URL_ENCRYPTED_YY| and |DOWNLOAD_COMMAND_ENCRYPTED_YY|.

\initials{LDF 2011.05.06.}
Added token declaration for |AUTHORIZATION_YY|.

\initials{LDF 2011.09.26.}
Added token declarations for |TRANSFER_YY| and |PROXY_CERTIFICATE_YY|.

\initials{LDF 2011.10.23.}
Added token declaration for |TIMEOUT_YY|.

\initials{LDF 2011.10.27.}
Added token declaration for |INVALID_YY|. 

\initials{LDF 2011.11.03.}
Added token declarations for |SECRET_KEY_YY|, |PUBLIC_KEY_YY| and |KEY_PAIR_YY|.

\initials{LDF 2011.11.14.}
Added the token declaration for |GET_YY|.

\initials{LDF 2011.11.17.}
Added the token declaration for |DISTRIBUTE_YY|.

\initials{LDF 2011.11.17.}
Added the token declaration for |GLOBUS_SITES_YY|.
The token declaration for |GLOBUS_SITE_YY| (singular) was added previously.

\initials{LDF 2011.12.19.}
Added token declaration for |JAVASCRIPT_YY|.

\initials{LDF 2011.12.22.}
Added token declaration for |SESSION_ID_YY|.

\initials{LDF 2011.12.25.}
Added token declarations for |LEVEL_YY| and |LEVELS_YY|.

\initials{LDF 2012.02.07.}
Added token declarations for |NO_LINKS_YY|, |WITH_LINKS_YY| 
and |LINK_DIRECTORY_YY|.

\initials{LDF 2012.03.16.}
Added the token declarations for |SEND_YY| and |HOST_YY|.

\initials{LDF 2012.03.19.}
Added the token declaration for |SHELLSCRIPT_YY|.

\initials{LDF 2012.03.21.}
Added the token declaration for |SHELLSCRIPTS_YY|.

\initials{LDF 2012.03.22.}
Added the token declaration for |ADMIN_YY|

\initials{LDF 2012.03.26.}
Added the token declarations for |ENABLE_YY|, |ENABLED_YY|, 
|DISABLE_YY| and  |DISABLED_YY|.

\initials{LDF 2012.04.12.}
Added the token declarations for |INTERACTIVE_NODE_YY|,
|INTERACTIVE_NODE_YY|,
|APPEND_LD_LIBRARY_PATH_YY|,
|APPEND_PATH_YY|, |OPTDBCLI_PATH_YY|,
|IP_ADDRESS_YY| and |INTERACTIVE_NODE_IP_ADDRESS_YY|.

\initials{LDF 2012.05.03.}
Added token declaration for |UNSET_YY|.

\initials{LDF 2012.05.07.}
Added token declaration for |PRIVILEGES_YY|.

\initials{LDF 2012.05.15.}
Changed |PROXY_CERTIFICATE_YY| to |PROXY_CREDENTIAL_YY|.

\initials{LDF 2012.05.21.}
Added token declaration for |WITH_DEPENDENTS_YY|.
\ENDLOG

@<Token and type declarations@>=

@=%token<int_value> PACKAGE_NAME_YY@>   
@=%token<int_value> PACKAGE_VERSION_YY@>   
@=%token<int_value> DOWNLOAD_INFO_YY@>   
@=%token<int_value> DOWNLOAD_URL_YY@>   
@=%token<int_value> DOWNLOAD_URL_ENCRYPTED_YY@>   

@=%token<int_value> DOWNLOAD_COMMAND_YY@>   
@=%token<int_value> DOWNLOAD_COMMAND_ENCRYPTED_YY@>   
@=%token<int_value> PREREQUISITE_YY@>   
@=%token<int_value> PREREQUISITES_YY@>   
@=%token<int_value> ORDER_YY@>   
@=%token<int_value> INSTALLATION_SCRIPT_YY@>   
@=%token<int_value> INSTALLATION_SCRIPT_ENCRYPTED_YY@>   

@=%token<int_value> AUTHORIZATION_YY@>   

@=%token<string_value> CLIENT_FINISHED_YY@>@;@/   
@=%token<int_value> CLIENT_YY@>   
@=%token<int_value> SENDING_YY@>   

@=%token<int_value> FETCH_YY@>   
@=%token<int_value> GET_YY@>   

@=%token<int_value> EXTRACT_YY@>   
@=%token<int_value> VALIDATE_YY@>   
@=%token<int_value> DISTINGUISHED_NAME_YY@>   
@=%token<int_value> ENVIRONMENT_YY@>   
@=%token<int_value> SHELLSCRIPT_YY@>   
@=%token<int_value> SHELLSCRIPTS_YY@> 
@=%token<int_value> ADMIN_YY@>

@=%token<int_value> ENABLE_YY@>
@=%token<int_value> ENABLED_YY@>
@=%token<int_value> DISABLE_YY@> 
@=%token<int_value> DISABLED_YY@>

@=%token<int_value> SHOW_YY@>
@=%token<int_value> ALL_YY@>
@=%token<int_value> ENTRIES_YY@>
@=%token<int_value> AND_YY@>
@=%token<int_value> USER_YY@>
@=%token<int_value> SET_YY@>
@=%token<int_value> UNSET_YY@>
@=%token<int_value> PUBLIC_YY@>
@=%token<int_value> PRIVATE_YY@>
@=%token<int_value> WITH_PREREQUISITES_YY@>
@=%token<int_value> WITH_DEPENDENTS_YY@>
@=%token<int_value> WITH_INSTALLATION_SCRIPT_YY@>
@=%token<int_value> HTML_YY@>
@=%token<int_value> JAVASCRIPT_YY@>

@=%token<int_value> LEVEL_YY@>
@=%token<int_value> LEVELS_YY@>

@=%token<int_value> INFO_YY@>

@=%token<int_value> EFFECTIVE_USER_YY@>

@=%token<int_value> CERTIFICATE_YY@>
@=%token<int_value> CERTIFICATES_YY@>

@=%token<int_value> PRIVILEGES_YY@>

@=%token<int_value> ENCRYPTED_YY@>
@=%token<int_value> OWNER_YY@>

@=%token<int_value> TRANSFER_YY@>
@=%token<int_value> PROXY_CREDENTIAL_YY@>
@=%token<int_value> INVALID_YY@>

@=%token<int_value> SEND_YY@>

@=%token<int_value> INSTALL_YY@>
@=%token<int_value> REINSTALL_YY@>
@=%token<int_value> GLOBUS_SITE_YY@>
@=%token<int_value> HOST_YY@>
@=%token<int_value> GLOBUS_SITES_YY@>
@=%token<int_value> STDOUT_FILENAME_YY@>
@=%token<int_value> STDERR_FILENAME_YY@>
@=%token<int_value> TIMEOUT_YY@>

@=%token<int_value> INTERACTIVE_NODE_YY@>
@=%token<int_value> APPEND_LD_LIBRARY_PATH_YY@>
@=%token<int_value> APPEND_PATH_YY@>
@=%token<int_value> OPTDBCLI_PATH_YY@>
@=%token<int_value> IP_ADDRESS_YY@>
@=%token<int_value> INTERACTIVE_NODE_IP_ADDRESS_YY@>

@=%token<int_value> NO_LINKS_YY@>
@=%token<int_value> WITH_LINKS_YY@>
@=%token<int_value> LINK_DIRECTORY_YY@>

@=%token<int_value> SECRET_KEY_YY@>@;@/
@=%token<int_value> PUBLIC_KEY_YY@>@;@/
@=%token<int_value> KEY_PAIR_YY@>@;@/
@=%token<int_value> DISTRIBUTE_YY@>@;@/

@=%token<int_value> FROM_YY@>@;@/
@=%token<int_value> DATABASE_YY@>@;@/

@=%token<int_value> SESSION_ID_YY@>@;@/

@q **** (4) Tokens for start conditions.  @>
@ Tokens for start conditions.  
\initials{LDF Date unknown.}

@<Token and type declarations@>=      

@q *** (3) Numbers.  @>
@ Numbers.    

@<Token and type declarations@>=      

@=%token<int_value> INTEGER_YY@>@;@/      
@=%token<uint_value> UNSIGNED_INTEGER_YY@>@;@/      
@=%token<float_value> FLOAT_YY@>@;@/      

@q ** (2) Rules.  @>
@ Rules.

@<Rules@>=

@q *** (3) Program.  @>
@ Program.

@<Rules@>=

@=program: statement_list END_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
       lock_cerr_mutex();
       cerr << "[Thread " << param->thread_ctr
            << "] In `yyparse':  `program: statement_list END_YY'.  Ending." 
            << endl;
       unlock_cerr_mutex();
    }

#if 0 
    else
    {
       lock_cerr_mutex(); 
       cerr << "[Thread " << param->thread_ctr
            << "] In `yyparse':  `program: statement_list END_YY':"
            << endl 
            << "Number of entries:  " << param->entries.size() 
            << endl;
       unlock_cerr_mutex(); 

        for(vector<Entry_Type>::iterator iter = param->entries.begin();
           iter != param->entries.end();
           ++iter)
       
          iter->show("", param);

    }
#endif       

    return 0;

};

@q *** (3) statement_list.  @>
@ \<statement list>.
\initials{LDF 2008.08.18.}

\LOG
\initials{LDF 2008.08.18.}
Added this section.
\ENDLOG  

@q **** (4) statement_list --> EMPTY.  @>

@ \<statement list> $\longrightarrow$ \.{EMPTY}.  
This rule ensures that an empty file won't cause an error.
\initials{LDF 2008.07.07.}

@<Rules@>=

@=statement_list: /* Empty  */  @>
{

    if (static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter))->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " 
             << static_cast<Scan_Parse_Parameter_Type*>(
                   yyget_extra(parameter))->thread_ctr 
             << "] In `yyparse':  `statement_list: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex();
    }
};

@q **** (4) statement_list --> statement_list statement.  @>

@ \<statement list> $\longrightarrow$ \<statement>.
\initials{LDF 2009.10.05.}

@<Rules@>=

@=statement_list: statement_list statement @>
{

    if (static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter))->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " 
             << static_cast<Scan_Parse_Parameter_Type*>(
                   yyget_extra(parameter))->thread_ctr 
             << "] In `yyparse':  `statement_list:  statement'." 
             << endl;
        unlock_cerr_mutex();
    }
};

@q *** (3) Statement.  @>
@ Statement.
\initials{LDF 2009.10.05.}

@q **** (4) statement --> START_ENTRY_YY entry_statement_list END_ENTRY_YY @>

@ \<statement> $\longrightarrow$ \.{START\_ENTRY\_YY} \<entry statement list> 
\.{END\_ENTRY\_YY}.
\initials{LDF 2009.10.05.}

@<Rules@>=

@=statement: START_ENTRY_YY entry_statement_list END_ENTRY_YY @>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement: START_ENTRY_YY entry_statement_list END_ENTRY_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if 0 
    if (param->entries.size() ==  0)
    {
        lock_cerr_mutex();
        cerr << get_datestamp() << " [Thread " << param->thread_ctr 
             << "] WARNING!  In `yyparse':  "
             << "`statement: START_ENTRY_YY entry_statement_list END_ENTRY_YY':"
             << endl
             << "Failed to create entry.  Will try to continue."
             << endl;
        unlock_cerr_mutex(); 
    }
    else
    {
       lock_cerr_mutex(); 
       param->entries.back().show("", param);
       unlock_cerr_mutex(); 

    }
#endif 

};

@q **** (4) @>
@
@<Rules@>=

@=entry_statement_list: /* Empty  */  @>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `entry_statement_list: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex();
    }

    Entry_Type e;

    param->entries.push_back(e);

};

@q **** (4) @>
@
@<Rules@>=

@=entry_statement_list: entry_statement_list keyword_value_pair  @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `entry_statement_list: entry_statement_list "
             << "keyword_value_pair'." 
             << endl;
        unlock_cerr_mutex();
    }

};

@q **** (4) @>
@
@<Rules@>=

@=entry_statement_list: entry_statement_list prerequisite_statement  @>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `entry_statement_list: prerequisite_statement."
             << endl;
        unlock_cerr_mutex();
    }

};

@q **** (4) entry_statement_list: entry_statement_list PRIVATE_YY  @>

@ \<entry statement list> $\longrightarrow$ \<entry statement list> 
\.{PRIVATE\_YY}.
\initials{LDF 2010.05.25.}

\LOG
\initials{LDF 2010.05.25.}
Added this rule.
\ENDLOG 

@<Rules@>=

@=entry_statement_list: entry_statement_list PRIVATE_YY  @>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `entry_statement_list: entry_statement_list PRIVATE_YY."
             << endl;
        unlock_cerr_mutex();
    }

    param->entries.back().private_flag = true;

};

@q **** (4) entry_statement_list: entry_statement_list PUBLIC_YY  @>

@ \<entry statement list> $\longrightarrow$ \<entry statement list> 
\.{PUBLIC\_YY}.
\initials{LDF 2010.05.25.}

\LOG
\initials{LDF 2010.05.25.}
Added this rule.
\ENDLOG 

@<Rules@>=

@=entry_statement_list: entry_statement_list PUBLIC_YY  @>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `entry_statement_list: entry_statement_list PUBLIC_YY."
             << endl;
        unlock_cerr_mutex();
    }

    param->entries.back().private_flag = false;

};

@q **** (4) @>
@
@<Rules@>=

@=keyword_value_pair: PACKAGE_NAME_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `keyword_value_pair: PACKAGE_NAME_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex();
    }

    param->entries.back().package_name = @=$2@>;

};

@q **** (4) @>
@
\LOG
\initials{LDF 2011.11.29.}
Now testing length of \.{STRING\_YY} before setting 
|param->entries.back().package_version|.  If it's 0, not setting.
\ENDLOG 

@<Rules@>=

@=keyword_value_pair: PACKAGE_VERSION_YY STRING_YY @>
{
 
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `keyword_value_pair: PACKAGE_VERSION_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex();
    }
    if (strlen(@=$2@>))
       param->entries.back().package_version = @=$2@>;

};

@q **** (4) @>
@
\LOG
\initials{LDF 2010.05.25.}
Added this rule.
\ENDLOG

@<Rules@>=

@=keyword_value_pair: PACKAGE_VERSION_YY INTEGER_YY @>
{
 
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `keyword_value_pair: PACKAGE_VERSION_YY INTEGER_YY'." 
             << endl;
        unlock_cerr_mutex();
    }

    stringstream s;

    s << @=$2@>; 

    param->entries.back().package_version = s.str();

};

@q **** (4) keyword_value_pair: DOWNLOAD_URL_YY STRING_YY  @>
@ \<keyword value pair> $\longrightarrow$ \.{DOWNLOAD\_URL\_YY} \.{ STRING\_YY}.
\initials{LDF Date unknown.}

\LOG
\initials{LDF Date unknown.}
Added this rule.
\ENDLOG

@<Rules@>=

@=keyword_value_pair: DOWNLOAD_URL_YY STRING_YY @>
{
    
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `keyword_value_pair: DOWNLOAD_URL_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex();
    }

    param->entries.back().download_url = @=$2@>;   

};

@q **** (4) keyword_value_pair: DOWNLOAD_URL_ENCRYPTED_YY STRING_YY  @>
@ \<keyword value pair> $\longrightarrow$ \.{DOWNLOAD\_URL\_ENCRYPTED\_YY} 
\.{ STRING\_YY}.
\initials{LDF 2011.04.20.}

\LOG
\initials{LDF 2011.04.20.}
Added this rule.

\initials{LDF 2011.05.04.}
Now setting |param->entries.back().private_flag = true|.  That is, if an entry is 
encrypted, this implies that it's private, too.
\ENDLOG

@<Rules@>=

@=keyword_value_pair: DOWNLOAD_URL_ENCRYPTED_YY STRING_YY @>
{
    
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `keyword_value_pair: DOWNLOAD_URL_ENCRYPTED_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex();
    }

    param->entries.back().download_url_encrypted = @=$2@>;   
    param->entries.back().encrypted_flag = true;
    param->entries.back().private_flag = true;

};

@q **** (4) keyword_value_pair: DOWNLOAD_COMMAND_YY STRING_YY  @>
@ \<keyword value pair> $\longrightarrow$ \.{DOWNLOAD\_COMMAND\_YY} \.{ STRING\_YY}.
\initials{LDF Date unknown.}

\LOG
\initials{LDF Date unknown.}
Added this rule.
\ENDLOG

@<Rules@>=

@=keyword_value_pair: DOWNLOAD_COMMAND_YY STRING_YY @>
{
    
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `keyword_value_pair: DOWNLOAD_COMMAND_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex();
    }

    param->entries.back().download_command = @=$2@>;   

};

@q **** (4) keyword_value_pair: DOWNLOAD_COMMAND_ENCRYPTED_YY STRING_YY  @>
@ \<keyword value pair> $\longrightarrow$ \.{DOWNLOAD\_COMMAND\_ENCRYPTED\_YY} 
\.{ STRING\_YY}.
\initials{LDF 2011.04.20.}

\LOG
\initials{LDF 2011.04.20.}
Added this rule.

\initials{LDF 2011.05.04.}
Now setting |param->entries.back().private_flag = true|.  That is, if an entry is 
encrypted, this implies that it's private, too.
\ENDLOG

@<Rules@>=

@=keyword_value_pair: DOWNLOAD_COMMAND_ENCRYPTED_YY STRING_YY @>
{
    
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `keyword_value_pair: DOWNLOAD_COMMAND_ENCRYPTED_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex();
    }

    param->entries.back().download_command_encrypted = @=$2@>;   
    param->entries.back().encrypted_flag = true;
    param->entries.back().private_flag = true;

};

@q **** (4) keyword_value_pair: INSTALLATION_SCRIPT_YY STRING_YY  @>

@ \<keyword value pair> $\longrightarrow$ \.{INSTALLATION\_SCRIPT\_YY} 
\.{STRING\_YY}.

\LOG
\initials{LDF 2011.04.20.}
Added this rule.
\ENDLOG

@<Rules@>=

@=keyword_value_pair: INSTALLATION_SCRIPT_YY STRING_YY @>
{
    
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `keyword_value_pair: INSTALLATION_SCRIPT_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex();
    }

    param->entries.back().installation_script = @=$2@>;   

};

@q **** (4) keyword_value_pair: INSTALLATION_SCRIPT_ENCRYPTED_YY STRING_YY  @>

@ \<keyword value pair> $\longrightarrow$ \.{INSTALLATION\_SCRIPT\_ENCRYPTED\_YY} 
\.{STRING\_YY}.

\LOG
\initials{LDF 2011.04.20.}
Added this rule.

\initials{LDF 2011.05.04.}
Now setting |param->entries.back().private_flag = true|.  That is, if an entry is 
encrypted, this implies that it's private, too.
\ENDLOG

@<Rules@>=

@=keyword_value_pair: INSTALLATION_SCRIPT_ENCRYPTED_YY STRING_YY @>
{
    
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `keyword_value_pair: INSTALLATION_SCRIPT_ENCRYPTED_YY "
             << "STRING_YY'." 
             << endl;
        unlock_cerr_mutex();
    }

    param->entries.back().installation_script_encrypted = @=$2@>;   
    param->entries.back().encrypted_flag = true;
    param->entries.back().private_flag = true;

};

@q **** (4) @>
@
@<Rules@>=

@=keyword_value_pair: OWNER_YY STRING_YY @>
{
    
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `keyword_value_pair: OWNER_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex();
    }

    param->entries.back().owner = @=$2@>;   

};

@q **** (4) keyword_value_pair: AUTHORIZATION_YY STRING_YY  @>
@ \<keyword value pair> $\longrightarrow$ \.{AUTHORIZATION\_YY} 
\.{ STRING\_YY}.
\initials{LDF 2011.05.06.}

\LOG
\initials{LDF 2011.05.06.}
Added this rule.
\ENDLOG

@<Rules@>=

@=keyword_value_pair: AUTHORIZATION_YY STRING_YY @>
{
    
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `keyword_value_pair: AUTHORIZATION_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex();
    }

    param->entries.back().authorization  = @=$2@>;   
    param->entries.back().encrypted_flag = true;
    param->entries.back().private_flag   = true;

};

@q *** (3) Prerequisite statements.  @>
@ Prerequisite statements.  
\initials{LDF 2009.10.07.}

\LOG
\initials{LDF 2009.10.07.}
Added this section.
\ENDLOG

@q **** (4) prerequisite_statement: PREREQUISITE_YY STRING_YY  @>
@ \<prerequisite statement> $\longrightarrow$: \.{PREREQUISITE\_YY} \.{STRING\_YY}.
@<Rules@>=

@=prerequisite_statement: PREREQUISITE_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `prerequisite_statement: PREREQUISITE_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex();
    }

    Entry_Type e(@=$2@>);

    param->entries.back().prerequisites.push_back(e);
    

};

@q **** (4) prerequisite_statement: PREREQUISITE_YY STRING_YY STRING_YY  @>
@ \<prerequisite statement> $\longrightarrow$: \.{PREREQUISITE\_YY} \.{STRING\_YY} \.{STRING\_YY}.
@<Rules@>=

@=prerequisite_statement: PREREQUISITE_YY STRING_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `prerequisite_statement: PREREQUISITE_YY STRING_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex();
    }

    Entry_Type e(@=$2@>, @=$3@>);

    param->entries.back().prerequisites.push_back(e);

};

@q **** (4) statement --> CLIENT_YY SENDING_YY installation_script  @>
@q **** (4) STRING_YY INTEGER_YY INTEGER_YY.                        @>
@q **** (4) entry_string_list                                       @>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{SENDING\_YY} 
\<installation script> \.{STRING\_YY} \.{INTEGER\_YY} \.{INTEGER\_YY} 
\<entry string list>.
\initials{LDF 2010.01.12.}

\LOG
\initials{LDF 2010.01.12.}
Added this rule.

\initials{LDF 2010.03.10.}
Added |STRING_YY| for the |entry_name|.

\initials{LDF 2011.04.21.}
Replaced the two final \.{STRING} tokens with \<entry string list>.
Changed \.{INSTALLATION\_SCRIPT\_YY} to \<installation script>.
\ENDLOG

@<Rules@>=

@=statement: CLIENT_YY SENDING_YY installation_script STRING_YY INTEGER_YY INTEGER_YY @>@/
@=entry_string_list@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;       

    response.entry_id = @=$5@>;  /* Not needed at present.
                                    \initials{LDF 2010.01.22.}  */

    stringstream temp_strm;
  
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "CLIENT_YY SENDING_YY installation_script STRING_YY "
             << "INTEGER_YY INTEGER_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */

@q ***** (5) @>

    if (param->entry_string_vector.size() == 0)
    {
        lock_cerr_mutex();
        cerr << get_datestamp() << " [Thread " << param->thread_ctr 
             << "] WARNING!  In `yyparse':  "
             << "Rule `statement: CLIENT_YY SENDING_YY installation_script "
             << "STRING_YY INTEGER_YY INTEGER_YY STRING_YY':"
             << endl
             << "No package name.  Can't receive installation script."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex();

        temp_strm << "RECEIVE INSTALLATION_SCRIPT FAILED FOR ENTRY \"" 
                  << response.entry_name << "\"";

        if (!response.version.empty())
           temp_strm << " \"" << response.version << "\"";

     
        response.command = temp_strm.str();
        
    }
@q ***** (5) @>

    else  /* |param->entry_string_vector.size() > 0|  */
    {
@q ****** (6) @>

       response.entry_name = param->entry_string_vector[0];

       if (param->entry_string_vector.size() > 1)
          response.version = param->entry_string_vector[1];
       else 
          response.version = "";

       param->entry_string_vector.clear();

@q ****** (6) @>

       if (param->PARSER_DEBUG)
       {
           lock_cerr_mutex();
           cerr << "[Thread " << param->thread_ctr 
                << "] In `yyparse':  Rule `statement:  "
                << "CLIENT_YY SENDING_YY installation_script STRING_YY "
                << "INTEGER_YY INTEGER_YY entry_string_list':"
                << endl
                << "`STRING_YY' ($4) == " << @=$4@>
                << endl 
                << "`entry_id' ($5) == " << @=$5@>
                << endl 
                << "`file_type' ($6) == " << @=$6@>
                << endl  
                << "`entry_name' == " << response.entry_name
                << endl 
                << "`version' == " << response.version
                << endl  
                << "Calling `accept_data'."
                << endl;
           unlock_cerr_mutex();

       }  /* |if (param->PARSER_DEBUG)| */

@q ****** (6) @>

       int status = accept_data(param, @=$4@>, @=$5@>, @=$6@>);

       if (status == 0)
       {
           if (param->PARSER_DEBUG)
           {
               lock_cerr_mutex();
               cerr << "[Thread " << param->thread_ctr 
                    << "] In `yyparse':  Rule `statement:  "
                    << "CLIENT_YY SENDING_YY installation_script STRING_YY "
                    << "INTEGER_YY INTEGER_YY entry_string_list':"
                    << endl
                    << "`accept_data' succeeded, returning 0."
                    << endl;
               unlock_cerr_mutex();

           }  /* |if (param->PARSER_DEBUG)| */

           temp_strm << "RECEIVE INSTALLATION_SCRIPT SUCCEEDED FOR ENTRY \"" 
                     << response.entry_name << "\"";

           if (!response.version.empty())
              temp_strm << " \"" << response.version << "\"";

         
           response.command = temp_strm.str();

       }  /* |if (status == 0)| */

       else /* |status != 0|  */
       {
           lock_cerr_mutex();
           cerr << get_datestamp() << " [Thread " << param->thread_ctr 
                << "] WARNING!  In `yyparse':  "
                << "Rule `statement: CLIENT_YY SENDING_YY installation_script "
                << "STRING_YY INTEGER_YY INTEGER_YY STRING_YY':"
                << endl
                << "`accept_data' failed, returning " << status
                << endl
                << "Will try to continue."
                << endl;
           unlock_cerr_mutex();

           temp_strm << "RECEIVE INSTALLATION_SCRIPT FAILED FOR ENTRY \"" 
                     << response.entry_name << "\"";

           if (!response.version.empty())
              temp_strm << " \"" << response.version << "\"";

         
           response.command = temp_strm.str();

       }  /* |if (status != 0)| */

@q ****** (6) @>

    } /* |else| (|param->entry_string_vector.size() > 0|)  */

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);
 
@q ***** (5) @>

};

@q **** (4) statement --> CLIENT_YY SENDING_YY download_info_encrypted    @>
@q **** (4) STRING_YY INTEGER_YY INTEGER_YY.                              @>
@q **** (4) entry_string_list                                             @>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{SENDING\_YY} 
\<download info encrypted> \.{STRING\_YY} \.{INTEGER\_YY} 
\.{INTEGER\_YY} \<entry string list>.
\initials{LDF 2011.04.21.}

\LOG
\initials{LDF 2011.04.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: CLIENT_YY SENDING_YY download_info_encrypted STRING_YY @>@/
@=INTEGER_YY INTEGER_YY entry_string_list@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;       

    response.entry_id = @=$5@>;  /* Not needed at present.
                                    \initials{LDF 2010.01.22.}  */

    stringstream temp_strm;
  
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "CLIENT_YY SENDING_YY download_info_encrypted STRING_YY "
             << "INTEGER_YY INTEGER_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */

    int command_or_url;

    if (@=$3@> == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE)
         command_or_url = 0;
    else 
      command_or_url = 1;

@q ***** (5) @>

    if (param->entry_string_vector.size() == 0)
    {
        lock_cerr_mutex();
        cerr << get_datestamp() << " [Thread " << param->thread_ctr 
             << "] WARNING!  In `yyparse':  "
             << "Rule `statement: CLIENT_YY SENDING_YY download_info_encrypted "
             << "STRING_YY INTEGER_YY INTEGER_YY STRING_YY':"
             << endl
             << "No package name.  Can't receive download ";

        if (command_or_url == 1)
           cerr << "command.";
        else 
           cerr << "URL.";

        cerr << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex();

        temp_strm << "RECEIVE DOWNLOAD_";

        if (command_or_url == 1)
           temp_strm << "COMMAND_";
        else 
           temp_strm << "URL_";
        
        temp_strm << "ENCRYPTED FAILED FOR ENTRY \"" 
                  << response.entry_name << "\"";

        if (!response.version.empty())
           temp_strm << " \"" << response.version << "\"";

     
        response.command = temp_strm.str();
        
    }
@q ***** (5) @>

    else  /* |param->entry_string_vector.size() > 0|  */
    {
@q ****** (6) @>

       response.entry_name = param->entry_string_vector[0];

       if (param->entry_string_vector.size() > 1)
          response.version = param->entry_string_vector[1];
       else 
          response.version = "";

       param->entry_string_vector.clear();

@q ****** (6) @>

       if (param->PARSER_DEBUG)
       {
           lock_cerr_mutex();
           cerr << "[Thread " << param->thread_ctr 
                << "] In `yyparse':  Rule `statement:  "
                << "CLIENT_YY SENDING_YY download_info_encrypted STRING_YY "
                << "INTEGER_YY INTEGER_YY entry_string_list':"
                << endl
                << "`STRING_YY' ($4) == " << @=$4@>
                << endl 
                << "`entry_id' ($5) == " << @=$5@>
                << endl 
                << "`file_type' ($6) == " << @=$6@>
                << endl  
                << "`entry_name' == " << response.entry_name
                << endl 
                << "`version' == " << response.version
                << endl  
                << "Calling `accept_data'."
                << endl;
           unlock_cerr_mutex();

       }  /* |if (param->PARSER_DEBUG)| */

@q ****** (6) @>

       int status = accept_data(param, @=$4@>, @=$5@>, @=$6@>);

       if (status == 0)
       {
           if (param->PARSER_DEBUG)
           {
               lock_cerr_mutex();
               cerr << "[Thread " << param->thread_ctr 
                    << "] In `yyparse':  Rule `statement:  "
                    << "CLIENT_YY SENDING_YY download_info_encrypted STRING_YY "
                    << "INTEGER_YY INTEGER_YY entry_string_list':"
                    << endl
                    << "`accept_data' succeeded, returning 0."
                    << endl;
               unlock_cerr_mutex();

           }  /* |if (param->PARSER_DEBUG)| */

           temp_strm << "RECEIVE DOWNLOAD_";

           if (command_or_url == 1)
              temp_strm << "COMMAND_";
           else 
              temp_strm << "URL_";

           temp_strm << "ENCRYPTED SUCCEEDED FOR ENTRY \"" 
                     << response.entry_name << "\"";

           if (!response.version.empty())
              temp_strm << " \"" << response.version << "\"";

         
           response.command = temp_strm.str();

       }  /* |if (status == 0)| */

       else /* |status != 0|  */
       {
           lock_cerr_mutex();
           cerr << get_datestamp() << " [Thread " << param->thread_ctr 
                << "] WARNING!  In `yyparse':  "
                << "Rule `statement: CLIENT_YY SENDING_YY download_info_encrypted "
                << "STRING_YY INTEGER_YY INTEGER_YY STRING_YY':"
                << endl
                << "`accept_data' failed, returning " << status
                << endl
                << "Will try to continue."
                << endl;
           unlock_cerr_mutex();

           temp_strm << "RECEIVE DOWNLOAD";
 
           if (command_or_url == 1)
              temp_strm << "COMMAND_";
           else 
              temp_strm << "URL_";

           temp_strm << "ENCRYPTED FAILED FOR ENTRY \"" 
                     << response.entry_name << "\"";

           if (!response.version.empty())
              temp_strm << " \"" << response.version << "\"";

         
           response.command = temp_strm.str();

       }  /* |if (status != 0)| */

@q ****** (6) @>

    } /* |else| (|param->entry_string_vector.size() > 0|)  */

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

     
 
@q ***** (5) @>

};

@q **** (4) statement --> CLIENT_YY SENDING_YY AUTHORIZATION_YY  @>
@q **** (4) STRING_YY INTEGER_YY INTEGER_YY.                     @>
@q **** (4) entry_string_list                                    @>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{SENDING\_YY} 
\.{AUTHORIZATION\_YY} \.{STRING\_YY} \.{INTEGER\_YY} 
\.{INTEGER\_YY} \<entry string list>.
\initials{LDF 2011.05.06.}

\LOG
\initials{LDF 2011.05.06.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: CLIENT_YY SENDING_YY AUTHORIZATION_YY STRING_YY @>@/
@=INTEGER_YY INTEGER_YY entry_string_list@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;       

    response.entry_id = @=$5@>;  /* Not needed at present.
                                    \initials{LDF 2010.01.22.}  */

    stringstream temp_strm;
  
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "CLIENT_YY SENDING_YY AUTHORIZATION_YY STRING_YY "
             << "INTEGER_YY INTEGER_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */

@q ***** (5) @>

    if (param->entry_string_vector.size() == 0)
    {
        lock_cerr_mutex();
        cerr << get_datestamp() << " [Thread " << param->thread_ctr 
             << "] WARNING!  In `yyparse':  "
             << "Rule `statement: CLIENT_YY SENDING_YY AUTHORIZATION_YY "
             << "STRING_YY INTEGER_YY INTEGER_YY STRING_YY':"
             << endl
             << "No package name.  Can't receive authorization."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex();

        temp_strm << "RECEIVE AUTHORIZATION FAILED FOR ENTRY \"" 
                  << response.entry_name << "\"";

        if (!response.version.empty())
           temp_strm << " \"" << response.version << "\"";

     
        response.command = temp_strm.str();
        
    }
@q ***** (5) @>

    else  /* |param->entry_string_vector.size() > 0|  */
    {
@q ****** (6) @>

       response.entry_name = param->entry_string_vector[0];

       if (param->entry_string_vector.size() > 1)
          response.version = param->entry_string_vector[1];
       else 
          response.version = "";

       param->entry_string_vector.clear();

@q ****** (6) @>

       if (param->PARSER_DEBUG)
       {
           lock_cerr_mutex();
           cerr << "[Thread " << param->thread_ctr 
                << "] In `yyparse':  Rule `statement:  "
                << "CLIENT_YY SENDING_YY AUTHORIZATION_YY STRING_YY "
                << "INTEGER_YY INTEGER_YY entry_string_list':"
                << endl
                << "`STRING_YY' ($4) == " << @=$4@>
                << endl 
                << "`entry_id' ($5) == " << @=$5@>
                << endl 
                << "`file_type' ($6) == " << @=$6@>
                << endl  
                << "`entry_name' == " << response.entry_name
                << endl 
                << "`version' == " << response.version
                << endl  
                << "Calling `accept_data'."
                << endl;
           unlock_cerr_mutex();

       }  /* |if (param->PARSER_DEBUG)| */

@q ****** (6) @>

       int status = accept_data(param, @=$4@>, @=$5@>, @=$6@>);

       if (status == 0)
       {
           if (param->PARSER_DEBUG)
           {
               lock_cerr_mutex();
               cerr << "[Thread " << param->thread_ctr 
                    << "] In `yyparse':  Rule `statement:  "
                    << "CLIENT_YY SENDING_YY AUTHORIZATION_YY STRING_YY "
                    << "INTEGER_YY INTEGER_YY entry_string_list':"
                    << endl
                    << "`accept_data' succeeded, returning 0."
                    << endl;
               unlock_cerr_mutex();

           }  /* |if (param->PARSER_DEBUG)| */

           temp_strm << "RECEIVE AUTHORIZATION SUCCEEDED FOR ENTRY \"" 
                     << response.entry_name << "\"";

           if (!response.version.empty())
              temp_strm << " \"" << response.version << "\"";

         
           response.command = temp_strm.str();

       }  /* |if (status == 0)| */

       else /* |status != 0|  */
       {
           lock_cerr_mutex();
           cerr << get_datestamp() << " [Thread " << param->thread_ctr 
                << "] WARNING!  In `yyparse':  "
                << "Rule `statement: CLIENT_YY SENDING_YY AUTHORIZATION_YY "
                << "STRING_YY INTEGER_YY INTEGER_YY STRING_YY':"
                << endl
                << "`accept_data' failed, returning " << status
                << endl
                << "Will try to continue."
                << endl;
           unlock_cerr_mutex();

           temp_strm << "RECEIVE AUTHORIZATION FAILED FOR ENTRY \"" 
                     << response.entry_name << "\"";

           if (!response.version.empty())
              temp_strm << " \"" << response.version << "\"";

         
           response.command = temp_strm.str();

       }  /* |if (status != 0)| */

@q ****** (6) @>

    } /* |else| (|param->entry_string_vector.size() > 0|)  */

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

     
 
@q ***** (5) @>

};

@q **** (4) statement --> CLIENT_FINISHED_YY @>

@ \<statement> $\longrightarrow$ \.{CLIENT\_FINISHED\_YY}.
\initials{LDF 2010.01.12.}

\LOG
\initials{LDF 2010.01.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: CLIENT_FINISHED_YY @>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));
   
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement: CLIENT_FINISHED_YY'."
             << endl;
        unlock_cerr_mutex();
    }

    param->client_finished = true;

};

@q **** (4) statement --> FETCH_YY INSTALLATION_SCRIPT_YY FOR_YY ENTRY_YY @>
@q **** (4) entry_string_list ORDER_YY INTEGER_YY                         @>

@ \<statement> $\longrightarrow$ 
\.{FETCH\_YY} \.{INSTALLATION\_SCRIPT\_YY} \.{FOR\_YY} \.{ENTRY\_YY} 
\<entry string list> \.{ORDER\_YY} \.{INTEGER\_YY}.
\initials{LDF 2010.01.19.}

\LOG
\initials{LDF 2010.01.19.}
Added this rule.

\initials{LDF 2010.03.05.}
Added \.{ORDER\_YY} \.{INTEGER\_YY}.

\initials{LDF 2010.09.23.}
Replaced the two \.{STRING\_YY} tokens with \<entry string list> and removed 
the variant rules with one \.{STRING\_YY} token and three \.{STRING\_YY} tokens, 
respectively.
\ENDLOG

@<Rules@>=

@=statement: FETCH_YY INSTALLATION_SCRIPT_YY FOR_YY ENTRY_YY entry_string_list @>@/
@=ORDER_YY INTEGER_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: FETCH_YY INSTALLATION_SCRIPT_YY FOR_YY "
             << "ENTRY_YY entry_string_list ORDER_YY INTEGER_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    Response_Type response;
 
    response.type = Response_Type::FETCH_INSTALLATION_SCRIPT_TYPE;
    response.entry_name   = param->entry_string_vector[0];

    if (param->entry_string_vector.size() > 1)
       response.version = param->entry_string_vector[1];

    if (param->entry_string_vector.size() > 2)
       response.remote_filename = param->entry_string_vector[2];

    response.install_order = @=$7@>;

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

    param->entry_string_vector.clear();

};

@q **** (4) statement --> FETCH_YY DOWNLOAD_INFO_YY FOR_YY ENTRY_YY @>
@q **** (4) entry_string_list ORDER_YY INTEGER_YY                   @>

@ \<statement> $\longrightarrow$ 
\.{FETCH\_YY} \.{DOWNLOAD\_INFO\_YY} \.{FOR\_YY} \.{ENTRY\_YY} 
\<entry string list> \.{ORDER\_YY} \.{INTEGER\_YY}.
\initials{LDF 2010.02.02.}

\LOG
\initials{LDF 2010.02.02.}
Added this rule.

\initials{LDF 2010.03.05.}
Added \.{ORDER\_YY} \.{INTEGER\_YY}.

\initials{LDF 2010.03.26.}
Changed |STRING_YY| to |entry_string_list|.  Removed the variant rule with 
two |STRING_YY| symbols.

\initials{LDF 2010.03.29.}
Changed |DOWNLOAD_URL_YY| to |DOWNLOAD_INFO_YY|.
\ENDLOG

@<Rules@>=

@=statement: FETCH_YY DOWNLOAD_INFO_YY FOR_YY ENTRY_YY entry_string_list @>@/
@=ORDER_YY INTEGER_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement: FETCH_YY "
             << "DOWNLOAD_INFO_YY FOR_YY ENTRY_YY entry_string_list ORDER_YY INTEGER_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */
   
    Response_Type response;
 
    response.type          = Response_Type::FETCH_DOWNLOAD_INFO_TYPE;
    response.entry_name    = param->entry_string_vector[0];

    if (param->entry_string_vector.size() > 1)
       response.version    = param->entry_string_vector[1];

    param->entry_string_vector.clear();

    response.install_order = @=$7@>;

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        response.show("response:");
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

};

@q **** (4) statement --> FETCH_YY AUTHORIZATION_YY FOR_YY ENTRY_YY @>
@q **** (4) entry_string_list ORDER_YY INTEGER_YY                   @>

@ \<statement> $\longrightarrow$ 
\.{FETCH\_YY} \.{AUTHORIZATION\_YY} \.{FOR\_YY} \.{ENTRY\_YY} 
\<entry string list> \.{ORDER\_YY} \.{INTEGER\_YY}.
\initials{LDF 2011.05.06.}

\LOG
\initials{LDF 2011.05.06.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: FETCH_YY AUTHORIZATION_YY FOR_YY ENTRY_YY entry_string_list @>@/
@=ORDER_YY INTEGER_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement: FETCH_YY "
             << "AUTHORIZATION_YY FOR_YY ENTRY_YY entry_string_list ORDER_YY INTEGER_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    Response_Type response;
 
    response.type          = Response_Type::FETCH_AUTHORIZATION_TYPE;
    response.entry_name    = param->entry_string_vector[0];

    if (param->entry_string_vector.size() > 1)
       response.version    = param->entry_string_vector[1];

    param->entry_string_vector.clear();

    response.install_order = @=$7@>;

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

};

@q **** (4) statement --> FETCH_YY PREREQUISITES_YY FOR_YY ENTRY_YY entry_string_list @>

@  \<statement> $\longrightarrow$ 
\.{FETCH\_YY} \.{PREREQUISITES\_YY} \.{FOR\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2010.03.04.}

\LOG
\initials{LDF 2010.03.04.}
Added this rule.

\initials{LDF 2010.03.26.}
Changed |STRING_YY| to |entry_string_list|.  Removed the variant rule with 
two |STRING_YY| symbols.
\ENDLOG

@<Rules@>=

@=statement: FETCH_YY PREREQUISITES_YY FOR_YY ENTRY_YY entry_string_list @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement: FETCH_YY "
             << "PREREQUISITES_YY FOR_YY ENTRY_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    Response_Type response;
 
    response.type    = Response_Type::FETCH_PREREQUISITES_TYPE;
    response.entry_name   = param->entry_string_vector[0];

    if (param->entry_string_vector.size() > 1)
       response.version    = param->entry_string_vector[1];

    param->entry_string_vector.clear();

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

};

@q **** (4) statement --> RECEIVE_YY INSTALLATION_SCRIPT_YY SUCCEEDED_YY @>
@q **** (4) FOR_YY ENTRY_YY entry_string_list                            @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_YY} \.{INSTALLATION\_SCRIPT\_YY} 
\.{SUCCEEDED\_YY}
\.{FOR\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2010.03.08.}

\LOG
\initials{LDF 2010.03.08.}
Added this rule.

\initials{LDF 2010.03.12.}
Added \.{FOR\_YY} \.{ENTRY\_YY} \.{STRING\_YY}.

\initials{LDF 2010.03.26.}
Changed |STRING_YY| to |entry_string_list|.  Removed the variant rule with 
two |STRING_YY| symbols.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY INSTALLATION_SCRIPT_YY SUCCEEDED_YY @>@/
@=FOR_YY ENTRY_YY entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY INSTALLATION_SCRIPT_YY SUCCEEDED_YY "
             << "FOR_YY ENTRY_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

};

@q **** (4) statement --> RECEIVE_YY INSTALLATION_SCRIPT_YY FAILED_YY @>
@q **** (4) FOR_YY ENTRY_YY entry_string_list                         @>
@ \<statement> $\longrightarrow$ \.{RECEIVE\_YY} \.{INSTALLATION\_SCRIPT\_YY} 
\.{FAILED\_YY} \.{FOR\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2010.03.08.}

\LOG
\initials{LDF 2010.03.08.}
Added this rule.

\initials{LDF 2010.03.12.}
Added \.{FOR\_YY} \.{ENTRY\_YY} \.{STRING\_YY}.

\initials{LDF 2010.03.18.}
Changed \.{STRING\_YY} to \<entry string list>.  Removed variant rule with two \.{STRING\_YY} 
symbols.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY INSTALLATION_SCRIPT_YY FAILED_YY @>@/
@=FOR_YY ENTRY_YY entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY INSTALLATION_SCRIPT_YY FAILED_YY "
             << "FOR_YY ENTRY_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    param->entry_string_vector.clear();

};

@q **** (4) statement --> RECEIVE_YY DOWNLOAD_INFO_YY SUCCEEDED_YY @>
@q **** (4) FOR_ENTRY_YY entry_string_list                         @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_YY} \.{DOWNLOAD\_INFO\_YY} 
\.{SUCCEEDED\_YY} \.{FOR\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2010.02.02.}

\LOG
\initials{LDF 2010.02.02.}
Added this rule.

\initials{LDF 2010.03.12.}
Added \.{FOR\_YY} \.{ENTRY\_YY} \.{STRING\_YY}.

\initials{LDF 2010.03.18.}
Changed \.{STRING\_YY} to \<entry string list>.  Removed variants of this rule.

\initials{LDF 2010.03.29.}
Changed |DOWNLOAD_URL_YY| to |DOWNLOAD_INFO_YY|.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY DOWNLOAD_INFO_YY SUCCEEDED_YY FOR_YY ENTRY_YY entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY DOWNLOAD_INFO_YY SUCCEEDED_YY FOR_YY ENTRY_YY "
             << "entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    param->entry_string_vector.clear();

};

@q **** (4) statement --> RECEIVE_YY DOWNLOAD_INFO_YY FAILED_YY @>
@q **** (4) FOR_ENTRY_YY entry_string_list                      @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_YY} \.{DOWNLOAD\_INFO\_YY} 
\.{FAILED\_YY} \.{FOR\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2010.03.12.}

\LOG
\initials{LDF 2010.03.12.}
Added this rule.

\initials{LDF 2010.03.18.}
Replaced \.{STRING\_YY} with \<entry string list>.

\initials{LDF 2010.03.29.}
Changed |DOWNLOAD_URL_YY| to |DOWNLOAD_INFO_YY|.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY DOWNLOAD_INFO_YY FAILED_YY FOR_YY ENTRY_YY entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY DOWNLOAD_INFO_YY FAILED_YY FOR_YY ENTRY_YY "
             << "entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    cerr << get_datestamp() << " [Thread " << param->thread_ctr << "] "
         << "ERROR!  Client failed to receive download info";

    if (param->entry_string_vector.size() ==  0) /* This should never happen.
                                                    \initials{LDF 2010.03.18.}  */
 
       cerr << " for unknown entry." << endl;

    else 
       cerr << " for entry `" << param->entry_string_vector[0] << "'." 
            << endl;

    if (param->entry_string_vector.size() > 1)
       cerr << " " << param->entry_string_vector[1] << endl;

    param->entry_string_vector.clear();

};

@q **** (4) statement --> RECEIVE_YY DOWNLOAD_URL_YY ENCRYPTED_YY SUCCEEDED_YY @>
@q **** (4) FOR_ENTRY_YY entry_string_list                                     @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_YY} 
\.{DOWNLOAD\_URL\_YY} \.{ENCRYPTED\_YY} \.{SUCCEEDED\_YY} \.{FOR\_YY} 
\.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2011.02.10.}

\LOG
\initials{LDF 2011.02.10.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY DOWNLOAD_URL_YY ENCRYPTED_YY SUCCEEDED_YY FOR_YY ENTRY_YY @>@/
@= entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY DOWNLOAD_URL_YY ENCRYPTED_YY SUCCEEDED_YY FOR_YY ENTRY_YY "
             << "entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    param->entry_string_vector.clear();

};

@q **** (4) statement --> RECEIVE_YY DOWNLOAD_URL_YY ENCRYPTED_YY @>
@q **** (4) FAILED_YY FOR_ENTRY_YY entry_string_list              @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_YY} 
\.{DOWNLOAD\_URL\_YY} \.{ENCRYPTED\_YY} 
\.{FAILED\_YY} \.{FOR\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2011.02.10.}

\LOG
\initials{LDF 2011.02.10.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY DOWNLOAD_URL_YY ENCRYPTED_YY FAILED_YY FOR_YY ENTRY_YY @>@/
@=            entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY DOWNLOAD_URL_YY ENCRYPTED_YY FAILED_YY FOR_YY ENTRY_YY "
             << "entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    cerr << get_datestamp() << " [Thread " << param->thread_ctr << "] "
         << "ERROR!  Client failed to receive encrypted download URL";

    if (param->entry_string_vector.size() ==  0) /* This should never happen.
                                                    \initials{LDF 2010.03.18.}  */
 
       cerr << " for unknown entry." << endl;

    else 
       cerr << " for entry `" << param->entry_string_vector[0] << "'." 
            << endl;

    if (param->entry_string_vector.size() > 1)
       cerr << " " << param->entry_string_vector[1] << endl;

    param->entry_string_vector.clear();

};

@q **** (4) statement --> RECEIVE_YY DOWNLOAD_COMMAND_YY ENCRYPTED_YY SUCCEEDED_YY @>
@q **** (4) FOR_ENTRY_YY entry_string_list                                         @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_YY} 
\.{DOWNLOAD\_COMMAND\_YY} \.{ENCRYPTED\_YY} \.{SUCCEEDED\_YY} \.{FOR\_YY} 
\.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2011.03.30.}

\LOG
\initials{LDF 2011.03.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY DOWNLOAD_COMMAND_YY ENCRYPTED_YY SUCCEEDED_YY FOR_YY ENTRY_YY @>@/
@= entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY DOWNLOAD_COMMAND_YY ENCRYPTED_YY SUCCEEDED_YY "
             << "FOR_YY ENTRY_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    param->entry_string_vector.clear();

};

@q **** (4) statement --> RECEIVE_YY DOWNLOAD_COMMAND_YY ENCRYPTED_YY @>
@q **** (4) FAILED_YY FOR_ENTRY_YY entry_string_list              @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_YY} 
\.{DOWNLOAD\_COMMAND\_YY} \.{ENCRYPTED\_YY} 
\.{FAILED\_YY} \.{FOR\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2011.03.30.}

\LOG
\initials{LDF 2011.03.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY DOWNLOAD_COMMAND_YY ENCRYPTED_YY FAILED_YY FOR_YY ENTRY_YY @>@/
@=            entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY DOWNLOAD_COMMAND_YY ENCRYPTED_YY FAILED_YY "
             << "FOR_YY ENTRY_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    cerr << get_datestamp() << " [Thread " << param->thread_ctr << "] "
         << "ERROR!  Client failed to receive encrypted download command";

    if (param->entry_string_vector.size() ==  0) /* This should never happen.
                                                    \initials{LDF 2010.03.18.}  */
 
       cerr << " for unknown entry." << endl;

    else 
       cerr << " for entry `" << param->entry_string_vector[0] << "'." 
            << endl;

    if (param->entry_string_vector.size() > 1)
       cerr << " " << param->entry_string_vector[1] << endl;

    param->entry_string_vector.clear();

};

@q **** (4) statement --> RECEIVE_YY AUTHORIZATION_YY SUCCEEDED_YY @>
@q **** (4) FOR_ENTRY_YY entry_string_list                         @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_YY} 
\.{AUTHORIZATION\_YY} \.{SUCCEEDED\_YY} \.{FOR\_YY} 
\.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2011.05.06.}

\LOG
\initials{LDF 2011.05.06.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY AUTHORIZATION_YY SUCCEEDED_YY FOR_YY ENTRY_YY @>@/
@= entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY AUTHORIZATION_YY SUCCEEDED_YY FOR_YY ENTRY_YY "
             << "entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    param->entry_string_vector.clear();

};

@q **** (4) statement --> RECEIVE_YY AUTHORIZATION_YY @>
@q **** (4) FAILED_YY FOR_ENTRY_YY entry_string_list              @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_YY} 
\.{DOWNLOAD\_URL\_YY}
\.{FAILED\_YY} \.{FOR\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2011.05.06.}

\LOG
\initials{LDF 2011.05.06.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY AUTHORIZATION_YY FAILED_YY FOR_YY ENTRY_YY @>@/
@=entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY AUTHORIZATION_YY FAILED_YY FOR_YY ENTRY_YY "
             << "entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    cerr << get_datestamp() << " [Thread " << param->thread_ctr << "] "
         << "ERROR!  Client failed to receive authorization ";

    if (param->entry_string_vector.size() ==  0) /* This should never happen.
                                                    \initials{LDF 2010.03.18.}  */
 
       cerr << " for unknown entry." << endl;

    else 
       cerr << " for entry `" << param->entry_string_vector[0] << "'." 
            << endl;

    if (param->entry_string_vector.size() > 1)
       cerr << " " << param->entry_string_vector[1] << endl;

    param->entry_string_vector.clear();

};

@q **** (4) statement --> VALIDATE_YY DISTINGUISHED_NAME_YY STRING_YY @>

@ \<statement> $\longrightarrow$ \.{VALIDATE\_YY} \.{DISTINGUISHED\_NAME\_YY}
\.{STRING\_YY}.
\initials{LDF 2010.02.11.}

\LOG
\initials{LDF 2010.02.11.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  VALIDATE_YY DISTINGUISHED_NAME_YY STRING_YY@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: VALIDATE_YY DISTINGUISHED_NAME_YY STRING_YY'."
             << endl
             << "`STRING_YY' == $3 == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    Response_Type response;
 
    response.type                   = Response_Type::VALIDATE_DISTINGUISHED_NAME_TYPE;
    response.distinguished_name_str = @=$3@>;

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_front(response);
    pthread_mutex_unlock(&param->response_deque_mutex);
    
};

@q **** (4) prerequisite_string_list:  /* Empty  */  @>

@ \<prerequisite string list>. $\longrightarrow$ \.{EMPTY}. 
\initials{LDF 2010.03.17.}

\LOG
\initials{LDF 2010.03.17.}
Added this rule.
\ENDLOG

@<Rules@>=

@=prerequisite_string_list: /* Empty  */  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " 
             << static_cast<Scan_Parse_Parameter_Type*>(
                   yyget_extra(parameter))->thread_ctr 
             << "] In `yyparse':  `prerequisite_string_list: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->prerequisite_string_vector.clear();

};

@q **** (4) prerequisite_string_list:  prerequisite_string_list STRING_YY @>

@ \<string list>. $\longrightarrow$ \.{STRING\_YY}. 
\initials{LDF 2010.03.17.}

\LOG
\initials{LDF 2010.03.17.}
Added this rule.
\ENDLOG

@<Rules@>=

@=prerequisite_string_list: prerequisite_string_list STRING_YY  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " 
             << static_cast<Scan_Parse_Parameter_Type*>(
                   yyget_extra(parameter))->thread_ctr 
             << "] In `yyparse':  `prerequisite_string_list: prerequisite_string_list STRING_YY'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->prerequisite_string_vector.push_back(@=$2@>);

};

@q **** (4) entry_string_list:  /* Empty  */  @>

@ \<entry string list>. $\longrightarrow$ \.{EMPTY}. 
\initials{LDF 2010.03.17.}

\LOG
\initials{LDF 2010.03.17.}
Added this rule.
\ENDLOG

@<Rules@>=

@=entry_string_list: /* Empty  */  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " 
             << static_cast<Scan_Parse_Parameter_Type*>(
                   yyget_extra(parameter))->thread_ctr 
             << "] In `yyparse':  `entry_string_list: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->entry_string_vector.clear();

};

@q **** (4) entry_string_list:  entry_string_list STRING_YY @>

@ \<string list>. $\longrightarrow$ \.{STRING\_YY}. 
\initials{LDF 2010.03.17.}

\LOG
\initials{LDF 2010.03.17.}
Added this rule.
\ENDLOG

@<Rules@>=

@=entry_string_list: entry_string_list STRING_YY  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " 
             << static_cast<Scan_Parse_Parameter_Type*>(
                   yyget_extra(parameter))->thread_ctr 
             << "] In `yyparse':  `entry_string_list: entry_string_list STRING_YY'." 
             << endl;

        cerr << "$2 == " << @=$2@> << endl;

        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->entry_string_vector.push_back(@=$2@>);

};

@q **** (4) statement --> ADD_YY PREREQUISITE_YY prerequisite_string_list FOR_YY @>
@q **** (4)               ENTRY_YY entry_string_list @>

@ \<statement> $\longrightarrow$ 
\.{ADD\_YY} \.{PREREQUISITE\_YY} \<prerequisite string list> 
\.{STRING\_YY} \.{FOR\_YY} \.{ENTRY\_YY} \<entry string list> .
\initials{LDF 2010.03.15.}

\LOG
\initials{LDF 2010.03.15.}
Added this rule.

\initials{LDF 2010.03.18.}
Changed this rule.  Replaced |STRING_YY| symbols with |prerequisite_string_list| and 
|entry_string_list|.  Removed the other variants of this rule.
\ENDLOG

@<Rules@>=
@=statement:  ADD_YY PREREQUISITE_YY prerequisite_string_list FOR_YY ENTRY_YY entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: ADD_YY PREREQUISITE_YY prerequisite_string_list "
             << "FOR_YY ENTRY_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    string entry_version = ""; 
    string prereq_version = "";

    if (param->entry_string_vector.size() > 1) 
       entry_version = param->entry_string_vector[1];

    if (param->prerequisite_string_vector.size() > 1) 
       prereq_version = param->prerequisite_string_vector[1];

  
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "param->entry_string_vector.size() == " 
             << param->entry_string_vector.size()
             << endl 
             << "param->prerequisite_string_vector.size() == " 
             << param->prerequisite_string_vector.size()
             << endl
             << "param->entry_string_vector[0] == " 
             << param->entry_string_vector[0]
             << endl 
             << "param->prerequisite_string_vector[0] == " 
             << param->prerequisite_string_vector[0]
             << endl
             << "`entry_version' == " << entry_version
             << endl
             << "`prereq_version' == " << prereq_version
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)| */
 
    int status = param->add_prerequisite(param->entry_string_vector[0], 
                                         entry_version,
                                         param->prerequisite_string_vector[0], 
                                         prereq_version);

    param->entry_string_vector.clear();

    param->prerequisite_string_vector.clear();

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: ADD_YY PREREQUISITE_YY prerequisite_string_list FOR_YY "
             << "ENTRY_YY entry_string_list'."
             << endl
             << "`Scan_Parse_Parameter_Type::add_prerequisite' returned " << status
             << endl;
  
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#endif 

};

@q **** (4) statement --> DELETE_YY ENTRY_YY entry_string_list FINALLY_YY @>

@ \<statement> $\longrightarrow$ 
\.{DELETE\_YY} \.{ENTRY\_YY} \<entry string list> \.{FINALLY\_YY}.
\initials{LDF 2010.09.09.}

\LOG
\initials{LDF 2010.09.09.}
Added this rule.

\initials{LDF 2012.01.12.}
Added \.{FINALLY\_YY}.
\ENDLOG

@<Rules@>=
@=statement:  DELETE_YY ENTRY_YY entry_string_list FINALLY_YY@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DELETE_YY ENTRY_YY entry_string_list FINALLY_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    string entry_version = ""; 

    if (param->entry_string_vector.size() > 1) 
       entry_version = param->entry_string_vector[1];

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "param->entry_string_vector.size() == " 
             << param->entry_string_vector.size()
             << endl 
             << "param->entry_string_vector[0] == " 
             << param->entry_string_vector[0]
             << endl 
             << "`entry_version' == " << entry_version
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)| */
 
    int status = param->delete_entries(param->entry_string_vector[0], 
                                     entry_version);

    param->entry_string_vector.clear();

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DELETE_YY ENTRY_YY entry_string_list'."
             << endl
             << "`Scan_Parse_Parameter_Type::delete_entries' returned " << status
             << endl;
  
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#endif 

};

@q **** (4) statement --> DELETE_YY ALL_YY ENTRIES_YY FOR_YY USER_YY FINALLY_YY@>

@ \<statement> $\longrightarrow$ 
\.{DELETE\_YY} \.{ALL\_YY} \.{ENTRIES\_YY} \.{FOR\_YY} \.{USER\_YY}
\.{FINALLY\_YY}.
\initials{LDF 2010.10.14.}

\LOG
\initials{LDF 2010.10.14.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement:  DELETE_YY ALL_YY ENTRIES_YY FOR_YY USER_YY FINALLY_YY@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DELETE_YY ALL_YY ENTRIES_YY FOR_YY USER_YY FINALLY_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    int status = param->delete_entries();

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DELETE_YY ALL_YY ENTRIES_YY FOR_YY USER_YY FINALLY_YY'."
             << endl
             << "`Scan_Parse_Parameter_Type::delete_entries' returned " << status
             << endl;
  
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#endif 

};

@q **** (4) statement --> MARK_YY AS_YY DELETED_YY ENTRY_YY entry_string_list  @>

@ \<statement> $\longrightarrow$ 
\.{MARK\_YY} \.{AS\_YY} \.{DELETED\_YY} \.{ENTRY\_YY} \<entry string list> 
\initials{LDF 2012.01.12.}

\LOG
\initials{LDF 2012.01.12.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement: MARK_YY AS_YY DELETED_YY ENTRY_YY entry_string_list @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: MARK_YY AS_YY DELETED_YY ENTRY_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    string entry_version = ""; 

    if (param->entry_string_vector.size() > 1) 
       entry_version = param->entry_string_vector[1];

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "param->entry_string_vector.size() == " 
             << param->entry_string_vector.size()
             << endl 
             << "param->entry_string_vector[0] == " 
             << param->entry_string_vector[0]
             << endl 
             << "`entry_version' == " << entry_version
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)| */
 

    int status = param->mark_entries(true,
                                     param->entry_string_vector[0], 
                                     entry_version);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: MARK_YY AS_YY DELETED_YY ENTRY_YY entry_string_list':"
             << endl
             << "`Scan_Parse_Parameter_Type::mark_entries' failed, returning "
             << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: MARK_YY AS_YY DELETED_YY ENTRY_YY entry_string_list':"
             << endl 
             << "`Scan_Parse_Parameter_Type::mark_entries' succeeded."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |else if (param->PARSER_DEBUG)| */

    param->entry_string_vector.clear();

#endif 

    

};

@q **** (4) statement --> MARK_YY AS_YY DELETED_YY ALL_YY ENTRIES_YY @>
@q **** (4)               FOR_YY USER_YY                             @>

@ \<statement> $\longrightarrow$ 
\.{MARK\_YY} \.{AS\_YY} \.{DELETED\_YY} \.{ALL\_YY} \.{ENTRIES\_YY} \.{FOR\_YY}
\.{USER\_YY}.
\initials{LDF 2012.01.12.}

\LOG
\initials{LDF 2012.01.12.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement: MARK_YY AS_YY DELETED_YY ALL_YY ENTRIES_YY FOR_YY USER_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: MARK_YY AS_YY DELETED_YY ALL_YY ENTRIES_YY FOR_YY USER_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    int status = param->mark_entries(true);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: MARK_YY AS_YY DELETED_YY ENTRY_YY entry_string_list':"
             << endl
             << "`Scan_Parse_Parameter_Type::mark_entries' failed, returning "
             << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: MARK_YY AS_YY DELETED_YY ENTRY_YY entry_string_list':"
             << endl 
             << "`Scan_Parse_Parameter_Type::mark_entries' succeeded."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |else if (param->PARSER_DEBUG)| */

#endif 

    

};

@q **** (4) statement --> UNDELETE_YY ENTRY_YY entry_string_list @>

@ \<statement> $\longrightarrow$ 
\.{UNDELETE\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2012.01.12.}

\LOG
\initials{LDF 2012.01.12.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement:  UNDELETE_YY ENTRY_YY entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: UNDELETE_YY ENTRY_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    string entry_version = ""; 

    if (param->entry_string_vector.size() > 1) 
       entry_version = param->entry_string_vector[1];

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "param->entry_string_vector.size() == " 
             << param->entry_string_vector.size()
             << endl 
             << "param->entry_string_vector[0] == " 
             << param->entry_string_vector[0]
             << endl 
             << "`entry_version' == " << entry_version
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)| */

    int status = param->mark_entries(false, 
                                     param->entry_string_vector[0], 
                                     entry_version);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: UNDELETE_YY ENTRY_YY entry_string_list':"
             << endl
             << "`Scan_Parse_Parameter_Type::mark_entries' failed, returning "
             << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: UNDELETE_YY ENTRY_YY entry_string_list':"
             << endl 
             << "`Scan_Parse_Parameter_Type::mark_entries' succeeded."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |else if (param->PARSER_DEBUG)| */

    param->entry_string_vector.clear();

#endif 

     

};

@q **** (4) statement --> UNDELETE_YY ALL_YY DELETED_YY ENTRIES_YY FOR_YY USER_YY@>

@ \<statement> $\longrightarrow$ 
\.{UNDELETE\_YY} \.{ALL\_YY} \.{DELETED\_YY} \.{ENTRIES\_YY} \.{FOR\_YY} \.{USER\_YY}.
\initials{LDF 2012.01.12.}

\LOG
\initials{LDF 2012.01.12.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement:  UNDELETE_YY ALL_YY DELETED_YY ENTRIES_YY FOR_YY USER_YY@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: UNDELETE_YY ALL_YY DELETED_YY ENTRIES_YY FOR_YY USER_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    int status = param->mark_entries(false);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: UNDELETE_YY ALL_YY DELETED_YY ENTRIES_YY FOR_YY USER_YY':"
             << endl
             << "`Scan_Parse_Parameter_Type::mark_entries' failed, returning "
             << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: UNDELETE_YY ALL_YY DELETED_YY ENTRIES_YY FOR_YY USER_YY':"
             << endl 
             << "`Scan_Parse_Parameter_Type::mark_entries' succeeded."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |else if (param->PARSER_DEBUG)| */

#endif 

    

};

@q **** (4) statement --> DELETE_YY PREREQUISITE_YY prerequisite_string_list @>
@q **** (4) FOR_YY ENTRY_YY entry_string_list                                @>

@ \<statement> $\longrightarrow$ \.{DELETE\_YY} \<prerequisite string list>
\.{FOR\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2010.09.09.}

\LOG
\initials{LDF 2010.09.09.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement:  DELETE_YY PREREQUISITE_YY prerequisite_string_list @>@/
@=FOR_YY ENTRY_YY entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DELETE_YY PREREQUISITE_YY prerequisite_string_list "
             << "FOR_YY ENTRY_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();

        cerr << "param->prerequisite_string_vector.size() == " 
             << param->prerequisite_string_vector.size()
             << endl;

        int i = 0;

        for (vector<string>::const_iterator iter = param->prerequisite_string_vector.begin();
             iter != param->prerequisite_string_vector.end();
             ++iter)
           cerr << "param->prerequisite_string_vector[" << i++ << "] == " << *iter 
                << endl;

        i = 0;

        cerr << "param->entry_string_vector.size() == " 
             << param->entry_string_vector.size()
             << endl;

        for (vector<string>::const_iterator iter = param->entry_string_vector.begin();
             iter != param->entry_string_vector.end();
             ++iter)
           cerr << "param->entry_string_vector[" << i++ << "] == " << *iter 
                << endl;

        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)| */

    string prerequisite_version;
    string entry_version;

    if (   param->prerequisite_string_vector.size() > 1 
        && !param->prerequisite_string_vector[1].empty())
        prerequisite_version = param->prerequisite_string_vector[1];

    if (   param->entry_string_vector.size() > 1 
        && !param->entry_string_vector[1].empty())
        entry_version = param->entry_string_vector[1];

    int status = param->delete_prerequisites(false,
                                             param->entry_string_vector[0],
                                             entry_version,
                                             param->prerequisite_string_vector[0],
                                             prerequisite_version);

    param->entry_string_vector.clear();
    param->prerequisite_string_vector.clear();

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DELETE_YY PREREQUISITE_YY prerequisite_string_list "
             << "FOR_YY ENTRY_YY entry_string_list'."
             << endl
             << "`Scan_Parse_Parameter_Type::delete_prerequisites' returned " << status
             << endl;

        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#endif 

};

@q **** (4) statement --> DELETE_YY PREREQUISITES_YY FOR_YY ENTRY_YY entry_string_list  @>

@ \<statement> $\longrightarrow$ \.{DELETE\_YY} \.{PREREQUISITES\_YY}
\.{FOR\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2010.09.09.}

\LOG
\initials{LDF 2010.09.09.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement:  DELETE_YY PREREQUISITES_YY FOR_YY ENTRY_YY entry_string_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DELETE_YY PREREQUISITES_YY "
             << "FOR_YY ENTRY_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();

        int i = 0;

        cerr << "param->entry_string_vector.size() == " 
             << param->entry_string_vector.size()
             << endl;

        for (vector<string>::const_iterator iter = param->entry_string_vector.begin();
             iter != param->entry_string_vector.end();
             ++iter)
           cerr << "param->entry_string_vector[" << i++ << "] == " << *iter 
                << endl;

        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)| */

    string entry_version;

    if (   param->entry_string_vector.size() > 1 
        && !param->entry_string_vector[1].empty())
        entry_version = param->entry_string_vector[1];

    int status = param->delete_prerequisites(true,
                                             param->entry_string_vector[0],
                                             entry_version);

    param->entry_string_vector.clear();

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DELETE_YY PREREQUISITES_YY "
             << "FOR_YY ENTRY_YY entry_string_list'."
             << endl
             << "`Scan_Parse_Parameter_Type::delete_prerequisites' returned " << status
             << endl;

  
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#endif 

};

@q **** (4) statement:  CLIENT_YY TO_YY SEND_YY ENVIRONMENT_YY SHELLSCRIPT_YY @>
@q **** (4) STRING_YY GLOBUS_SITE_YY STRING_YY admin_optional                 @>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{TO\_YY} \.{SEND\_YY} 
\.{ENVIRONMENT\_YY} \.{SHELLSCRIPT\_YY} \.{STRING\_YY} \.{GLOBUS\_SITE\_YY} 
\.{STRING\_YY} \<admin optional>.
\initials{LDF 2012.03.16.}

\LOG
\initials{LDF 2012.03.16.}
Added this rule.

\initials{LDF 2012.03.22.}
Added \<admin optional>.
\ENDLOG

@<Rules@>=

@=statement:  CLIENT_YY TO_YY SEND_YY ENVIRONMENT_YY SHELLSCRIPT_YY STRING_YY @>@/
@=GLOBUS_SITE_YY STRING_YY admin_optional@>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `CLIENT_YY TO_YY SEND_YY "
             << "ENVIRONMENT_YY SHELLSCRIPT_YY STRING_YY GLOBUS_SITE_YY STRING_YY "
             << "admin_optional'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    stringstream temp_strm;

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

    temp_strm << "SEND ENVIRONMENT SHELLSCRIPT <" << @=$6@> << "> GLOBUS_SITE <" << @=$8@> 
              << ">";

    if (@=$9@> > 0)
       temp_strm << " ADMIN";

    response.command = temp_strm.str();

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

     

};

@q **** (4) admin_optional  @>
@ \<admin optional>.

\LOG
\initials{LDF 2012.03.22.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> admin_optional@>

@q **** (4) admin_optional:  /* Empty  */  @>

@ \<admin optional> $\longrightarrow$ \.{Empty}.
\initials{LDF 2012.03.22.}

\LOG
\initials{LDF 2012.03.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=admin_optional:  /* Empty  */  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `admin_optional:  /* Empty  */.'"
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 0;

     

};

@q **** (4) admin_optional:  ADMIN_YY  @>

@ \<admin optional> $\longrightarrow$ \.{ADMIN\_YY}.
\initials{LDF 2012.03.22.}

\LOG
\initials{LDF 2012.03.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=admin_optional:  ADMIN_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `admin_optional:  "
             << "ADMIN_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 1;

     

};

@q **** (4) statement:  CLIENT_YY SENDING_YY ENVIRONMENT_YY SHELLSCRIPT_YY @>
@q **** (4) GLOBUS_SITE_YY STRING_YY admin_optional                        @>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{SENDING\_YY} \.{ENVIRONMENT\_YY}.
\.{SHELLSCRIPT\_YY} \.{GLOBUS\_SITE\_YY} \.{STRING\_YY} \<admin optional>.
\initials{LDF 2010.03.19.}

\LOG
\initials{LDF 2010.03.19.}
Added this rule.

\initials{LDF 2012.03.16.}
Added \.{GLOBUS\_SITE\_YY} \.{STRING\_YY}.

\initials{LDF 2012.03.22.}
Added \<admin optional>.
\ENDLOG

@<Rules@>=

@=statement:  CLIENT_YY SENDING_YY ENVIRONMENT_YY SHELLSCRIPT_YY GLOBUS_SITE_YY STRING_YY @>@/
@=admin_optional@>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `CLIENT_YY SENDING_YY ENVIRONMENT_YY "
             << "SHELLSCRIPT_YY GLOBUS_SITE_YY STRING_YY admin_optional'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

    param->environment_globus_site = @=$6@>;
    param->environment_admin_flag  = @=$7@>;

    char temp_str[] = "";

    int status = accept_data(param, temp_str, 0, Response_Type::SEND_ENVIRONMENT_SHELLSCRIPT_TYPE);

    if (status != 0)
    {
        lock_cerr_mutex();
        cerr << get_datestamp() << " [Thread " 
             << param->thread_ctr 
             << "] ERROR!  In `yyparse', rule `CLIENT_YY SENDING_YY "
             << "ENVIRONMENT_YY SHELLSCRIPT_YY GLOBUS_SITE_YY STRING_YY admin_optional':" 
             << endl
             << "`accept_data' failed, returning " << status << ".  Continuing."
             << endl;
        unlock_cerr_mutex();

        response.command = "SERVER RECEIVE ENVIRONMENT SHELLSCRIPT GLOBUS_SITE ";
        response.command += @=$6@>;
        response.command += " FAILED";

    }  /* |if (status != 0)|  */

    else /* |status == 0|  */
    {
       response.command =   "SERVER RECEIVE ENVIRONMENT SHELLSCRIPT GLOBUS_SITE "; 
       response.command += @=$6@>;
       response.command += " SUCCEEDED";
       
    } /* |else| (|status == 0|)  */

    param->environment_globus_site = "";

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

     

    param->environment_globus_site = "";
    param->environment_admin_flag  = 0;

};

@q **** (4) statement:  FETCH_YY ENVIRONMENT_YY SHELLSCRIPT_YYS FOR_YY @>
@q **** (4) GLOBUS_SITE_YY STRING_YY                                   @>

@ \<statement> $\longrightarrow$ \.{FETCH\_YY} \.{ENVIRONMENT\_YY}.
\.{SHELLSCRIPTS\_YY} \.{FOR\_YY} \.{GLOBUS\_SITE\_YY} \.{STRING\_YY}.
\initials{LDF 2012.03.19.}

\LOG
\initials{LDF 2012.03.19.}
Added this rule.

\initials{LDF 2012.03.22.}
Changed \.{SHELLSCRIPT\_YY} to \.{SHELLSCRIPTS\_YY}.
\ENDLOG

@<Rules@>=

@=statement: FETCH_YY ENVIRONMENT_YY SHELLSCRIPTS_YY FOR_YY GLOBUS_SITE_YY STRING_YY@>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `FETCH_YY ENVIRONMENT_YY SHELLSCRIPTS_YY "
             << "FOR_YY GLOBUS_SITE_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    stringstream temp_strm;

    Response_Type response;
 
    response.type = Response_Type::FETCH_ENVIRONMENT_SHELLSCRIPT_TYPE;
    response.globus_site = @=$6@>;

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

    

};

@q **** (4) statement:  RECEIVE_YY ENVIRONMENT_YY SHELLSCRIPT_YY SUCCEEDED_YY @>
@q **** (4) FOR_YY GLOBUS_SITE_YY STRING_YY                                   @>

@ \.{RECEIVE\_YY} \.{ENVIRONMENT\_YY} \.{SHELLSCRIPT\_YY} 
\.{SUCCEEDED\_YY} \.{FOR\_YY} \.{GLOBUS\_SITE\_YY} \.{STRING\_YY}.
\initials{LDF 2012.03.21.}

\LOG
\initials{LDF 2012.03.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY ENVIRONMENT_YY SHELLSCRIPT_YY SUCCEEDED_YY @>@/
@=FOR_YY GLOBUS_SITE_YY STRING_YY@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY ENVIRONMENT_YY SHELLSCRIPT_YY "
             << "SUCCEEDED_YY FOR_YY GLOBUS_SITE_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    

};

@q **** (4) statement:  RECEIVE_YY ENVIRONMENT_YY SHELLSCRIPT_YY FAILED_YY @>
@q **** (4) FOR_YY GLOBUS_SITE_YY STRING_YY                                @>

@ \.{RECEIVE\_YY} \.{ENVIRONMENT\_YY} \.{SHELLSCRIPT\_YY} 
\.{FAILED\_YY} \.{FOR\_YY} \.{GLOBUS\_SITE\_YY} \.{STRING\_YY}.
\initials{LDF 2012.03.21.}

\LOG
\initials{LDF 2012.03.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY ENVIRONMENT_YY SHELLSCRIPT_YY FAILED_YY @>@/
@=FOR_YY GLOBUS_SITE_YY STRING_YY@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY ENVIRONMENT_YY SHELLSCRIPT_YY FAILED_YY "
             << "FOR_YY GLOBUS_SITE_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    lock_cerr_mutex();
    cerr << get_datestamp() << " [Thread " << param->thread_ctr 
         << "] WARNING!  In `yyparse':  "
         << "`statement: RECEIVE_YY ENVIRONMENT_YY SHELLSCRIPT_YY FAILED_YY "
         << "FOR_YY GLOBUS_SITE_YY STRING_YY':"
         << endl
         << "Client failed to receive environment shellscript "
         << "for Globus site `" << @=$7@> << "'."
         << endl
         << "Continuing."
         << endl;
    unlock_cerr_mutex(); 

};

@q **** (4) statement:  DELETE_YY ENVIRONMENT_YY SHELLSCRIPTS_YY  @>

@ \.{DELETE\_YY} \.{ENVIRONMENT\_YY} \.{SHELLSCRIPTS\_YY}.
\initials{LDF 2012.03.26.}

\LOG
\initials{LDF 2012.03.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  DELETE_YY ENVIRONMENT_YY SHELLSCRIPTS_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DELETE_YY ENVIRONMENT_YY SHELLSCRIPTS_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT   

    int status = param->delete_environment_shellscripts(0, "");

#endif /* |HAVE_LIBMYSQLCLIENT|  */

     

};

@q **** (4) statement:  DELETE_YY ENVIRONMENT_YY SHELLSCRIPTS_YY  @>
@q **** (4) FOR_YY GLOBUS_SITE_YY STRING_YY                       @>

@ \.{DELETE\_YY} \.{ENVIRONMENT\_YY} \.{SHELLSCRIPTS\_YY} 
\.{FOR\_YY} \.{GLOBUS\_SITE\_YY} \.{STRING\_YY}.
\initials{LDF 2012.03.21.}

\LOG
\initials{LDF 2012.03.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  DELETE_YY ENVIRONMENT_YY SHELLSCRIPTS_YY @>@/
@=FOR_YY GLOBUS_SITE_YY STRING_YY@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DELETE_YY ENVIRONMENT_YY SHELLSCRIPTS_YY  "
             << "FOR_YY GLOBUS_SITE_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT   

    int status = param->delete_environment_shellscripts(0, @=$6@>);

#endif /* |HAVE_LIBMYSQLCLIENT|  */

     

};

@q **** (4) statement:  DELETE_YY ENVIRONMENT_YY SHELLSCRIPT_YY INTEGER_YY @>

@ \.{DELETE\_YY} \.{ENVIRONMENT\_YY} \.{SHELLSCRIPT\_YY} \.{INTEGER\_YY}.
\initials{LDF 2012.03.26.}

\LOG
\initials{LDF 2012.03.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  DELETE_YY ENVIRONMENT_YY SHELLSCRIPT_YY INTEGER_YY@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DELETE_YY ENVIRONMENT_YY SHELLSCRIPT_YY  "
             << "INTEGER_YY'."
             << endl
             << "`INTEGER_YY' == " << @=$4@>
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT   

    int status = param->delete_environment_shellscripts(@=$4@>);

#endif /* |HAVE_LIBMYSQLCLIENT|  */

     

};

@q **** (4) entry_or_entries  @>
@ \<entry or entries>.

\LOG
\initials{LDF 2012.05.21.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> entry_or_entries@>

@q **** (4) entry_or_entries:  ENTRY_YY  @>

@ \<entry or entries> $\longrightarrow$ \.{ENTRY\_YY}.
\initials{LDF 2012.05.21.}

\LOG
\initials{LDF 2012.05.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=entry_or_entries:  ENTRY_YY  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `entry_or_entries:  ENTRY_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 0;

     

};

@q **** (4) entry_or_entries:  ENTRIES_YY  @>

@ \<entry or entries> $\longrightarrow$ \.{ENTRIES\_YY}.
\initials{LDF 2012.05.21.}

\LOG
\initials{LDF 2012.05.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=entry_or_entries:  ENTRIES_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `entry_or_entries: ENTRIES_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 1;

     

};

@q **** (4) statement:  SHOW_YY ENTRIES_YY show_option_list @>

@ \<statement> $\longrightarrow$ \.{SHOW\_YY} \.{ENTRIES\_YY} 
\<show option list>.
\initials{LDF 2010.05.21.}

\LOG
\initials{LDF 2010.05.21.}
Added this rule.

\initials{LDF 2010.09.08.}
Added \<with prerequisites optional>.

\initials{LDF 2010.09.23.}
Added \<html optional>.

\initials{LDF 2010.10.08.}
Added \<with installation script optional>.

\initials{LDF 2011.01.26.}
Added \.{FOR\_YY}. 

\initials{LDF 2011.01.28.}
Replaced \<with prerequisites optional>, \<html optional> and
\<with installation script optional> with \<show option list>.
Removed \.{FOR\_YY}. 

\initials{LDF 2012.05.21.}
Changed \.{ENTRIES\_YY} to \<entry or entries> and added \<entry string list>.
\ENDLOG

@<Rules@>=

@=statement: SHOW_YY entry_or_entries entry_string_list show_option_list @> 
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  SHOW_YY entry_or_entries "
             << "entry_string_list show_option_list'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    Response_Type response;

    response.type = Response_Type::SHOW_ENTRIES_TYPE;

    if (@=$2@> == 0)
    {
        response.entries_single = true;

        response.entry_name = param->entry_string_vector[0];

        if (param->entry_string_vector.size() > 1)
           response.version = param->entry_string_vector[1];
    }

    if (!(param->show_options & 1U | param->show_options & 2U)) 
    {
       /* Always at least show user entries. 
          \initials{LDF 2012.04.03.}  */

        param->show_options = 1U;  
    }

    response.entries_user                     =      1U & param->show_options;
    response.entries_public                   =      2U & param->show_options;
    
    response.entries_with_prerequisites       =      4U & param->show_options;

    response.entries_with_dependents          =    256U & param->show_options;
    
    response.entries_with_installation_script =      8U & param->show_options;

    if (32 & param->show_options)  /* JavaScript takes precedence over HTML  
                                      \initials{LDF 2011.12.19.}             */
    {
       response.output_format = Response_Type::OUTPUT_FORMAT_JAVASCRIPT;
    }
    else if (16 & param->show_options)
    {
       response.output_format = Response_Type::OUTPUT_FORMAT_HTML;
    }
    else 
    {
       response.output_format = Response_Type::OUTPUT_FORMAT_PLAIN_TEXT;
    }

    if (64 & param->show_options) /* Show levels  */
    {

        if (param->PARSER_DEBUG)
        {
            cerr << "param->show_level_map.size() == "
                 << param->show_level_map.size()
                 << endl;

            cerr << "level_list:  "
                 << endl;

        }  /* |if (param->PARSER_DEBUG)|  */  

        response.show_level_map = param->show_level_map;

        param->show_level_map.clear();

        if (param->PARSER_DEBUG)
        {
            cerr << "response.show_level_map.size() == " 
                 << response.show_level_map.size() << endl;

            for (map<int, int>::const_iterator iter 
                 = response.show_level_map.begin();
                 iter != response.show_level_map.end();
                 ++iter)
            {
                cerr << "iter->first:   " << iter->first
                     << endl 
                     << "iter->second:  " << iter->second
                     << endl;
            }   
        }  /* |if (param->PARSER_DEBUG)|  */  

    }  /* |if (64 & param->show_options)|  */

    response.entries_all =  128U & param->show_options;           

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

    param->show_options = 0;

    param->entry_string_vector.clear();

     

};

@q **** (4) show_option_list and show_option @>
@ \<show option list> and \<show option>.

\LOG
\initials{LDF 2011.01.28.}
Added these type declarations.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> show_option_list@>
@=%type <int_value> show_option@>

@q **** (4) show_option_list:  /* Empty  */  @>

@ \<show option list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2011.01.28.}

\LOG
\initials{LDF 2011.01.28.}
Added this rule.
\ENDLOG

@<Rules@>=

@=show_option_list:  /* Empty  */  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_option_list:  /* Empty  */.'"
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->show_options = 0;

    param->show_level_map.clear();

    @=$$@> = 0;

};

@q **** (4) show_option_list:  show_option_list show_option  @>

@ \<show option list> $\longrightarrow$ \<show option>.
\initials{LDF 2011.01.28.}

\LOG
\initials{LDF 2011.01.28.}
Added this rule.
\ENDLOG

@<Rules@>=

@=show_option_list:  show_option_list show_option @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_option_list:  show_option_list show_option'.'"
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 0;

};

@q **** (4) show_option:  ALL_YY  @>

@ \<show option> $\longrightarrow$ \.{ALL\_YY}.
\initials{LDF 2011.01.28.}

\LOG
\initials{LDF 2011.01.28.}
Added this rule.

\initials{LDF 2012.04.03.}
Changed, so that the flags for ``user'' and ``public'' are both set, if this 
option is used.  Previously, it was a dummy option that didn't set any flags.
This may need to changed at a later date, if I implement a way of showing 
some entries, e.g., ones that have been modified since a given date, or 
according to some other criteria.
\ENDLOG

@<Rules@>=

@=show_option: ALL_YY  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_option:  ALL_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->show_options |= 3U;  /* User and public  */

    param->show_options |= 128U; /* ``All'' flag --- not currently 
                                     used for anything.
                                     \initials{LDF 2012.04.03.}  */

    @=$$@> = 0;

};

@q **** (4) show_option:  USER_YY  @>

@ \<show option> $\longrightarrow$ \.{USER\_YY}.
\initials{LDF 2011.01.28.}

\LOG
\initials{LDF 2011.01.28.}
Added this rule.
\ENDLOG

@<Rules@>=

@=show_option:  USER_YY  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_option:  USER_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->show_options |= 1U;

    @=$$@> = 0;

};

@q **** (4) show_option:  PUBLIC_YY  @>

@ \<show option> $\longrightarrow$ \.{PUBLIC\_YY}.
\initials{LDF 2011.01.28.}

\LOG
\initials{LDF 2011.01.28.}
Added this rule.
\ENDLOG

@<Rules@>=

@=show_option:  PUBLIC_YY  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_option:  PUBLIC_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->show_options |= 2U;

    @=$$@> = 0;

};

@q **** (4) show_option:  WITH_PREREQUISITES_YY  @>

@ \<show option> $\longrightarrow$ \.{WITH\_PREREQUISITES\_YY}.
\initials{LDF 2011.01.28.}

\LOG
\initials{LDF 2011.01.28.}
Added this rule.
\ENDLOG

@<Rules@>=

@=show_option:  WITH_PREREQUISITES_YY  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_option:  "
             << "WITH_PREREQUISITES_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->show_options |= 4U;

    @=$$@> = 0;

};

@q **** (4) show_option:  WITH_DEPENDENTS_YY  @>

@ \<show option> $\longrightarrow$ \.{WITH\_DEPENDENTS\_YY}.
\initials{LDF 2012.05.21.}

\LOG
\initials{LDF 2012.05.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=show_option:  WITH_DEPENDENTS_YY  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_option:  "
             << "WITH_DEPENDENTS_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->show_options |= 256U;  

    @=$$@> = 0;

     

};

@q **** (4) show_option:  WITH_INSTALLATION_SCRIPT_YY  @>

@ \<show option> $\longrightarrow$ \.{WITH\_INSTALLATION\_SCRIPT\_YY}.
\initials{LDF 2011.01.28.}

\LOG
\initials{LDF 2011.01.28.}
Added this rule.
\ENDLOG

@<Rules@>=

@=show_option:  WITH_INSTALLATION_SCRIPT_YY  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_option:  "
             << "WITH_INSTALLATION_SCRIPT_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->show_options |= 8U;

    @=$$@> = 0;

};

@q **** (4) show_option:  HTML_YY  @>

@ \<show option> $\longrightarrow$ \.{HTML\_YY}.
\initials{LDF 2011.01.28.}

\LOG
\initials{LDF 2011.01.28.}
Added this rule.
\ENDLOG

@<Rules@>=

@=show_option:  HTML_YY  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_option:  HTML_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->show_options |= 16U;

    @=$$@> = 0;

};

@q **** (4) show_option:  JAVASCRIPT_YY  @>

@ \<show option> $\longrightarrow$ \.{JAVASCRIPT\_YY}.
\initials{LDF 2011.12.19.}

\LOG
\initials{LDF 2011.12.19.}
Added this rule.
\ENDLOG

@<Rules@>=

@=show_option:  JAVASCRIPT_YY  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_option:  JAVASCRIPT_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->show_options |= 32U;

    @=$$@> = 0;

};

@q **** (4) show_option:  LEVELS level_list @>

@ \<show option> $\longrightarrow$ \.{LEVELS\_YY}
\<level list>.

\LOG
\initials{LDF 2011.12.25.}
Added this rule.
\ENDLOG

@<Rules@>=

@=show_option:  LEVELS_YY level_list @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_option:  LEVELS_YY  "
             << "level_list'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->show_options |= 64U;

    @=$$@> = 0;

     

};

@q **** (4) level_list.  @>
@ \<level list>.
\initials{LDF 2011.12.25.}

@<Token and type declarations@>=

@=%type <int_value> level_list@>

@q **** (4) level_list:  /* Empty  */ @>

@ \<level list> $\longrightarrow$  \.{Empty}.
\initials{LDF 2011.12.25.}

\LOG
\initials{LDF 2011.12.25.}
Added this rule.
\ENDLOG

@<Rules@>=

@=level_list:  /* Empty  */ @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `level_list:  /* Empty  */'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 0;

     

};

@q **** (4) @>

@ \<level list> $\longrightarrow$  \<level list> \.{INTEGER\_YY} 
\.{INTEGER\_YY}. 
\initials{LDF 2011.12.25.}

\LOG
\initials{LDF 2011.12.25.}
Added this rule.
\ENDLOG

@<Rules@>=

@=level_list: level_list INTEGER_YY INTEGER_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `level_list: level_list INTEGER_YY INTEGER_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 0;

    param->show_level_map.insert(make_pair(@=$2@>, @=$3@>));

     

};

@q **** (4) @>

@ \<level list> $\longrightarrow$  \<level list> 
\.{INTEGER\_YY} \.{INTEGER\_YY} \.{SEMI\_COLON\_YY}.
\initials{LDF 2011.12.25.}

\LOG
\initials{LDF 2011.12.25.}
Added this rule.
\ENDLOG

@<Rules@>=

@=level_list: level_list INTEGER_YY INTEGER_YY SEMI_COLON_YY@>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `level_list: level_list INTEGER_YY "
             << "INTEGER_YY SEMI_COLON_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 0;

    param->show_level_map.insert(make_pair(@=$2@>, @=$3@>));

     

};

@q **** (4) @>

@ \<level list> $\longrightarrow$  \<level list> 
\.{INTEGER\_YY} \.{INTEGER\_YY} \.{SLASH\_YY}.
\initials{LDF 2011.12.25.}

\LOG
\initials{LDF 2011.12.25.}
Added this rule.
\ENDLOG

@<Rules@>=

@=level_list: level_list INTEGER_YY INTEGER_YY SLASH_YY@>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `level_list: level_list INTEGER_YY "
             << "INTEGER_YY SLASH_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 0;

    param->show_level_map.insert(make_pair(@=$2@>, @=$3@>));

     

};

@q **** (4) statement:  SHOW_YY CERTIFICATE_YY USER_YY html_optional @>

@ \<statement> $\longrightarrow$ \.{SHOW\_YY} \.{CERTIFICATE\_YY} 
\.{USER\_YY} \<html optional>.
\initials{LDF 2010.10.27.}

\LOG
\initials{LDF 2010.10.27.}
Added this rule.

\initials{LDF 2010.11.04.}
Added \<html optional>.
\ENDLOG

@<Rules@>=

@=statement: SHOW_YY CERTIFICATE_YY USER_YY html_optional@> 
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  SHOW_YY CERTIFICATE_YY "
             << "USER_YY html_optional'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    Response_Type response;
 
    response.type = Response_Type::SHOW_CERTIFICATES_TYPE;
    response.certificate_user  = true;

    response.output_format = @=$4@>;

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

};

@q **** (4) statement:  SHOW_YY CERTIFICATES_YY ALL_YY html_optional@>

@ \<statement> $\longrightarrow$ \.{SHOW\_YY} \.{CERTIFICATES\_YY} 
\.{ALL\_YY} \<html optional>.
\initials{LDF 2010.10.27.}

\LOG
\initials{LDF 2010.10.27.}
Added this rule.

\initials{LDF 2010.11.04.}
Added \<html optional>.
\ENDLOG

@<Rules@>=

@=statement: SHOW_YY CERTIFICATES_YY ALL_YY html_optional@> 
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  SHOW_YY CERTIFICATES_YY "
             << "ALL_YY html_optional'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    Response_Type response;
 
    response.type = Response_Type::SHOW_CERTIFICATES_TYPE;
    response.certificates_all  = true;
    response.output_format = @=$4@>;

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

};

@q **** (4) html_optional  @>
@ \<html optional>.

\LOG
\initials{LDF 2010.09.23.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> html_optional@>

@q **** (4) html_optional:  /* Empty  */  @>

@ \<html optional> $\longrightarrow$ \.{Empty}.
\initials{LDF 2010.09.23.}

\LOG
\initials{LDF 2010.09.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=html_optional:  /* Empty  */  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `html_optional:  /* Empty  */.'"
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = Response_Type::OUTPUT_FORMAT_PLAIN_TEXT;

};

@q **** (4) html_optional:  HTML_YY  @>

@ \<html optional> $\longrightarrow$ \.{HTML\_YY}.
\initials{LDF 2010.09.23.}

\LOG
\initials{LDF 2010.09.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=html_optional:  HTML_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `html_optional:  "
             << "HTML_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = Response_Type::OUTPUT_FORMAT_HTML;

};

@q **** (4) statement:  SHOW_YY ENVIRONMENT_YY SHELLSCRIPTS_YY @>
@q **** (4) show_environment_shellscript_option_list           @>

@ \<statement> $\longrightarrow$ \.{SHOW\_YY} 
\.{ENVIRONMENT\_YY} \.{SHELLSCRIPTS\_YY} \.{USER\_YY} 
\<show environment shellscript option list>.
\initials{LDF 2012.03.21.}

\LOG
\initials{LDF 2012.03.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SHOW_YY ENVIRONMENT_YY SHELLSCRIPTS_YY @>@/
@=show_environment_shellscript_option_list@>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  SHOW_YY ENVIRONMENT_YY SHELLSCRIPTS_YY "
             << "show_environment_shellscript_option_list'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    Response_Type response;
 
    response.type = Response_Type::SHOW_ENVIRONMENT_SHELLSCRIPTS_TYPE;
 
    response.show_environment_shellscript_options 
       = param->show_environment_shellscript_options;

    response.globus_site_set = param->show_environment_shellscript_globus_site_set;

    param->show_environment_shellscript_globus_site_set.clear();

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

    param->show_environment_shellscript_options = 0;

     

};

@q **** (4) show_environment_shellscript_option_list and  @>
@q **** (4) show_environment_shellscript_option @>

@ \<show environment shellscript option list> and 
\<show environment shellscript option>.

\LOG
\initials{LDF 2012.03.21.}
Added these type declarations.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> show_environment_shellscript_option_list@>
@=%type <int_value> show_environment_shellscript_option@>

@q **** (4) show_environment_shellscript_option_list:  /* Empty  */  @>

@ \<show environment shellscript option list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2012.03.21.}

\LOG
\initials{LDF 2012.03.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=show_environment_shellscript_option_list:  /* Empty  */  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_environment_shellscript_option_list:  /* Empty  */.'"
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->show_environment_shellscript_options = 0;
    param->show_environment_shellscript_globus_site_set.clear();

    @=$$@> = 0;

     

};

@q **** (4) show_environment_shellscript_option_list: @>
@q **** (4) show_environment_shellscript_option_list  @>
@q **** (4) show_environment_shellscript_option       @>

@ \<show environment shellscript option list> $\longrightarrow$ 
\<show environment shellscript option>.
\initials{LDF 2012.03.21.}

\LOG
\initials{LDF 2012.03.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=show_environment_shellscript_option_list:  show_environment_shellscript_option_list @>@/
@=show_environment_shellscript_option@>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_environment_shellscript_option_list:  "
             << "show_environment_shellscript_option_list show_environment_shellscript_option'.'"
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 0;

    

};

@q **** (4) show_environment_shellscript_option:  USER_YY  @>

@ \<show environment shellscript option> $\longrightarrow$ \.{USER\_YY}.
\initials{LDF 2012.03.21.}

\LOG
\initials{LDF 2012.03.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=show_environment_shellscript_option:  USER_YY  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_environment_shellscript_option:  USER_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->show_environment_shellscript_options |= 1U;

    @=$$@> = 0;

     

};

@q **** (4) show_environment_shellscript_option:  GLOBUS_SITE_YY STRING_YY @>

@ \<show environment shellscript option> $\longrightarrow$ \.{GLOBUS\_SITE\_YY}
\.{STRING\_YY}.
\initials{LDF 2012.03.21.}

\LOG
\initials{LDF 2012.03.21.}
Added this rule.

\initials{LDF 2012.03.26.}
Added code for unsetting the |GLOBUS_SITES_YY ALL_YY| option, if it
has been set previously.
\ENDLOG

@:TODO@> !! TODO:  Maybe use a vector in order to make it possible to show
the ``environment shellscripts'' for several Globus sites.
\initials{LDF 2012.03.26.}

@<Rules@>=

@=show_environment_shellscript_option:  GLOBUS_SITE_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_environment_shellscript_option:  "
             << "GLOBUS_SITE_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    /* If the |GLOBUS_SITES_YY ALL_YY| option has been set previously,
       unset it.  \initials{LDF 2012.03.26.}  */

    param->show_environment_shellscript_options &= ~4U;

    param->show_environment_shellscript_options |= 2U;
    param->show_environment_shellscript_globus_site_set.insert(@=$2@>);

    @=$$@> = 0;

     

};

@q **** (4) show_environment_shellscript_option:  GLOBUS_SITES_YY ALL_YY @>

@ \<show environment shellscript option> $\longrightarrow$ \.{GLOBUS\_SITES\_YY}
\.{ALL\_YY}.
\initials{LDF 2012.03.21.}

\LOG
\initials{LDF 2012.03.21.}
Added this rule.

\initials{LDF 2012.03.26.}
Added code for unsetting the |GLOBUS_SITE_YY STRING_YY| option
and |param->show_environment_shellscript_globus_site|, if the former 
has been set previously.
\ENDLOG

@<Rules@>=

@=show_environment_shellscript_option:  GLOBUS_SITES_YY ALL_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `show_environment_shellscript_option:  "
             << "GLOBUS_SITES_YY ALL_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    /* If the |GLOBUS_SITE_YY STRING_YY| option has been set previously,
       unset it and clear |param->show_environment_shellscript_globus_site_set|.  
       \initials{LDF 2012.03.26.}  */

    param->show_environment_shellscript_options &= ~2U;

    param->show_environment_shellscript_globus_site_set.clear();

    param->show_environment_shellscript_options |= 4U;

    @=$$@> = 0;

     

};

@q **** (4) statement:  ENABLE_YY ENVIRONMENT_YY SHELLSCRIPT_YY INTEGER_YY  @>

@ \<statement> $\longrightarrow$ \.{ENABLE\_YY} 
\.{ENVIRONMENT\_YY} \.{SHELLSCRIPT\_YY} \.{INTEGER\_ZZ}.
\initials{LDF 2012.03.26.}

\LOG
\initials{LDF 2012.03.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: ENABLE_YY ENVIRONMENT_YY SHELLSCRIPT_YY INTEGER_YY@>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  ENABLE_YY ENVIRONMENT_YY SHELLSCRIPT_YY "
             << "INTEGER_YY'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

#if HAVE_LIBMYSQLCLIENT   

    int status = param->enable_environment_shellscript(@=$4@>);

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  ENABLE_YY ENVIRONMENT_YY SHELLSCRIPT_YY "
             << "INTEGER_YY':" 
             << endl
             << "`Scan_Parse_Parameter_Type::enable_environment_shellscript' "
             << "returned " << status << "."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

#endif /* |HAVE_LIBMYSQLCLIENT|  */

     

};

@q **** (4) statement:  DISABLE_YY ENVIRONMENT_YY SHELLSCRIPT_YY INTEGER_YY  @>

@ \<statement> $\longrightarrow$ \.{DISABLE\_YY} 
\.{ENVIRONMENT\_YY} \.{SHELLSCRIPT\_YY} \.{INTEGER\_ZZ}.
\initials{LDF 2012.03.26.}

\LOG
\initials{LDF 2012.03.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DISABLE_YY ENVIRONMENT_YY SHELLSCRIPT_YY INTEGER_YY@>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  DISABLE_YY ENVIRONMENT_YY SHELLSCRIPT_YY "
             << "INTEGER_YY'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

#if HAVE_LIBMYSQLCLIENT   

    /* |true| is the |disable_flag| argument 
       to |Scan_Parse_Parameter_Type::enable_environment_shellscript|.
       \initials{LDF 2012.03.26.}  */

    int status = param->enable_environment_shellscript(@=$4@>, true);

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  DISABLE_YY ENVIRONMENT_YY SHELLSCRIPT_YY "
             << "INTEGER_YY':" 
             << endl
             << "`Scan_Parse_Parameter_Type::enable_environment_shellscript' "
             << "returned " << status << "."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

#endif /* |HAVE_LIBMYSQLCLIENT|  */

     

};

@q **** (4) statement --> CLIENT_YY RECEIVE_YY ENTRY_YY INFO_YY SUCCEEDED_YY @>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{RECEIVE\_YY} \.{ENTRY\_YY} \.{INFO\_YY} 
\.{SUCCEEDED\_YY}.
\initials{LDF 2010.05.26.}

\LOG
\initials{LDF 2010.05.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  CLIENT_YY RECEIVE_YY ENTRY_YY INFO_YY SUCCEEDED_YY@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: CLIENT_YY RECEIVE_YY ENTRY_YY INFO_YY SUCCEEDED_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

};

@q **** (4) statement --> CLIENT_YY RECEIVE_YY ENTRY_YY INFO_YY FAILED_YY @>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{RECEIVE\_YY} \.{ENTRY\_YY} \.{INFO\_YY} 
\.{FAILED\_YY}.
\initials{LDF 2010.05.26.}

\LOG
\initials{LDF 2010.05.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  CLIENT_YY RECEIVE_YY ENTRY_YY INFO_YY FAILED_YY@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: CLIENT_YY RECEIVE_YY ENTRY_YY INFO_YY FAILED_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

};

@q **** (4) statement --> SET_YY EFFECTIVE_USER_YY STRING_YY.  @>

@ \<statement> $\longrightarrow$ \.{SET\_YY} \.{EFFECTIVE\_USER\_YY} 
\.{STRING\_YY}.
\initials{LDF 2010.06.30.}

\LOG
\initials{LDF 2010.06.30.}
Added this rule.

\initials{LDF 2010.07.02.}
Added code for resetting the ``effective user''.
This can be done if and only if the current "effective user" can act as a delegate.
This in turn is determined by the \.{delegate} field of the \.{Users} table in 
the database.
\ENDLOG

@<Rules@>=

@=statement: SET_YY EFFECTIVE_USER_YY STRING_YY@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    int status;

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "`SET_YY EFFECTIVE_USER_YY STRING_YY'."
             << endl;

        cerr << "param->user_id == " << param->user_id << endl
             << "param->user_name == " << param->user_name << endl
             << "param->effective_user_id == " << param->effective_user_id << endl
             << "param->effective_user_dn == " << param->effective_user_dn << endl
             << "param->effective_user_name == " << param->effective_user_name << endl
             << "$3 == " << @=$3@> << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */

@q ***** (5) @>
@
\LOG
\initials{LDF 2010.07.02.}
Added this section.
\ENDLOG

@<Rules@>=

    if (   !(   param->effective_user_id <= 0 
             && param->effective_user_dn.empty()
             && param->effective_user_name.empty())
        && param->effective_user_dn == @=$3@>)
    {
@q ****** (6) @>

        lock_cerr_mutex();
        cerr << get_datestamp() << " [Thread " << param->thread_ctr 
             << "] WARNING!  In `yyparse':  Rule `statement:  "
             << "`SET_YY EFFECTIVE_USER_YY STRING_YY':"
             << endl 
             << "(STRING_YY == param->effective_user_dn) == " 
             << (@=$3@> == param->effective_user_dn)
             << endl 
             << "`STRING_YY' == " << @=$3@>
             << endl 
             << "`param->effective_user_dn' == " << param->effective_user_dn
             << endl 
             << "\"Effective user\" has already been set to this user.  "
             << "Ignoring and continuing."
             << endl;
        unlock_cerr_mutex(); 

     }  /* |if|  */

@q ***** (5) @>
@
@<Rules@>=

    else
    {

#if HAVE_LIBMYSQLCLIENT   

@q ****** (6) @>

        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << param->thread_ctr 
                 << "] In `yyparse':  Rule `statement:  "
                 << "`SET_YY EFFECTIVE_USER_YY STRING_YY':"
                 << endl 
                 << "param->user_name == " << param->user_name 
                 << endl
                 << "param->user_id == " << param->user_id 
                 << endl
                 << "$3 == " << @$3@> 
                 << endl
                 << "About to call `Scan_Parse_Parameter_Type::check_delegation'."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */

@q ****** (6) @>

        status = param->check_delegation(@=$3@>);

        if (status != 0)
        {
            lock_cerr_mutex();
            cerr << get_datestamp() << " [Thread " << param->thread_ctr 
                 << "] ERROR!  In `yyparse':  Rule `statement:  "
                 << "`SET_YY EFFECTIVE_USER_YY STRING_YY':"
                 << endl 
                 << "`Scan_Parse_Parameter_Type::check_delegation' failed, returning "
                 << status 
                 << endl
                 << "Sending failure message to client, clearing `param->entries' "
                 << "and exiting `yyparse' with return value 2."
                 << endl;
            unlock_cerr_mutex(); 

            param->entries.clear();

            return 2;

        }  /* |if (status != 0)|  */

@q ***** (5) @>
@
\LOG
\initials{LDF 2012.05.23.}
Added this section.
\ENDLOG

@<Rules@>=

        Response_Type response;
        response.type = Response_Type::COMMAND_ONLY_TYPE;

        response.command = "SET EFFECTIVE_USER SUCCEEDED";

        pthread_mutex_lock(&param->response_deque_mutex);
        param->response_deque.push_front(response);
        pthread_mutex_unlock(&param->response_deque_mutex);

@q ***** (5) @>
@
@<Rules@>=

        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << param->thread_ctr 
                 << "] In `yyparse':  Rule `statement:  "
                 << "`SET_YY EFFECTIVE_USER_YY STRING_YY':"
                 << endl 
                 << "`Scan_Parse_Parameter_Type::check_delegation' succeeded, "
                 << "returning 0."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)| (|status == 0|) */
   
@q ***** (5) @>

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

         

@q ***** (5) @>

    }  /* |else|  */

};

@q **** (4) statement --> ADD_YY installation_script STRING_YY  @>
@q **** (4) TO_YY ENTRY_YY entry_string_list                       @>

@ \<statement> $\longrightarrow$ \.{ADD\_YY} \<installation script> 
\.{STRING\_YY} \.{TO\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2010.09.30.}

\LOG
\initials{LDF 2010.09.30.}
Added this rule.

\initials{LDF 2010.10.06.}
Added error-handling code for the case that \<entry string list> is empty.

\initials{LDF 2011.05.25.}
Changed \.{INSTALLATION\_SCRIPT\_YY} to \<installation script>.  Now passing its
value to |Scan_Parse_Parameter_Type::add_installation_script|.

\initials{LDF 2011.06.08.}
@:BUG FIX@> BUG FIX:  Replaced |@=2@>| with |@=$2@>| in the call to 
|Scan_Parse_Parameter_Type::add_installation_script| (fourth argument).
\ENDLOG

@<Rules@>=

@=statement: ADD_YY installation_script STRING_YY @>@/
@=TO_YY ENTRY_YY entry_string_list@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    int status;

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "`ADD_YY installation_script STRING_YY "
             << "TO_YY ENTRY_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT   

    string curr_filename = @=$3@>;

    string curr_package_name;

    string curr_package_version;

    if (param->entry_string_vector.size() > 0)
       curr_package_name = param->entry_string_vector[0];
    else
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  Rule `statement:  "
             << "`ADD_YY installation_script STRING_YY "
             << "TO_YY ENTRY_YY entry_string_list':"
             << endl
             << "`param'->entry_string_vector.size() == 0.  Can't add "
             << "installation script."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex();

        goto ADD_INST_SCRIPT_RULE_END;

    }

    if (param->entry_string_vector.size() > 1)
       curr_package_version = param->entry_string_vector[1];

    param->entry_string_vector.clear();

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "`ADD_YY installation_script STRING_YY "
             << "TO_YY ENTRY_YY entry_string_list':"
             << endl
             << "`curr_filename' == " << curr_filename
             << endl 
             << "`curr_package_name' == " << curr_package_name
             << endl 
             << "`curr_package_version' == " << curr_package_version
             << endl; 
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */
  

    status = param->add_installation_script(curr_filename, 
                                            curr_package_name, 
                                            curr_package_version,
                                            @=$2@>);

    if (status != 0)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  Rule `statement:  "
             << "`ADD_YY installation_script STRING_YY "
             << "TO_YY ENTRY_YY entry_string_list':"
             << endl
             << "`Scan_Parse_Parameter_Type::add_installation_script' failed, "
             << "returning " << status << "."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (status != 0)|  */
 
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "`ADD_YY installation_script STRING_YY "
             << "TO_YY ENTRY_YY entry_string_list':"
             << endl
             << "`Scan_Parse_Parameter_Type::add_installation_script' succeeded."
             << endl;
        unlock_cerr_mutex();

    }  /* |else if (param->PARSER_DEBUG)|  */

    ADD_INST_SCRIPT_RULE_END: 
    ;

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) @>

};

@q **** (4) installation_script.  @>

@ \<installation script>.
\initials{LDF 2011.04.21.}

\LOG
\initials{LDF 2011.04.21.}
Added this section.
\ENDLOG

@<Token and type declarations@>=
@=%type <int_value> installation_script@>

@q **** (4) @>
@
\LOG
\initials{LDF 2011.04.21.}
Added this section.
\ENDLOG

@<Rules@>=
@=installation_script: INSTALLATION_SCRIPT_YY@>
{
     
   @=$$@> = 0;

};

@q **** (4) @>
@
\LOG
\initials{LDF 2011.03.31.}
Added this section.
\ENDLOG

@<Rules@>=
@=installation_script: INSTALLATION_SCRIPT_ENCRYPTED_YY@>
{
   @=$$@> = 1;

};

@q **** (4) statement --> ADD_YY download_info STRING_YY  @>
@q **** (4) TO_YY ENTRY_YY entry_string_list              @>

@ \<statement> $\longrightarrow$ \.{ADD\_YY} \<download info> 
\.{STRING\_YY} \.{TO\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2011.06.08.}

\LOG
\initials{LDF 2011.06.08.}
Added this rule.

\initials{LDF 2011.10.31.}
Changed \<download info encrypted> to \<download info>.  Modified code to account
for non-encrypted download information. 
\ENDLOG

@<Rules@>=

@=statement: ADD_YY download_info STRING_YY @>@/
@=TO_YY ENTRY_YY entry_string_list@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    int status;

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "`ADD_YY download_info STRING_YY "
             << "TO_YY ENTRY_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */

@q ***** (5) @>

#if HAVE_LIBMYSQLCLIENT   

    string curr_string = @=$3@>;

    string curr_package_name;

    string curr_package_version;

@q ***** (5) @>

    if (param->entry_string_vector.size() > 0)
    {
@q ****** (6) @>
       curr_package_name = param->entry_string_vector[0];

       if (param->entry_string_vector.size() > 1)
          curr_package_version = param->entry_string_vector[1];

       param->entry_string_vector.clear();

@q ****** (6) @>

       if (param->PARSER_DEBUG)
       {
           lock_cerr_mutex();
           cerr << "[Thread " << param->thread_ctr 
                << "] In `yyparse':  Rule `statement:  "
                << "`ADD_YY download_info STRING_YY "
                << "TO_YY ENTRY_YY entry_string_list':"
                << endl
                << "`curr_string' == " << curr_string
                << endl 
                << "`curr_package_name' == " << curr_package_name
                << endl 
                << "`curr_package_version' == " << curr_package_version
                << endl; 
           unlock_cerr_mutex();

       }  /* |if (param->PARSER_DEBUG)| */
  

@q ****** (6) @>

       status = param->add_download_info(curr_string, 
                                         curr_package_name, 
                                         curr_package_version,
                                         @=$2@>);
@q ****** (6) @>

       if (status != 0)
       {
           lock_cerr_mutex();
           cerr << "[Thread " << param->thread_ctr 
                << "] ERROR!  In `yyparse':  Rule `statement:  "
                << "`ADD_YY download_info STRING_YY "
                << "TO_YY ENTRY_YY entry_string_list':"
                << endl
                << "`Scan_Parse_Parameter_Type::add_download_info' failed, "
                << "returning " << status << "."
                << endl
                << "Continuing."
                << endl;
           unlock_cerr_mutex();

       }  /* |if (status != 0)|  */
 
@q ****** (6) @>

       else if (param->PARSER_DEBUG)
       {
           lock_cerr_mutex();
           cerr << "[Thread " << param->thread_ctr 
                << "] In `yyparse':  Rule `statement:  "
                << "`ADD_YY download_info STRING_YY "
                << "TO_YY ENTRY_YY entry_string_list':"
                << endl
                << "`Scan_Parse_Parameter_Type::add_download_info' succeeded."
                << endl;
           unlock_cerr_mutex();

       }  /* |else if (param->PARSER_DEBUG)|  */

@q ****** (6) @>

    }  /* |if (param->entry_string_vector.size() > 0)|  */

@q ***** (5) @>

    else
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  Rule `statement:  "
             << "`ADD_YY download_info STRING_YY "
             << "TO_YY ENTRY_YY entry_string_list':"
             << endl
             << "`param'->entry_string_vector.size() == 0.  Can't add "
             << "download info encrypted."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex();

    }

@q ***** (5) @>

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

     

};

@q **** (4) download_info and download_info_encrypted.  @>

@ \<download info> and \<download info encrypted>.
\initials{LDF 2011.04.21.}

\LOG
\initials{LDF 2011.04.21.}
Added this section.

\initials{LDF 2011.10.31.}
Added type declaration for \<download info>.
\ENDLOG

@<Token and type declarations@>=
@=%type <int_value> download_info@>
@=%type <int_value> download_info_encrypted@>

@q **** (4) download_info: DOWNLOAD_URL_YY.  @>

@ \<download info encrypted> $\longrightarrow$ \.{DOWNLOAD\_URL\_YY}.
\initials{LDF 2011.10.31.}

\LOG
\initials{LDF 2011.10.31.}
Added this section.
\ENDLOG

@<Rules@>=
@=download_info: DOWNLOAD_URL_YY@>
{

   @=$$@> = Response_Type::DOWNLOAD_URL_TYPE;

};

@q **** (4) download_info: DOWNLOAD_COMMAND_YY.  @>

@ \<download info encrypted> $\longrightarrow$ \.{DOWNLOAD\_COMMAND\_YY}.
\initials{LDF 2011.10.31.}

\LOG
\initials{LDF 2011.10.31.}
Added this section.
\ENDLOG

@<Rules@>=
@=download_info: DOWNLOAD_COMMAND_YY@>
{

   @=$$@> = Response_Type::DOWNLOAD_COMMAND_TYPE;

};

@q **** (4) download_info: download_info_encrypted.  @>

@ \<download info encrypted> $\longrightarrow$ \<download info encrypted>.
\initials{LDF 2011.10.31.}

\LOG
\initials{LDF 2011.10.31.}
Added this section.
\ENDLOG

@<Rules@>=
@=download_info: download_info_encrypted@>
{

   @=$$@> = @=$1@>;

};

@q **** (4) download_info_encrypted: DOWNLOAD_URL_ENCRYPTED_YY.  @>

@ \<download info encrypted> $\longrightarrow$ \.{DOWNLOAD\_URL\_ENCRYPTED\_YY}.
\initials{LDF 2011.04.21.}

\LOG
\initials{LDF 2011.04.21.}
Added this section.

\initials{LDF 2011.10.31.}
Now setting |@=$$@>| to |Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE|.
\ENDLOG

@<Rules@>=
@=download_info_encrypted: DOWNLOAD_URL_ENCRYPTED_YY@>
{
     

   @=$$@> = Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE;

};

@q **** (4) download_info_encrypted: DOWNLOAD_COMMAND_ENCRYPTED_YY.  @>

@ \<download info encrypted> $\longrightarrow$ \.{DOWNLOAD\_COMMAND\_ENCRYPTED\_YY}.
\initials{LDF 2011.04.21.}

\LOG
\initials{LDF 2011.04.21.}
Added this section.

\initials{LDF 2011.10.31.}
Now setting |@=$$@>| to |Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE|.
\ENDLOG

@<Rules@>=
@=download_info_encrypted: DOWNLOAD_COMMAND_ENCRYPTED_YY@>
{

   @=$$@> = Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE;

};

@q **** (4) statement --> ADD_YY AUTHORIZATION_YY STRING_YY  @>
@q **** (4) TO_YY ENTRY_YY entry_string_list                 @>

@ \<statement> $\longrightarrow$ \.{ADD\_YY} \.{AUTHORIZATION\_YY}
\.{STRING\_YY} \.{TO\_YY} \.{ENTRY\_YY} \<entry string list>.
\initials{LDF 2011.11.22.}

\LOG
\initials{LDF 2011.11.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: ADD_YY AUTHORIZATION_YY STRING_YY @>@/
@=TO_YY ENTRY_YY entry_string_list @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    int status;

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "`ADD_YY AUTHORIZATION_YY STRING_YY "
             << "TO_YY ENTRY_YY entry_string_list'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */

@q ***** (5) @>

#if HAVE_LIBMYSQLCLIENT   

    string curr_string = @=$3@>;

    string curr_package_name;

    string curr_package_version;

@q ***** (5) @>

    if (param->entry_string_vector.size() > 0)
    {
@q ****** (6) @>
       curr_package_name = param->entry_string_vector[0];

       if (param->entry_string_vector.size() > 1)
          curr_package_version = param->entry_string_vector[1];

       param->entry_string_vector.clear();

@q ****** (6) @>

       if (param->PARSER_DEBUG)
       {
           lock_cerr_mutex();
           cerr << "[Thread " << param->thread_ctr 
                << "] In `yyparse':  Rule `statement:  "
                << "`ADD_YY AUTHORIZATION_YY STRING_YY "
                << "TO_YY ENTRY_YY entry_string_list':"
                << endl
                << "`curr_string' == " << curr_string
                << endl 
                << "`curr_package_name' == " << curr_package_name
                << endl 
                << "`curr_package_version' == " << curr_package_version
                << endl; 
           unlock_cerr_mutex();

       }  /* |if (param->PARSER_DEBUG)| */
  

@q ****** (6) @>

       status = param->add_authorization(curr_string, 
                                         curr_package_name, 
                                         curr_package_version);

@q ****** (6) @>

       if (status != 0)
       {
           lock_cerr_mutex();
           cerr << "[Thread " << param->thread_ctr 
                << "] ERROR!  In `yyparse':  Rule `statement:  "
                << "`ADD_YY AUTHORIZATION_YY STRING_YY "
                << "TO_YY ENTRY_YY entry_string_list':"
                << endl
                << "`Scan_Parse_Parameter_Type::add_authorization' failed, "
                << "returning " << status << "."
                << endl
                << "Continuing."
                << endl;
           unlock_cerr_mutex();

       }  /* |if (status != 0)|  */
 
@q ****** (6) @>

       else if (param->PARSER_DEBUG)
       {
           lock_cerr_mutex();
           cerr << "[Thread " << param->thread_ctr 
                << "] In `yyparse':  Rule `statement:  "
                << "`ADD_YY AUTHORIZATION_YY STRING_YY "
                << "TO_YY ENTRY_YY entry_string_list':"
                << endl
                << "`Scan_Parse_Parameter_Type::add_authorization' succeeded."
                << endl;
           unlock_cerr_mutex();

       }  /* |else if (param->PARSER_DEBUG)|  */

@q ****** (6) @>

    }  /* |if (param->entry_string_vector.size() > 0)|  */

@q ***** (5) @>

    else
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  Rule `statement:  "
             << "`ADD_YY AUTHORIZATION_YY STRING_YY "
             << "TO_YY ENTRY_YY entry_string_list':"
             << endl
             << "`param'->entry_string_vector.size() == 0.  Can't add "
             << "download info encrypted."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex();

    }

@q ***** (5) @>

#endif /* |#if HAVE_LIBMYSQLCLIENT|  */

     

};

@q **** (4) statement:  CLIENT_YY TO_YY TRANSFER_YY PROXY_CREDENTIAL_YY STRING_YY@>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{TO\_YY} 
\.{TRANSFER\_YY} \.{PROXY\_CREDENTIAL\_YY} \.{STRING\_YY}.
\initials{LDF 2011.09.29.}

\LOG
\initials{LDF 2011.09.29.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: CLIENT_YY TO_YY TRANSFER_YY PROXY_CREDENTIAL_YY STRING_YY @> 
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  CLIENT_YY TO_YY TRANSFER_YY "
             << "PROXY_CREDENTIAL_YY STRING_YY'." 
             << endl;

        cerr << "proxy credential filename:  " << @=$5@> << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    Response_Type response;

    response.remote_filename  = @=$5@>;
    response.type = Response_Type::PROXY_CREDENTIAL_TYPE;

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_front(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

     

};

@q **** (4) statement:  PROXY_CREDENTIAL_YY STRING_YY INVALID_YY CLIENT_YY @>
@q **** (4) NOT_YY TO_YY TRANSFER_YY @>

@ \<statement> $\longrightarrow$ \.{PROXY\_CREDENTIAL\_YY} \.{STRING\_YY} 
\.{INVALID\_YY} \.{CLIENT\_YY} \.{NOT\_YY} \.{TO\_YY} \.{TRANSFER\_YY}.
\initials{LDF 2011.10.27.}

\LOG
\initials{LDF 2011.10.27.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: PROXY_CREDENTIAL_YY STRING_YY INVALID_YY CLIENT_YY @>@/
@=NOT_YY TO_YY TRANSFER_YY@> 
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  PROXY_CREDENTIAL_YY "
             << "STRING_YY INVALID_YY CLIENT_YY "
             << "NOT_YY TO_YY TRANSFER_YY'."
             << endl
             << "proxy credential filename:  " << @=$2@> 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    lock_cerr_mutex(); 
    cerr << "proxy credential `" << @=$2@> << "' invalid.  Client not transferring."
         << endl;
    unlock_cerr_mutex(); 

     

};

@q **** (4) statement --> CLIENT_YY SENDING_YY PROXY_CREDENTIAL_YY. @>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{SENDING\_YY} 
 \.{PROXY\_CREDENTIAL\_YY}.
\initials{LDF 2011.09.26.}

\LOG
\initials{LDF 2011.09.26.}
Added this rule.

\initials{LDF 2011.09.29.}
Removed \.{STRING\_YY} from end of rule.  It's not needed.
\ENDLOG

@<Rules@>=

@=statement: CLIENT_YY SENDING_YY PROXY_CREDENTIAL_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;       

    stringstream temp_strm;

    string proxy_filename;
  
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "CLIENT_YY SENDING_YY PROXY_CREDENTIAL_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */

@q ***** (5) @>

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "CLIENT_YY SENDING_YY PROXY_CREDENTIAL_YY':"
             << endl
             << "Calling `accept_data'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */

@q ****** (6) @>

       int status = accept_data(param, 0, 0, Response_Type::PROXY_CREDENTIAL_TYPE, 
                                &proxy_filename);

       if (status == 0)
       {
           if (param->PARSER_DEBUG)
           {
               lock_cerr_mutex();
               cerr << "[Thread " << param->thread_ctr 
                    << "] In `yyparse':  Rule `statement:  "
                    << "CLIENT_YY SENDING_YY PROXY_CREDENTIAL_YY':"
                    << endl
                    << "`accept_data' succeeded, returning 0."
                    << endl;
               unlock_cerr_mutex();

           }  /* |if (param->PARSER_DEBUG)| */

           temp_strm << "RECEIVE PROXY_CREDENTIAL SUCCEEDED <" << proxy_filename << ">";
         
           response.command = temp_strm.str();

       }  /* |if (status == 0)| */

       else /* |status != 0|  */
       {
           lock_cerr_mutex();
           cerr << get_datestamp() << " [Thread " << param->thread_ctr 
                << "] WARNING!  In `yyparse':  "
                << "Rule `statement: CLIENT_YY SENDING_YY PROXY_CREDENTIAL_YY':"
                << endl
                << "`accept_data' failed, returning " << status
                << endl
                << "Will try to continue."
                << endl;
           unlock_cerr_mutex();

           temp_strm << "RECEIVE PROXY_CREDENTIAL FAILED";

           response.command = temp_strm.str();

       }  /* |else| (|status != 0|) */

@q ****** (6) @>

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_front(response);
    pthread_mutex_unlock(&param->response_deque_mutex);
 
     

@q ***** (5) @>

};

@q **** (4) @>

@
\LOG
\initials{LDF 2011.09.30.}
Added this section.

\initials{LDF 2011.10.23.}
Added type declaration for |timeout_optional|.

\initials{LDF 2012.02.03.}
Added type declaration for |reinstall_prerequisites_optional|.

\initials{LDF 2012.02.07.}
Added type declarations for |link_expression_list| and |link_expression|.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value>    install_or_reinstall@>@;@/
@=%type <string_value> package_version_optional@>@;@/
@=%type <string_value> stdout_filename_optional@>@;@/
@=%type <string_value> stderr_filename_optional@>@;@/
@=%type <int_value>    timeout_optional@>@;@/
@=%type <int_value>    reinstall_prerequisites_optional@>@;@/
@=%type <string_value> link_expression_list@>@;@/
@=%type <string_value> link_expression@>@;

@q **** (4) install_or_reinstall: INSTALL_YY @>
@
\LOG
\initials{LDF 2011.09.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=install_or_reinstall: INSTALL_YY  @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `install_or_reinstall: INSTALL_YY'. "
             << endl;
        unlock_cerr_mutex();
    }

    @=$$@> = 0;

};

@q **** (4) install_or_reinstall: REINSTALL_YY  @>
@
\LOG
\initials{LDF 2011.09.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=install_or_reinstall: REINSTALL_YY  @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `install_or_reinstall: REINSTALL_YY'. "
             << endl;
        unlock_cerr_mutex();
    }

    @=$$@> = 1;

};

@q **** (4) package_version_optional: /* Empty */ @>
@
\LOG
\initials{LDF 2011.09.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=package_version_optional: /* Empty */  @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `package_version_optional: /* Empty */'. "
             << endl;
        unlock_cerr_mutex();
    }

    strcpy(@=$$@>, "");

};

@q **** (4) package_version_optional: PACKAGE_VERSION_YY STRING_YY @>
@
\LOG
\initials{LDF 2011.09.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=package_version_optional: PACKAGE_VERSION_YY STRING_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `package_version_optional: PACKAGE_VERSION_YY STRING_YY'. "
             << endl;
        unlock_cerr_mutex();
    }

    strcpy(@=$$@>, @=$2@>);

};

@q **** (4) stdout_filename_optional: /* Empty */ @>
@
\LOG
\initials{LDF 2011.09.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=stdout_filename_optional: /* Empty */  @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `stdout_filename_optional: /* Empty */'. "
             << endl;
        unlock_cerr_mutex();
    }

    strcpy(@=$$@>, "");

};

@q **** (4) stdout_filename_optional: STDOUT_FILENAME_YY STRING_YY @>
@
\LOG
\initials{LDF 2011.09.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=stdout_filename_optional: STDOUT_FILENAME_YY STRING_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `stdout_filename_optional: STDOUT_FILENAME_YY STRING_YY'. "
             << endl;
        unlock_cerr_mutex();
    }

    strcpy(@=$$@>, @=$2@>);

};

@q **** (4) stderr_filename_optional: /* Empty */ @>
@
\LOG
\initials{LDF 2011.09.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=stderr_filename_optional: /* Empty */  @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `stderr_filename_optional: /* Empty */'. "
             << endl;
        unlock_cerr_mutex();
    }

    strcpy(@=$$@>, "");

};

@q **** (4) stderr_filename_optional: STDERR_FILENAME_YY STRING_YY @>
@
\LOG
\initials{LDF 2011.09.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=stderr_filename_optional: STDERR_FILENAME_YY STRING_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `stderr_filename_optional: STDERR_FILENAME_YY STRING_YY'. "
             << endl;
        unlock_cerr_mutex();
    }

    strcpy(@=$$@>, @=$2@>);

};

@q **** (4) timeout_optional: /* Empty */ @>

@ \<timeout optional> $\longrightarrow$ \.{Empty}.
\initials{LDF 2011.10.23.}

\LOG
\initials{LDF 2011.10.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=timeout_optional: /* Empty */  @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `timeout_optional: /* Empty */'. "
             << endl;
        unlock_cerr_mutex();
    }

    @=$$@> = 0;

};

@q **** (4) timeout_optional: TIMEOUT_YY INTEGER_YY @>

@ \<timeout optional> $\longrightarrow$ \.{TIMEOUT\_YY} \.{INTEGER\_YY}.
\initials{LDF 2011.10.23.}

\LOG
\initials{LDF 2011.10.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=timeout_optional: TIMEOUT_YY INTEGER_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `timeout_optional: TIMEOUT_YY INTEGER_YY'. "
             << endl;
        unlock_cerr_mutex();
    }

    @=$$@> = @=$2@>;

};

@q **** (4) reinstall_prerequisites_optional: /* Empty */ @>

@ \<reinstall prerequisites optional> $\longrightarrow$ \.{Empty}.

\LOG
\initials{LDF 2012.02.03.}
Added this rule.
\ENDLOG

@<Rules@>=

@=reinstall_prerequisites_optional: /* Empty */  @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `reinstall_prerequisites_optional: /* Empty */'. "
             << endl;
        unlock_cerr_mutex();
    }

    @=$$@> = 0;

};

@q **** (4) reinstall_prerequisites_optional: REINSTALL_YY PREREQUISITES_YY @>

@ \<reinstall prerequisites optional> $\longrightarrow$ \.{REINSTALL\_YY} \.{PREREQUISITES\_YY}.

\LOG
\initials{LDF 2012.02.03.}
Added this rule.
\ENDLOG

@<Rules@>=

@=reinstall_prerequisites_optional: REINSTALL_YY PREREQUISITES_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `reinstall_prerequisites_optional: "
             << "REINSTALL_YY PREREQUISITES_YY'. "
             << endl;
        unlock_cerr_mutex();
    }

    @=$$@> = 1;

};

@q **** (4) reinstall_prerequisites_optional: NO_YY REINSTALL_YY PREQUISITES_YY @>

@ \<reinstall prerequisites optional> $\longrightarrow$ 
\.{NO\_YY} \.{REINSTALL\_YY} \.{PREREQUISITES\_YY}.

\LOG
\initials{LDF 2012.02.03.}
Added this rule.
\ENDLOG

@<Rules@>=

@=reinstall_prerequisites_optional: NO_YY REINSTALL_YY PREREQUISITES_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `reinstall_prerequisites_optional: NO_YY "
             << "REINSTALL_YY PREREQUISITES_YY'. "
             << endl;
        unlock_cerr_mutex();
    }

    @=$$@> = -1;

};

@q **** (4) link_expression_list: /* Empty */ @>

@ \<link expression list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2012.02.07.}

\LOG
\initials{LDF 2012.02.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=link_expression_list: /* Empty */  @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `link_expression_list: /* Empty */'. "
             << endl;
        unlock_cerr_mutex();
    }

    strcpy(@=$$@>, "");

};

@q **** (4) link_expression_list: link_expression_list link_expression @>

@ \<link expression list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2012.02.07.}

\LOG
\initials{LDF 2012.02.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=link_expression_list: link_expression_list link_expression @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `link_expression_list: link_expression_list link_expression'. "
             << endl;
        unlock_cerr_mutex();
    }

    if (strlen(@=$2@>) > 0 && strcmp(@=$2@>, "1") != 0 && strcmp(@=$1@>, "0") == 0)
    {
        cerr << "[Thread " << param->thread_ctr 
             << "] WARNING:  In `yyparse':  `link_expression_list: link_expression_list "
             << "link_expression':"
             << endl
             << "`WITH_LINK_DIRECTORY' specified after `NO_LINKS'.  This doesn't make sense."
             << endl 
             << "Not setting link directory."
             << endl
             << "Continuing."
             << endl;
    }
    else if (strlen(@=$1@>) > 0 && strcmp(@=$1@>, "0") != 0 && strcmp(@=$2@>, "1") == 0)
    {
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << param->thread_ctr 
                 << "] In `yyparse':  `link_expression_list: link_expression_list "
                 << "link_expression':"
                 << endl
                 << "`WITH_LINKS' followed `LINK_DIRECTORY'."
                 << endl 
                 << "Setting `$$' to `" << @=$1@> << "', "
                 << "i.e., not resetting to `" << @=$2@> << "'."
                 << endl;
            unlock_cerr_mutex();
        }
        strcpy(@=$$@>, @=$1@>);
           
    }
    else
    {
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << param->thread_ctr 
                 << "] In `yyparse':  `link_expression_list: link_expression_list "
                 << "link_expression':"
                 << endl
                 << "Setting `$$' to `" << @=$2@> << "'."
                 << endl;
            unlock_cerr_mutex();
        }   
        
        strcpy(@=$$@>, @=$2@>);
    }

    

};

@q **** (4) link_expression:  NO_LINKS_YY @>

@ \<link expression> $\longrightarrow$ \.{NO\_LINKS\_YY}.
\initials{LDF 2012.02.07.}

\LOG
\initials{LDF 2012.02.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=link_expression: NO_LINKS_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `link_expression: NO_LINKS_YY'. "
             << endl;
        unlock_cerr_mutex();
    }

    strcpy(@=$$@>, "0");

};

@q **** (4) link_expression:  WITH_LINKS_YY @>

@ \<link expression> $\longrightarrow$ \.{WITH\_LINKS\_YY}.
\initials{LDF 2012.02.07.}

\LOG
\initials{LDF 2012.02.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=link_expression: WITH_LINKS_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `link_expression: WITH_LINKS_YY'. "
             << endl;
        unlock_cerr_mutex();
    }

    strcpy(@=$$@>, "1");

};

@q **** (4) link_expression:  LINK_DIRECTORY_YY STRING_YY @>

@ \<link expression> $\longrightarrow$ \.{LINKS\_DIRECTORY\_YY} \.{STRING\_YY}.
\initials{LDF 2012.02.07.}

\LOG
\initials{LDF 2012.02.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=link_expression: LINK_DIRECTORY_YY STRING_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `link_expression: LINK_DIRECTORY_YY STRING_YY'. "
             << endl
             << "`STRING_YY' == " << @=$2@> << endl;
        unlock_cerr_mutex();
    }

    strcpy(@=$$@>, @=$2@>);

     

};

@q **** (4) statement -->  install_or_reinstall PACKAGE_NAME_YY STRING_YY      @>
@q **** (4) package_version_optional GLOBUS_SITE_YY STRING_YY                  @>
@q **** (4) stdout_filename_optional stderr_filename_optional timeout_optional @>
@q **** (4) reinstall_prerequisites_optional link_expression_list              @>

@ \<statement> $\longrightarrow$ \<install or reinstall> 
\<install or reinstall> \.{PACKAGE\_NAME\_YY} \.{STRING\_YY}
\<package version optional> \.{GLOBUS\_SITE\_YY} \.{STRING\_YY}             
\<stdout filename optional> \<stderr filename optional>
\<timeout optional> \<reinstall prerequisites optional>
\<link expression list>.             
\initials{LDF 2011.09.30.}

\LOG
\initials{LDF 2011.09.30.}
Added this rule.

\initials{LDF 2011.10.23.}
Added \<timeout optional>.  Added code for setting |entry.timeout| and the values of
other new data members of |Entry_Type|.

\initials{LDF 2012.02.03.}
Added \<reinstall prerequisites optional>.  Added code for setting 
|entry.remote_install_reinstall_prerequisites|.

\initials{LDF 2012.02.07.}
Added \<link expression list>.
Now calling |remote_install_rule_func|, which is defined in \filename{prsrfncs.web}.
Removed code from this rule and put it into |remote_install_rule_func|.  This
saves on compilation, if changes are made.
\ENDLOG

@<Rules@>=

@=statement: install_or_reinstall PACKAGE_NAME_YY STRING_YY @>@/
@=package_version_optional GLOBUS_SITE_YY STRING_YY @>
@=stdout_filename_optional stderr_filename_optional timeout_optional @>@/
@=reinstall_prerequisites_optional link_expression_list@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:"
             << endl 
             << "install_or_reinstall PACKAGE_NAME_YY STRING_YY "
             << "package_version_optional GLOBUS_SITE_YY STRING_YY"
             << endl 
             << "stdout_filename_optional stderr_filename_optional "
             << "timeout_optional reinstall_prerequisites_optional link_expression_list'."
             << endl;

        cerr << "install_or_reinstall == " << @=$1@> << endl
             << "package_name == " << @=$3@> << endl
             << "package_version == " << @=$4@> << endl
             << "globus site == " << @=$6@> << endl
             << "stdout_filename_optional == " <<  @=$7@> << endl 
             << "stderr_filename_optional == " <<  @=$8@> << endl
             << "timeout_optional == " <<  @=$9@> << endl
             << "reinstall_prerequisites_optional == " << @=$10@> << endl
             << "link_expression_list == " << @=$11@> << endl;

        cerr << "param->user_name == " << param->user_name << endl;
 
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */

@q ****** (6) @>

#if HAVE_LIBMYSQLCLIENT

    int status = remote_install_rule_func(param, @=$1@>, @=$3@>, @=$4@>, @=$6@>, 
                                          @=$7@>, @=$8@>, @=$9@>, @=$10@>, @=$11@>);

    if (status != 0)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  Rule `statement:"
             << endl 
             << "install_or_reinstall PACKAGE_NAME_YY STRING_YY "
             << "package_version_optional GLOBUS_SITE_YY STRING_YY"
             << endl 
             << "stdout_filename_optional stderr_filename_optional "
             << "timeout_optional reinstall_prerequisites_optional link_expression_list':"
             << endl
             << "`remote_install_func' failed, returning " << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 
    }
    else if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:"
             << endl 
             << "install_or_reinstall PACKAGE_NAME_YY STRING_YY "
             << "package_version_optional GLOBUS_SITE_YY STRING_YY"
             << endl 
             << "stdout_filename_optional stderr_filename_optional "
             << "timeout_optional reinstall_prerequisites_optional link_expression_list':"
             << endl
             << "`remote_install_func' succeeded."
             << endl;
        unlock_cerr_mutex(); 
    }

@q ****** (6) @>

     

#endif /* |HAVE_LIBMYSQLCLIENT|  */

@q ***** (5) @>

};

@q **** (4) statement:  CLIENT_YY TO_YY TRANSFER_YY KEY_PAIR_YY@>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{TO\_YY} 
\.{TRANSFER\_YY} \.{KEY\_PAIR\_YY}.
\initials{LDF 2011.11.03.}

\LOG
\initials{LDF 2011.11.03.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: CLIENT_YY TO_YY TRANSFER_YY KEY_PAIR_YY @> 
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  CLIENT_YY TO_YY TRANSFER_YY "
             << "KEY_PAIR_YY'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    Response_Type response;

    response.type = Response_Type::KEY_PAIR_TYPE;

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_front(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

     

};

@q **** (4) statement --> CLIENT_YY SENDING_YY KEY_PAIR_YY STRING_YY STRING_YY.  @>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{SENDING\_YY} 
 \.{KEY\_PAIR\_YY} \.{STRING\_YY} \.{STRING\_YY}.
\initials{LDF 2011.11.03.}

\LOG
\initials{LDF 2011.11.03.}
Added this rule.

\initials{LDF 2011.12.16.}
Added second \.{STRING\_YY} for setting |param->key_id|.
\ENDLOG

@<Rules@>=

@=statement: CLIENT_YY SENDING_YY KEY_PAIR_YY STRING_YY STRING_YY@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;       

    stringstream temp_strm;

    string key_pair_filename;

    string public_key_filename;
  
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "CLIENT_YY SENDING_YY KEY_PAIR_YY STRING_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */

    errno = 0;
    param->key_id = strtoul(@=$5@>, 0, 0);

    if (param->key_id == ULONG_MAX)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  Rule `statement:  "
             << "CLIENT_YY SENDING_YY KEY_PAIR_YY STRING_YY STRING_YY':"
             << endl
             << "`strtoul' failed to convert second `STRING_YY' to `unsigned long int', "
             << endl
             << "returning `ULONG_MAX'."
             << endl;

        if (errno != 0)
            cerr << "strtoul error:  " << strerror(errno)
                 << endl;

        cerr << "`$5' == " << @=$5@>
             << endl 
             << "Must call `accept_data' twice to handle data sent by client."
             << endl 
             << "Will try to continue."
             << endl;

        unlock_cerr_mutex();

    }  /* |if (param->key_id == ULONG_MAX)|  */
    
@q ***** (5) @>

    if (param->PARSER_DEBUG)
    {
         cerr << "param->key_id == " << param->key_id << endl;

    }  /* |if (param->PARSER_DEBUG)|  */  

@q ***** (5) @>

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "CLIENT_YY SENDING_YY KEY_PAIR_YY STRING_YY STRING_YY':"
             << endl
             << "Calling `accept_data'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */

@q ****** (6) @>
@
@<Rules@>=

    if (param->effective_user_id > 0)
    {
        param->effective_user_dn = @=$4@>;
    }
    else
        param->user_dn = @=$4@>;

@q ****** (6) @>

    int status = accept_data(param, 0, 0, Response_Type::KEY_PAIR_TYPE, 
                             &key_pair_filename);

@q ****** (6) @>
@
\LOG
\initials{LDF 2011.11.14.}
Added this section.
\ENDLOG
@<Rules@>=

    if (status == 2)
    {
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << param->thread_ctr 
                 << "] In `yyparse':  Rule `statement:  "
                 << "CLIENT_YY SENDING_YY KEY_PAIR_YY STRING_YY STRING_YY':"
                 << endl
                 << "`accept_data' succeeded, returning 2:  Replaced key pair."
                 << endl;
            unlock_cerr_mutex();

        }  /* |if (param->PARSER_DEBUG)| */

        temp_strm << "RECEIVE KEY_PAIR SUCCEEDED REPLACED";
      
        response.command = temp_strm.str();

    }  /* |if (status == 0)| */

@q ****** (6) @>
@
@<Rules@>=

    else if (status == 0)
    {
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << param->thread_ctr 
                 << "] In `yyparse':  Rule `statement:  "
                 << "CLIENT_YY SENDING_YY KEY_PAIR_YY STRING_YY STRING_YY':"
                 << endl
                 << "`accept_data' succeeded, returning 0."
                 << endl;
            unlock_cerr_mutex();

        }  /* |if (param->PARSER_DEBUG)| */

        temp_strm << "RECEIVE KEY_PAIR SUCCEEDED";
      
        response.command = temp_strm.str();

    }  /* |if (status == 0)| */

@q ****** (6) @>
@
@<Rules@>=

    else /* |status != 0|  */
    {
        lock_cerr_mutex();
        cerr << get_datestamp() << " [Thread " << param->thread_ctr 
             << "] WARNING!  In `yyparse':  "
             << "Rule `statement: CLIENT_YY SENDING_YY KEY_PAIR_YY "
             << "STRING_YY STRING_YY':"
             << endl
             << "`accept_data' failed, returning " << status
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex();

        temp_strm << "RECEIVE KEY_PAIR FAILED";

        response.command = temp_strm.str();

    }  /* |else| (|status != 0|) */

@q ****** (6) @>

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_front(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

     

@q ***** (5) @>

    temp_strm.str("");

    status = accept_data(param, 0, 0, Response_Type::PUBLIC_KEY_TYPE, 
                         &public_key_filename);

@q ****** (6) @>

    if (status == 2)
    {
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << param->thread_ctr 
                 << "] In `yyparse':  Rule `statement:  "
                 << "CLIENT_YY SENDING_YY KEY_PAIR_YY STRING_YY STRING_YY':"
                 << endl
                 << "`accept_data' succeeded, returning 2:  Replaced public key."
                 << endl;
            unlock_cerr_mutex();

        }  /* |if (param->PARSER_DEBUG)| */

        temp_strm << "RECEIVE PUBLIC_KEY SUCCEEDED REPLACED";
      
        response.command = temp_strm.str();

    }  /* |if (status == 0)| */

    else if (status == 4)
    {
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << param->thread_ctr 
                 << "] In `yyparse':  Rule `statement:  "
                 << "CLIENT_YY SENDING_YY KEY_PAIR_YY STRING_YY STRING_YY':"
                 << endl
                 << "`accept_data' succeeded, returning 4:  Public key already in database."
                 << endl 
                 << "Did not replace."
                 << endl;
            unlock_cerr_mutex();

        }  /* |if (param->PARSER_DEBUG)| */

        temp_strm << "RECEIVE PUBLIC_KEY SUCCEEDED NOT REPLACED";
      
        response.command = temp_strm.str();

    }  /* |if (status == 4)| */

@q ****** (6) @>
@
@<Rules@>=

    else if (status == 0)
    {
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << param->thread_ctr 
                 << "] In `yyparse':  Rule `statement:  "
                 << "CLIENT_YY SENDING_YY KEY_PAIR_YY STRING_YY STRING_YY':"
                 << endl
                 << "`accept_data' succeeded, returning 0."
                 << endl;
            unlock_cerr_mutex();

        }  /* |if (param->PARSER_DEBUG)| */

        temp_strm << "RECEIVE PUBLIC_KEY SUCCEEDED";
      
        response.command = temp_strm.str();

    }  /* |if (status == 0)| */

@q ****** (6) @>
@
@<Rules@>=

    else /* |status != 0|  */
    {
        lock_cerr_mutex();
        cerr << get_datestamp() << " [Thread " << param->thread_ctr 
             << "] WARNING!  In `yyparse':  "
             << "Rule `statement: CLIENT_YY SENDING_YY KEY_PAIR_YY "
             << "STRING_YY STRING_YY':"
             << endl
             << "`accept_data' failed, returning " << status
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex();

        temp_strm << "RECEIVE PUBLIC_KEY FAILED";

        response.command = temp_strm.str();

    }  /* |else| (|status != 0|) */

@q ****** (6) @>

@ |deque_exchange_front_2| just exchanges the front two items on a |deque|.
This way, the client outputs the message about the key pair before the one about
the public key, even though the response for the latter is pushed onto the front
of |param->response_deque| last.  This is the order I prefer.
\par
|deque_exchange_front_2| is defined in \filename{utilfncs.web}.  It returns 0
upon success and 1 upon failure.  However, I'm currently not bothering about
testing whether it fails here (it shouldn't).
\initials{LDF 2011.12.16.}

@<Rules@>=

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_front(response);
    deque_exchange_front_2(param->response_deque);   
    pthread_mutex_unlock(&param->response_deque_mutex);

     

@q ***** (5) @>

};

@q **** (4) statement --> CLIENT_YY ERROR_YY NOT_YY SENDING_YY KEY_PAIR_YY. @>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{ERROR\_YY} 
\.{NOT\_YY} \.{SENDING\_YY} \.{KEY\_PAIR\_YY}.
\initials{LDF 2011.11.04.}

\LOG
\initials{LDF 2011.11.04.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: CLIENT_YY ERROR_YY NOT_YY SENDING_YY KEY_PAIR_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  Rule `statement:  "
             << "CLIENT_YY ERROR_YY NOT_YY SENDING_YY KEY_PAIR_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)| */

@q ***** (5) @>

    lock_cerr_mutex();
    cerr << get_datestamp() << "[Thread " << param->thread_ctr 
         << "] WARNING!  In `yyparse':  Rule `statement:  "
         << "CLIENT_YY ERROR_YY NOT_YY SENDING_YY KEY_PAIR_YY':"
         << endl
         << "Client-side error:  Client not sending key pair."
         << endl
         << "Will try to continue."
         << endl;
    unlock_cerr_mutex();

};

@q **** (4) statement --> FETCH_YY KEY_PAIR_YY @>

@ \<statement> $\longrightarrow$ \.{FETCH\_YY} \.{KEY\_PAIR\_YY}.
\initials{LDF 2011.11.10.}

\LOG
\initials{LDF 2011.11.10.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: FETCH_YY KEY_PAIR_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement: FETCH_YY KEY_PAIR_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

    Response_Type response;

    response.type          = Response_Type::FETCH_KEY_PAIR_TYPE;

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

     

};

@q **** (4) statement --> RECEIVE_YY KEY_PAIR_YY SUCCEEDED_YY @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_YY} \.{KEY\_PAIR\_YY} 
\.{SUCCEEDED\_YY}.
\initials{LDF 2011.11.10.}

\LOG
\initials{LDF 2011.11.10.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY KEY_PAIR_YY SUCCEEDED_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY KEY_PAIR_YY SUCCEEDED_YY "
             << "'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

     

};

@q **** (4) statement --> RECEIVE_YY KEY_PAIR_YY FAILED_YY @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_YY} \.{KEY\_PAIR\_YY} 
\.{FAILED\_YY}.
\initials{LDF 2011.11.10.}

\LOG
\initials{LDF 2011.11.10.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  RECEIVE_YY KEY_PAIR_YY FAILED_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: RECEIVE_YY KEY_PAIR_YY FAILED_YY "
             << "'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

     

};

@q **** (4) globus_site_list and sub_globus_site_list.   @>
@ \<globus site list> and \<sub-globus site list>.
\initials{LDF 2011.11.17.}

\LOG
\initials{LDF 2011.11.17.}
Added these type declarations.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> globus_site_list@>@;@/
@=%type <int_value> sub_globus_site_list@>

@q **** (4) globus_site_list:  /* Empty  */ @>

@ \<globus site list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2011.11.17.}

\LOG
\initials{LDF 2011.11.17.}
Added this rule.

\initials{LDF 2012.05.02.}
Commented-out this rule.  I don't think it's needed, and it causes input that should
cause an error to be parsed without one.
\ENDLOG

@q @@<Rules@@>=@>

@<Garbage@>=

@=globus_site_list:  /* Empty  */ @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_list:  /* Empty  */'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_set.clear();

     

};

@q **** (4) globus_site_list:  GLOBUS_SITES_YY ALL_YY @>

@ \<globus site list> $\longrightarrow$ \.{GLOBUS\_SITES\_YY} \.{ALL\_YY}.
\initials{LDF 2011.12.16.}

@:NOTE@> !! PLEASE NOTE:  If this rule or its action are changed, the rule 
below must be changed accordingly!
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_list:  GLOBUS_SITES_YY ALL_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_list:  GLOBUS_SITES_YY ALL_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_set.clear();

    for (map<string, bool>::const_iterator iter = globus_site_map.begin();
         iter != globus_site_map.end();
         ++iter)
    {
         param->globus_site_set.insert(iter->first);
    }

     

};

@q **** (4) globus_site_list:  GLOBUS_SITE_YY ALL_YY @>

@ \<globus site list> $\longrightarrow$ \.{GLOBUS\_SITE\_YY} \.{ALL\_YY}.
\initials{LDF 2011.12.16.}

@:NOTE@> !! PLEASE NOTE:  If this rule or its action are changed, the rule 
above must be changed accordingly!
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this rule.  It's just a convenience.  It duplicates the rule
\<globus site list> $\longrightarrow$ \.{GLOBUS\_SITES\_YY} \.{ALL\_YY}, 
i.e., it ensures that typing ``\.{GLOBUS\_SITE\_YY} \.{ALL\_YY}''
instead of ``\.{GLOBUS\_SITES\_YY} \.{ALL\_YY}'' will still 
work correctly.
\ENDLOG

@<Rules@>=

@=globus_site_list:  GLOBUS_SITE_YY ALL_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_list:  GLOBUS_SITE_YY ALL_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_set.clear();

    for (map<string, bool>::const_iterator iter = globus_site_map.begin();
         iter != globus_site_map.end();
         ++iter)
    {
         param->globus_site_set.insert(iter->first);
    }

     

};

@q **** (4) globus_site_list:  sub_globus_site_list  @>

@ \<globus site list> $\longrightarrow$ \<sub-globus site list>.
\initials{LDF 2011.11.17.}

\LOG
\initials{LDF 2011.11.17.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_list:  sub_globus_site_list @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_list:  sub_globus_site_list'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

     

};

@q **** (4) sub_globus_site_list:  GLOBUS_SITE_YY STRING_YY @>

@ \<globus site list> $\longrightarrow$ \.{GLOBUS\_SITE\_YY} \.{STRING\_YY}.
\initials{LDF 2011.11.21.}

\LOG
\initials{LDF 2011.11.21.}
Added this rule.  It makes using the keyword \.{GLOBUS\_SITE} equivalent to using
\.{GLOBUS\_SITES}.  Previously, trying to use \.{GLOBUS\_SITE} with multiple 
strings caused an error.  This was logical, but error-prone.
\ENDLOG

@<Rules@>=

@=sub_globus_site_list:  GLOBUS_SITE_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `sub_globus_site_list:  GLOBUS_SITE_YY STRING_YY'."
             << endl
             << "`STRING_YY' == " << @=$2@> << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_set.clear();
    param->globus_site_set.insert(@=$2@>);

     

};

@q **** (4) sub_globus_site_list:  GLOBUS_SITES_YY STRING_YY @>

@ \<globus site list> $\longrightarrow$ \.{GLOBUS\_SITES\_YY} \.{STRING\_YY}.
\initials{LDF 2011.11.17.}

\LOG
\initials{LDF 2011.11.17.}
Added this rule.
\ENDLOG

@<Rules@>=

@=sub_globus_site_list:  GLOBUS_SITES_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `sub_globus_site_list:  GLOBUS_SITES_YY STRING_YY'."
             << endl
             << "`STRING_YY' == " << @=$2@> << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_set.clear();
    param->globus_site_set.insert(@=$2@>);

     

};

@q **** (4) sub_globus_site_list:  sub_globus_site_list STRING_YY @>

@ \<sub-globus site list> $\longrightarrow$ \.{STRING\_YY}.
\initials{LDF 2011.11.17.}

\LOG
\initials{LDF 2011.11.17.}
Added this rule.
\ENDLOG

@<Rules@>=

@=sub_globus_site_list:  sub_globus_site_list STRING_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `sub_globus_site_list:  sub_globus_site_list STRING_YY'."
             << endl
             << "`STRING_YY' == " << @=$2@> << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_set.insert(@=$2@>);

     

};

@q **** (4) statement --> DISTRIBUTE_YY KEY_PAIR_YY globus_site_list@>

@ \<statement> $\longrightarrow$ \.{DISTRIBUTE\_YY} \.{KEY\_PAIR\_YY} \<globus site list>.
\initials{LDF 2011.11.17.}

\LOG
\initials{LDF 2011.11.17.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  DISTRIBUTE_YY KEY_PAIR_YY globus_site_list @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DISTRIBUTE_YY KEY_PAIR_YY globus_site_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

@q ***** (5) @>

    map<string, bool>::const_iterator find_iter;

    Response_Type response;

    stringstream temp_strm;

    bool globus_site_found = false;

@q ***** (5) @>

    for (set<string>::const_iterator iter = param->globus_site_set.begin();
         iter != param->globus_site_set.end();
         ++iter)
    {
@q ****** (6) @>

        find_iter = globus_site_map.find(*iter);

        if (param->PARSER_DEBUG)
        {
            cerr << "*iter == " << *iter << endl;

        }  /* |if (param->PARSER_DEBUG)|  */ 

        if (find_iter == globus_site_map.end())
        {
           lock_cerr_mutex(); 
           cerr << "[Thread " << param->thread_ctr 
                << "] WARNING:  In `yyparse':  "
                << "`statement: DISTRIBUTE_YY KEY_PAIR_YY globus_site_list':"
                << endl
                << "`" << *iter << "' not in `globus_site_map'.  Not distributing "
                << "key pair to this Globus site."
                << endl
                << "Continuing."
                << endl;
           unlock_cerr_mutex(); 

           response.type = Response_Type::COMMAND_ONLY_TYPE;

           temp_strm.str("");

           temp_strm << "SERVER NOT DISTRIBUTING KEY_PAIR <"
                     << "Unknown Globus site:  " << *iter << ">";

           response.command = temp_strm.str();

           temp_strm.str("");

           pthread_mutex_lock(&param->response_deque_mutex);
           param->response_deque.push_back(response);
           pthread_mutex_unlock(&param->response_deque_mutex);

           continue;

        }  /* |if|  */

@q ****** (6) @>

        else if (find_iter->second == false)
        {
           lock_cerr_mutex(); 
           cerr << "[Thread " << param->thread_ctr 
                << "] WARNING:  In `yyparse':  "
                << "`statement: DISTRIBUTE_YY KEY_PAIR_YY globus_site_list':"
                << endl
                << "`" << *iter << "' is disabled.  Not distributing "
                << "key pair to this Globus site."
                << endl
                << "Continuing."
                << endl;
           unlock_cerr_mutex(); 

           response.type = Response_Type::COMMAND_ONLY_TYPE;

           temp_strm.str("");

           temp_strm << "SERVER NOT DISTRIBUTING KEY_PAIR <"
                     << "Globus site disabled:  " << *iter << ">";

           response.command = temp_strm.str();

           temp_strm.str("");

           pthread_mutex_lock(&param->response_deque_mutex);
           param->response_deque.push_back(response);
           pthread_mutex_unlock(&param->response_deque_mutex);

           continue;

        }  /* |else if (find_iter->second == false)|  */

@q ****** (6) @>

        else 
        {
            globus_site_found = true;

            response.globus_site_set.insert(*iter);

            if (param->PARSER_DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "`" << *iter << "' found on `globus_site_map'." << endl;
                unlock_cerr_mutex(); 
      
            }  /* |if (param->PARSER_DEBUG)|  */ 

        }  /* |else|  */

@q ****** (6) @>

    }  /* |for|  */

@q ***** (5) @>

    if (globus_site_found == true)
    {
         response.type = Response_Type::DISTRIBUTE_KEY_PAIR_TYPE;
 
         pthread_mutex_lock(&param->response_deque_mutex);  
         param->response_deque.push_back(response);
         pthread_mutex_unlock(&param->response_deque_mutex);  

    }  /* |if (globus_site_found == true)|  */

    param->globus_site_set.clear();

     

@q ***** (5) @>

};

@q **** (4) statement --> DELETE_YY KEY_PAIR_YY FROM_YY DATABASE_YY@>

@ \<statement> $\longrightarrow$ \.{DELETE\_YY} \.{KEY\_PAIR\_YY} 
\.{FROM\_YY} \.{DATABASE\_YY}.
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  DELETE_YY KEY_PAIR_YY FROM_YY DATABASE_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DELETE_YY KEY_PAIR_YY FROM_YY DATABASE_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

@q ***** (5) @>

#if HAVE_LIBMYSQLCLIENT

    int status = param->delete_key_pair();

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

    if (status == 3)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: DELETE_YY KEY_PAIR_YY FROM_YY DATABASE_YY':"
             << endl
             << "`Scan_Parse_Parameter_Type::delete_key_pair' failed, returning 3:" 
             << endl 
             << "No key pair in database.  Can't delete."
             << endl
             << "Sending message to client.  Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        response.command 
           = "SERVER DELETE KEY_PAIR FROM DATABASE FAILED NO KEY_PAIR IN DATABASE";

        param->response_deque.push_back(response);        

    }  /* |if (status == 3)|  */
    
    else if (status != 0)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: DELETE_YY KEY_PAIR_YY FROM_YY DATABASE_YY':"
             << endl
             << "`Scan_Parse_Parameter_Type::delete_key_pair' failed, returning " 
             << status << "."
             << endl
             << "Sending message to client.  Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        response.command = "SERVER DELETE KEY_PAIR FROM DATABASE FAILED";

        param->response_deque.push_back(response);        

    }  /* |if (status != 0)|  */
    
    else 
    {
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << param->thread_ctr 
                 << "] In `yyparse':  "
                 << "`statement: DELETE_YY KEY_PAIR_YY FROM_YY DATABASE_YY':"
                 << endl
                 << "`Scan_Parse_Parameter_Type::delete_key_pair' succeeded."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */  

        response.command = "SERVER DELETE KEY_PAIR FROM DATABASE SUCCEEDED";

        param->response_deque.push_back(response);        

    }  /* |else|  */

#endif 

     

@q ***** (5) @>

};

@q **** (4) statement --> DELETE_YY PUBLIC_KEY_YY FROM_YY DATABASE_YY@>

@ \<statement> $\longrightarrow$ \.{DELETE\_YY} \.{PUBLIC\_KEY\_YY} 
\.{FROM\_YY} \.{DATABASE\_YY}.
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  DELETE_YY PUBLIC_KEY_YY FROM_YY DATABASE_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DELETE_YY PUBLIC_KEY_YY FROM_YY DATABASE_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

@q ***** (5) @>

#if HAVE_LIBMYSQLCLIENT

    int status = param->delete_public_key();

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

    if (status == 3)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: DELETE_YY PUBLIC_KEY_YY FROM_YY DATABASE_YY':"
             << endl
             << "`Scan_Parse_Parameter_Type::delete_public_key' failed, returning 3:" 
             << endl 
             << "No public key in database.  Can't delete."
             << endl
             << "Sending message to client.  Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        response.command 
           = "SERVER DELETE PUBLIC_KEY FROM DATABASE FAILED NO PUBLIC_KEY IN DATABASE";

        param->response_deque.push_back(response);        

    }  /* |if (status == 3)|  */
    
    else if (status != 0)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: DELETE_YY PUBLIC_KEY_YY FROM_YY DATABASE_YY':"
             << endl
             << "`Scan_Parse_Parameter_Type::delete_public_key' failed, returning " 
             << status << "."
             << endl
             << "Sending message to client.  Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        response.command = "SERVER DELETE PUBLIC_KEY FROM DATABASE FAILED";

        param->response_deque.push_back(response);        

    }  /* |if (status != 0)|  */
    
    else 
    {
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex();
            cerr << "[Thread " << param->thread_ctr 
                 << "] In `yyparse':  "
                 << "`statement: DELETE_YY PUBLIC_KEY_YY FROM_YY DATABASE_YY':"
                 << endl
                 << "`Scan_Parse_Parameter_Type::delete_public_key' succeeded."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */  

        response.command = "SERVER DELETE PUBLIC_KEY FROM DATABASE SUCCEEDED";

        param->response_deque.push_back(response);        

    }  /* |else|  */

#endif 

     

@q ***** (5) @>

};

@q **** (4) statement --> SESSION_ID_YY STRING_YY  @>

@ \<statement> $\longrightarrow$ \.{SESSION\_ID\_YY} \.{STRING\_YY}.
\initials{LDF 2011.12.22.}

\LOG
\initials{LDF 2011.12.22.}
Added this rule.

\initials{LDF 2012.01.03.}
Added call to |Scan_Parse_Parameter_Type::get_session_data|.  About to start
working on this function.
\ENDLOG

@<Rules@>=

@=statement:  SESSION_ID_YY STRING_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: SESSION_ID_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

@q ***** (5) @>

    param->session_id = @=$2@>;

    Response_Type response;

    response.type = Response_Type::COMMAND_ONLY_TYPE;

    stringstream temp_strm;

    temp_strm << "SERVER SESSION_ID <" << param->session_id << ">";

    response.command = temp_strm.str();

    param->response_deque.push_front(response);

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: SESSION_ID_YY STRING_YY':"
             << endl
             << "`param->session_id' == " << param->session_id
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  

    int status = param->get_session_data();

    if (status != 0)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: SESSION_ID_YY STRING_YY':"
             << endl
             << "`param->get_session_data' failed, returning " << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (status != 0)|  */
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: SESSION_ID_YY STRING_YY':"
             << endl
             << "`param->get_session_data' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (param->PARSER_DEBUG)|  */ 

#endif /* |ifdef HAVE_LIBMYSQLCLIENT|  */

     

@q ***** (5) @>

};

@q **** (4) statement --> ADD_YY GLOBUS_SITE_YY STRING_YY globus_site_option_list @>

@ \<statement> $\longrightarrow$ \.{ADD\_YY} \.{GLOBUS\_SITE\_YY} \.{STRING\_YY}
\<globus site option list>.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  ADD_YY GLOBUS_SITE_YY STRING_YY globus_site_option_list@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: ADD_YY GLOBUS_SITE_YY STRING_YY globus_site_option_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    if (param->globus_site_options.enabled == 0)
       param->globus_site_options.enabled = 1;

    param->globus_site_options.hostname = @=$3@>;

    int status = param->add_globus_site();

    if (status == 2)
    {
#if 0 

/* This warning isn't needed here, because a similar one is issued by
   |Scan_Parse_Parameter_Type::add_globus_site|.  
   \initials{LDF 2012.05.04.}  */

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] WARNING!  In `yyparse':  "
             << "`statement: ADD_YY GLOBUS_SITE_YY STRING_YY globus_site_option_list':"
             << endl
             << "`Scan_Parse_Parameter_Type::add_globus_site' returned 2:"
             << endl
             << "Options specified would cause no change to existing database "
             << "entry for Globus site `" << @=$3@> << "'.  Not replaced."
             << endl 
             << "Continuing."
             << endl;
        unlock_cerr_mutex(); 
#endif 
    }

    else if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] WARNING!  In `yyparse':  "
             << "`statement: ADD_YY GLOBUS_SITE_YY STRING_YY globus_site_option_list':"
             << endl
             << "`Scan_Parse_Parameter_Type::add_globus_site' failed, "
             << "returning " << status << "."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex(); 
    }

    else if (param->PARSER_DEBUG)
    {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr 
              << "] In `yyparse':  "
              << "`statement: ADD_YY GLOBUS_SITE_YY STRING_YY globus_site_option_list':"
              << endl
              << "`Scan_Parse_Parameter_Type::add_globus_site' succeeded."
              << endl;
         unlock_cerr_mutex(); 

    }  /* |else if (param->PARSER_DEBUG)|  */ 

#endif /* |ifdef HAVE_LIBMYSQLCLIENT|  */

    param->globus_site_options.clear();

     

@q ***** (5) @>

};

@q **** (4) globus_site_option_list and globus_site_option @>
@ \<globus site option list> and \<globus site option>.

\LOG
\initials{LDF 2012.04.12.}
Added these type declarations.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> globus_site_option_list@>@;@/
@=%type <int_value> globus_site_option@>

@q **** (4) globus_site_option_list:  /* Empty  */  @>

@ \<globus site option list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option_list:  /* Empty  */  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option_list:  /* Empty  */.'"
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.clear();

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option_list:  globus_site_option_list globus_site_option  @>

@ \<globus site option list> $\longrightarrow$ \<globus site option>.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option_list:  globus_site_option_list globus_site_option @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option_list:  "
             << "globus_site_option_list globus_site_option'.'"
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option: INTERACTIVE_NODE_YY STRING_YY @>

@ \<globus site option> $\longrightarrow$ \.{INTERACTIVE\_NODE\_YY} \.{STRING\_YY}.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option: INTERACTIVE_NODE_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option:  INTERACTIVE_NODE_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.interactive_node_name = @=$2@>;

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option: APPEND_LD_LIBRARY_PATH_YY STRING_YY @>

@ \<globus site option> $\longrightarrow$ \.{APPEND\_LD\_LIBRARY\_PATH\_YY} 
\.{STRING\_YY}.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option: APPEND_LD_LIBRARY_PATH_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option:  APPEND_LD_LIBRARY_PATH_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.append_ld_library_path = @=$2@>;

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option: APPEND_PATH_YY STRING_YY @>

@ \<globus site option> $\longrightarrow$ \.{APPEND\_PATH\_YY} 
\.{STRING\_YY}.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option: APPEND_PATH_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option:  APPEND_PATH_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.append_path = @=$2@>;

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option: OPTDBCLI_PATH_YY STRING_YY @>

@ \<globus site option> $\longrightarrow$ \.{OPTDBCLI\_PATH\_YY} 
\.{STRING\_YY}.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option: OPTDBCLI_PATH_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option:  OPTDBCLI_PATH_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.optdbcli_path = @=$2@>;

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option: IP_ADDRESS_YY STRING_YY @>

@ \<globus site option> $\longrightarrow$ \.{IP\_ADDRESS\_YY} 
\.{STRING\_YY}.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option: IP_ADDRESS_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option:  IP_ADDRESS_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.ip_address = @=$2@>;

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option: INTERACTIVE_NODE_IP_ADDRESS_YY STRING_YY @>

@ \<globus site option> $\longrightarrow$ \.{INTERACTIVE\_NODE\_IP\_ADDRESS\_YY} 
\.{STRING\_YY}.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option: INTERACTIVE_NODE_IP_ADDRESS_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option:  INTERACTIVE_NODE_IP_ADDRESS_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.interactive_node_ip_address = @=$2@>;

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option: ENABLED_YY @>

@ \<globus site option> $\longrightarrow$ \.{ENABLED\_YY}.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option: ENABLED_YY@>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option:  ENABLED_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.enabled = 1;

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option: DISABLED_YY @>

@ \<globus site option> $\longrightarrow$ \.{DISABLED\_YY}.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option: DISABLED_YY@>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option:  DISABLED_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.enabled = -1;

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option: REPLACE_YY @>

@ \<globus site option> $\longrightarrow$ \.{REPLACE\_YY}.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option: REPLACE_YY@>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option:  REPLACE_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.replace = true;

    @=$$@> = 0;

     

};

@q **** (4) statement:  SHOW_YY globus_site_list html_optional@>

@ \<statement> $\longrightarrow$ \.{SHOW\_YY} \<globus site list> \<html optional>.
\initials{LDF 2012.05.02.}

\LOG
\initials{LDF 2012.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SHOW_YY globus_site_list html_optional@> 
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  SHOW_YY GLOBUS_SITES_YY "
             << "globus_site_list html_optional'." 
             << endl;

        cerr << "`param->globus_site_set.size()' == " << param->globus_site_set.size()
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    Response_Type response;
 
    map<string, bool>::const_iterator find_iter;

    stringstream temp_strm;

    bool globus_site_found = false;

@q ***** (5) @>

    for (set<string>::const_iterator iter = param->globus_site_set.begin();
         iter != param->globus_site_set.end();
         ++iter)
    {
@q ****** (6) @>

        find_iter = globus_site_map.find(*iter);

        if (param->PARSER_DEBUG)
        {
            cerr << "*iter == " << *iter << endl;

        }  /* |if (param->PARSER_DEBUG)|  */ 

        if (find_iter == globus_site_map.end())
        {
           lock_cerr_mutex(); 
           cerr << "[Thread " << param->thread_ctr 
                << "] WARNING:  In `yyparse':  "
                << "`statement:  SHOW_YY globus_site_list html_optional':"
                << endl
                << "`" << *iter << "' not in `globus_site_map'.  Can't show. "
                << endl
                << "Continuing."
                << endl;
           unlock_cerr_mutex(); 

           response.type = Response_Type::COMMAND_ONLY_TYPE;

           temp_strm.str("");

           temp_strm << "SERVER NOT SHOWING GLOBUS_SITE INFO <"
                     << "Unknown Globus site:  " << *iter << ">";

           response.command = temp_strm.str();

           temp_strm.str("");

           pthread_mutex_lock(&param->response_deque_mutex);
           param->response_deque.push_back(response);
           pthread_mutex_unlock(&param->response_deque_mutex);

           continue;

        }  /* |if|  */

@q ****** (6) @>

        else 
        {
            globus_site_found = true;

            response.globus_site_set.insert(*iter);

            if (param->PARSER_DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "`" << *iter << "' found on `globus_site_map'." << endl;
                unlock_cerr_mutex(); 
      
            }  /* |if (param->PARSER_DEBUG)|  */ 

        }  /* |else|  */

@q ****** (6) @>

    }  /* |for|  */

@q ***** (5) @>

    if (globus_site_found)
    {
        response.command = "";
        response.type = Response_Type::SHOW_GLOBUS_SITES_TYPE;
        response.output_format = @=$3@>;

        pthread_mutex_lock(&param->response_deque_mutex);
        param->response_deque.push_back(response);
        pthread_mutex_unlock(&param->response_deque_mutex);
    }

    param->globus_site_set.clear();

    

};

@q **** (4) statement:  DELETE_YY GLOBUS_SITE_YY STRING_YY FINALLY_YY  @>

@ \<statement> $\longrightarrow$ \.{DELETE\_YY} \.{GLOBUS\_SITE\_YY} 
\.{STRING\_YY} \.{FINALLY\_YY}.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DELETE_YY GLOBUS_SITE_YY STRING_YY FINALLY_YY@> 
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  DELETE_YY GLOBUS_SITE_YY "
             << "STRING_YY FINALLY_YY'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

#if HAVE_LIBMYSQLCLIENT

    param->globus_site_set.clear();
    param->globus_site_set.insert(@=$3@>);
 
    int status = param->delete_globus_sites(true);

    param->globus_site_set.clear();

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  DELETE_YY GLOBUS_SITE_YY "
             << "STRING_YY FINALLY_YY':" 
             << endl
             << "`Scan_Parse_Parameter_Type::delete_globus_site' returned "
             << status << "."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

#endif 

    

};

@q **** (4) statement --> MARK_YY AS_YY DELETED_YY GLOBUS_SITE_YY STRING_YY  @>

@ \<statement> $\longrightarrow$ 
\.{MARK\_YY} \.{AS\_YY} \.{DELETED\_YY} \.{GLOBUS\_SITE\_YY} \.{STRING\_YY}
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement: MARK_YY AS_YY DELETED_YY GLOBUS_SITE_YY STRING_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: MARK_YY AS_YY DELETED_YY GLOBUS_SITE_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)| */
 
    int status = param->mark_globus_site(true, @=$5@>);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: MARK_YY AS_YY DELETED_YY GLOBUS_SITE_YY STRING_YY':"
             << endl
             << "`Scan_Parse_Parameter_Type::mark_globus_site' failed, returning "
             << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: MARK_YY AS_YY DELETED_YY GLOBUS_SITE_YY STRING_YY':"
             << endl 
             << "`Scan_Parse_Parameter_Type::mark_entries' succeeded."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |else if (param->PARSER_DEBUG)| */

#endif 

    

};

@q **** (4) statement --> UNDELETE_YY GLOBUS_SITE_YY STRING_YY enable_optional@>

@ \<statement> $\longrightarrow$ 
\.{UNDELETE\_YY} \.{GLOBUS\_SITE\_YY} \.{STRING\_YY} \<enable optional>.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement:  UNDELETE_YY GLOBUS_SITE_YY STRING_YY enable_optional@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: UNDELETE_YY GLOBUS_SITE_YY STRING_YY enable_optional'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    int status = param->mark_globus_site(false, @=$3@>, @=$4@>);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: UNDELETE_YY GLOBUS_SITE_YY STRING_YY enable_optional'."
             << endl
             << "`Scan_Parse_Parameter_Type::mark_globus_site' failed, returning "
             << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: UNDELETE_YY GLOBUS_SITE_YY STRING_YY enable_optional'."
             << endl 
             << "`Scan_Parse_Parameter_Type::mark_globus_site' succeeded."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |else if (param->PARSER_DEBUG)| */

#endif 

     

};

@q **** (4) enable_optional  @>
@ \<enable optional>.

\LOG
\initials{LDF 2012.04.16.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> enable_optional@>

@q **** (4) enable_optional:  /* Empty  */  @>

@ \<enable optional> $\longrightarrow$ \.{Empty}.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=enable_optional:  /* Empty  */  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `enable_optional:  /* Empty  */.'"
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 0;

     

};

@q **** (4) enable_optional:  ENABLE_YY  @>

@ \<enable optional> $\longrightarrow$ \.{ENABLE\_YY}.
\initials{LDF 2012.03.22.}

\LOG
\initials{LDF 2012.03.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=enable_optional:  ENABLE_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `enable_optional:  "
             << "ENABLE_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 1;

     

};

@q **** (4) enable_optional:  DISABLE_YY  @>

@ \<enable optional> $\longrightarrow$ \.{DISABLE\_YY}.
\initials{LDF 2012.03.22.}

\LOG
\initials{LDF 2012.03.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=enable_optional:  DISABLE_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `enable_optional:  "
             << "DISABLE_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 2;

     

};

@q **** (4) statement --> ENABLE_YY GLOBUS_SITE_YY STRING_YY @>

@ \<statement> $\longrightarrow$ 
\.{ENABLE\_YY} \.{GLOBUS\_SITE\_YY} \.{STRING\_YY}.
\initials{LDF 2012.04.30.}

\LOG
\initials{LDF 2012.04.30.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement: ENABLE_YY GLOBUS_SITE_YY STRING_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: ENABLE_YY GLOBUS_SITE_YY STRING_YY '."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    int status = param->enable_globus_site(@=$3@>);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: ENABLE_YY ENTRY_YY STRING_YY':"
             << endl
             << "`Scan_Parse_Parameter_Type::enable_globus_site' failed, returning "
             << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: ENABLE_YY GLOBUS_SITE_YY STRING_YY':"
             << endl 
             << "`Scan_Parse_Parameter_Type::enable_globus_site' succeeded."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |else if (param->PARSER_DEBUG)| */

#endif 

};

@q **** (4) statement --> DISABLE_YY GLOBUS_SITE_YY STRING_YY @>

@ \<statement> $\longrightarrow$ 
\.{DISABLE\_YY} \.{GLOBUS\_SITE\_YY} \.{STRING\_YY}.
\initials{LDF 2012.04.30.}

\LOG
\initials{LDF 2012.04.30.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement: DISABLE_YY GLOBUS_SITE_YY STRING_YY @>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DISABLE_YY GLOBUS_SITE_YY STRING_YY '."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    int status = param->disable_globus_site(@=$3@>);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: DISABLE_YY ENTRY_YY STRING_YY':"
             << endl
             << "`Scan_Parse_Parameter_Type::disable_globus_site' failed, returning "
             << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: DISABLE_YY GLOBUS_SITE_YY STRING_YY':"
             << endl 
             << "`Scan_Parse_Parameter_Type::disable_globus_site' succeeded."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |else if (param->PARSER_DEBUG)| */

#endif 

};

@q **** (4) |add_or_delete|.  @>

@ \<add or delete>.
\initials{LDF 2012.05.02.}

\LOG
\initials{LDF 2012.05.02.}
Added this section.
\ENDLOG

@<Token and type declarations@>=
@=%type <int_value> add_or_delete@>

@q ***** (5) add_or_delete: ADD_YY  @>

@ \<add or delete> $\longrightarrow$ \.{ADD\_YY}.
\initials{LDF 2012.05.02.}

\LOG
\initials{LDF 2012.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=
@=add_or_delete: ADD_YY@>
{

   @=$$@> = 0;

};

@q ***** (5) add_or_delete: DELETE_YY  @>

@ \<add or delete> $\longrightarrow$ \.{DELETE\_YY}.
\initials{LDF 2012.05.02.}

\LOG
\initials{LDF 2012.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=
@=add_or_delete: DELETE_YY@>
{

   @=$$@> = 1;

};

@q **** (4) statement --> add_or_delete ADMIN_YY GLOBUS_SITE_YY STRING_YY USER_YY INTEGER_YY @>

@ \<statement> $\longrightarrow$ \<add or delete> \.{ADMIN\_YY} \.{GLOBUS\_SITE\_YY}
\.{STRING\_YY} \.{USER\_YY} \.{INTEGER\_YY}.
\initials{LDF 2012.05.02.}

\LOG
\initials{LDF 2012.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  add_or_delete ADMIN_YY GLOBUS_SITE_YY STRING_YY USER_YY INTEGER_YY@> 
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: add_or_delete ADMIN_YY GLOBUS_SITE_YY STRING_YY "
             << "USER_YY INTEGER_YY."
             << endl
             << "`add_or_delete' == " << @=$1@>
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    int status = param->edit_globus_site_admin(@=$4@>, @=$6@>, @=$1@>);

    if (status == 2)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] WARNING!  In `yyparse':  "
             << "`statement: add_or_delete ADMIN_YY GLOBUS_SITE_YY STRING_YY USER_YY INTEGER_YY':"
             << endl
             << "`Scan_Parse_Parameter_Type::edit_globus_site_admin' returned 2."
             << endl;

         if (@=$1@> == 0)
            cerr << "User " << @=$6@> << " is already admin of Globus site `" << @=$4@> << "'."
                 << endl
                 << "Not set again."
                 << endl;
         else if (@=$1@> == 1)
            cerr << "User " << @=$6@> << " is not admin of Globus site `" << @=$4@> << "'."
                 << endl
                 << "Not deleted."
                 << endl;             

         cerr << "Continuing."
              << endl;

         unlock_cerr_mutex(); 
    }    
    else if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] WARNING!  In `yyparse':  "
             << "`statement: add_or_delete ADMIN_YY GLOBUS_SITE_YY STRING_YY USER_YY INTEGER_YY':"
             << endl
             << "`Scan_Parse_Parameter_Type::edit_globus_site_admin' failed, "
             << "returning " << status << "."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex(); 
    }
   else if (param->PARSER_DEBUG)
   {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: add_or_delete ADMIN_YY GLOBUS_SITE_YY STRING_YY USER_YY INTEGER_YY':"
             << endl
             << "`Scan_Parse_Parameter_Type::edit_globus_site_admin' succeeded."
             << endl;
        unlock_cerr_mutex(); 

   }  /* |else if (param->PARSER_DEBUG)|  */ 

#endif /* |ifdef HAVE_LIBMYSQLCLIENT|  */

    

@q ***** (5) @>

};

@q **** (4) statement --> EDIT_YY GLOBUS_SITE_YY STRING_YY SET_YY globus_site_option_list@>

@ \<statement> $\longrightarrow$ 
\.{EDIT\_YY} \.{GLOBUS\_SITE\_YY} \.{STRING\_YY} \.{SET\_YY} \<globus site option list>.
\initials{LDF 2012.05.03.}

\LOG
\initials{LDF 2012.05.03.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement:  EDIT_YY GLOBUS_SITE_YY STRING_YY SET_YY globus_site_option_list@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: EDIT_YY GLOBUS_SITE_YY STRING_YY SET_YY globus_site_option_list'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    int status = param->edit_globus_site(@=$3@>, 0);

    if (status == 2)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] WARNING!  In `yyparse':  "
             << "`statement: EDIT_YY ENTRY_YY STRING_YY SET_YY globus_site_option_list':"
             << endl
             << "`Scan_Parse_Parameter_Type::edit_globus_site' returned 2:"
             << endl
             << "Options specified cause no change to database entry for Globus site "
             << "`" << @=$3@> << "'."
             << endl 
             << "Database entry not updated.  Continuing."
             << endl;
        unlock_cerr_mutex(); 

    }
    else if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: EDIT_YY ENTRY_YY STRING_YY SET_YY globus_site_option_list':"
             << endl
             << "`Scan_Parse_Parameter_Type::edit_globus_site' failed, returning "
             << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: EDIT_YY GLOBUS_SITE_YY STRING_YY SET_YY globus_site_option_list':"
             << endl 
             << "`Scan_Parse_Parameter_Type::edit_globus_site' succeeded."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |else if (param->PARSER_DEBUG)| */

#endif 

     

};

@q **** (4) statement --> EDIT_YY GLOBUS_SITE_YY STRING_YY UNSET_YY globus_site_option_list_1@>

@ \<statement> $\longrightarrow$ 
\.{EDIT\_YY} \.{GLOBUS\_SITE\_YY} \.{STRING\_YY} \.{UNSET\_YY} \<globus site option list 1>.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement:  EDIT_YY GLOBUS_SITE_YY STRING_YY UNSET_YY globus_site_option_list_1@>
{
    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: EDIT_YY GLOBUS_SITE_YY STRING_YY UNSET_YY globus_site_option_list_1'."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |if (param->PARSER_DEBUG)| */

#if HAVE_LIBMYSQLCLIENT

    int status = param->edit_globus_site(@=$3@>, 1);

    if (status == 2)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] WARNING!  In `yyparse':  "
             << "`statement: EDIT_YY ENTRY_YY STRING_YY UNSET_YY globus_site_option_list_1':"
             << endl
             << "`Scan_Parse_Parameter_Type::edit_globus_site' returned 2:"
             << endl
             << "Options specified cause no change to database entry for Globus site "
             << "`" << @=$3@> << "'."
             << endl 
             << "Database entry not updated.  Continuing."
             << endl;
        unlock_cerr_mutex(); 

    }
    else if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr 
             << "] ERROR!  In `yyparse':  "
             << "`statement: EDIT_YY ENTRY_YY STRING_YY UNSET_YY globus_site_option_list_1':"
             << endl
             << "`Scan_Parse_Parameter_Type::edit_globus_site' failed, returning "
             << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  "
             << "`statement: EDIT_YY GLOBUS_SITE_YY STRING_YY UNSET_YY globus_site_option_list_1':"
             << endl 
             << "`Scan_Parse_Parameter_Type::edit_globus_site' succeeded."
             << endl;
        unlock_cerr_mutex(); 
       
    }  /* |else if (param->PARSER_DEBUG)| */

#endif 

     

};

@q **** (4) globus_site_option_list_1 and globus_site_option_1 @>
@ \<globus site option list 1> and \<globus site option 1>.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added these type declarations.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> globus_site_option_list_1@>
@=%type <int_value> globus_site_option_1@>

@q **** (4) globus_site_option_list_1:  /* Empty  */  @> 

@ \<globus site option list 1> $\longrightarrow$ \.{Empty}.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option_list_1:  /* Empty  */  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option_list_1:  /* Empty  */.'"
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.clear();

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option_list_1:  globus_site_option_list_1 globus_site_option_1  @>

@ \<globus site option list 1> $\longrightarrow$ \<globus site option 1>.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option_list_1:  globus_site_option_list_1 globus_site_option_1 @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option_list_1:  "
             << "globus_site_option_list_1 globus_site_option_1'.'"
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option_1: INTERACTIVE_NODE_YY @>

@ \<globus site option 1> $\longrightarrow$ \.{INTERACTIVE\_NODE\_YY}.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option_1: INTERACTIVE_NODE_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option_1:  INTERACTIVE_NODE_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.interactive_node_name = "XXX";

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option_1: APPEND_LD_LIBRARY_PATH_YY @>

@ \<globus site option 1> $\longrightarrow$ \.{APPEND\_LD\_LIBRARY\_PATH\_YY}.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option_1: APPEND_LD_LIBRARY_PATH_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option_1:  APPEND_LD_LIBRARY_PATH_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.append_ld_library_path = "XXX";

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option_1: APPEND_PATH_YY @>

@ \<globus site option 1> $\longrightarrow$ \.{APPEND\_PATH\_YY}.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option_1: APPEND_PATH_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option_1:  APPEND_PATH_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.append_path = "XXX";

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option_1: OPTDBCLI_PATH_YY @>

@ \<globus site option 1> $\longrightarrow$ \.{OPTDBCLI\_PATH\_YY}.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option_1: OPTDBCLI_PATH_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option_1:  OPTDBCLI_PATH_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.optdbcli_path = "XXX";

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option_1: IP_ADDRESS_YY @>

@ \<globus site option 1> $\longrightarrow$ \.{IP\_ADDRESS\_YY}.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option_1: IP_ADDRESS_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option_1:  IP_ADDRESS_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.ip_address = "XXX";

    @=$$@> = 0;

     

};

@q **** (4) globus_site_option_1: INTERACTIVE_NODE_IP_ADDRESS_YY @>

@ \<globus site option 1> $\longrightarrow$ \.{INTERACTIVE\_NODE\_IP\_ADDRESS\_YY}.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=globus_site_option_1: INTERACTIVE_NODE_IP_ADDRESS_YY @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `globus_site_option_1:  INTERACTIVE_NODE_IP_ADDRESS_YY'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->globus_site_options.interactive_node_ip_address = "XXX";

    @=$$@> = 0;

     

};

@q **** (4) statement:  SHOW_YY PRIVILEGES_YY USER_YY html_optional @>

@ \<statement> $\longrightarrow$ \.{SHOW\_YY} \.{PRIVILEGES\_YY} 
\.{USER\_YY} \<html optional>.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SHOW_YY PRIVILEGES_YY USER_YY html_optional@> 
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  SHOW_YY PRIVILEGES_YY "
             << "USER_YY html_optional'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    Response_Type response;
 
    response.type = Response_Type::SHOW_PRIVILEGES_TYPE;
    response.privileges_user  = true;

    response.output_format = @=$4@>;

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

     

};

@q **** (4) statement:  SHOW_YY PRIVILEGES_YY ALL_YY html_optional@>

@ \<statement> $\longrightarrow$ \.{SHOW\_YY} \.{PRIVILEGES\_YY} 
\.{ALL\_YY} \<html optional>.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SHOW_YY PRIVILEGES_YY ALL_YY html_optional@> 
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    
    

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `statement:  SHOW_YY PRIVILEGES_YY "
             << "ALL_YY html_optional'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    Response_Type response;
 
    response.type = Response_Type::SHOW_PRIVILEGES_TYPE;
    response.privileges_all  = true;
    response.output_format = @=$4@>;

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

};

@ Putting parser together.
@c
@=%{@>
@<Include files@>@;@/
using namespace std;
@<Declarations of additional functions@>@;@/
#if 0 
@<Garbage@>@;@/
#endif 
@=%}@>
@<Options@>@;@/
@<|union| declaration@>@;@/
@<Token and type declarations@>@;@/
@=%%@>
@q Rules @>
@<Rules@>@;@/

@q * (1) Emacs-Lisp code for use in indirect buffers  @>

@q (progn (cweb-mode) (outline-minor-mode) (setq abbrev-mode t)        @>

@q * (1) Local variables for Emacs @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q abbrev-mode:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>

