@q spptkyfn.web  @>
@q Created by Laurence D. Finston (LDF) Fri Jan 13 10:52:38 CET 2012 @>

@q * (1) Top @>

@q * (1) Copyright and License.@>

@q This file is part of the OptiNum Grid Installer @>
@q Copyright (C) 2010, 2011, 2012, 2013 Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen @>

@q The OptiNum Grid Installer is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q The OptiNum Grid Installer is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License          @>
@q along with the OptiNum Grid Installer; if not, write to the Free Software                    @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gwdg.de@>

@q Laurence D. Finston                                                   @>
@q Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen  @>
@q Am Fassberg 11         					         @>
@q 37077 Goettingen              					 @>
@q Germany                           					 @>                                

@q Laurence.Finston@@gwdg.de (@@ stands for a single "at" sign.)@>

@q ** (2)  spptkyfn.web @>
@ {\bf Scan\_Parse\_Parameter\_Type} functions for use with GPG.

\LOG
\initials{LDF 2012.01.13.}
Created this file.  It contains the definitions of |Scan_Parse_Parameter_Type| 
member functions for use with GPG (The GNU Privacy Guard).
\ENDLOG 

@q ** (2) Include files  @>

@ Include files.

@<Include files@>=
#include <stdlib.h>  /* Standard Library for C  */
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <limits.h>

#include <algorithm> /* Standard Template Library (STL) for C++  */
#include <fstream> 
#include <iomanip>
#include <ios>
#include <iostream>
#include <map>
#include <string>
#include <time.h>
#include <math.h>
#include <sstream>  

#include <set>
#include <vector>
#include <deque>


#include <pthread.h>  /* POSIX threads  */

#include <gcrypt.h> /* for |gcry_control| */
#include <gnutls/gnutls.h>

#if HAVE_CONFIG_H
#include <config.h>
#endif 

#if IS_ROCKS_GOEGRID
#undef HAVE_LIBMYSQLCLIENT
#endif 

#if HAVE_LIBMYSQLCLIENT
#include <mysql.h>
#endif 

#include "entries.h++"  /* Headers generated from CWEB files belonging to this package  */
#include "dstngnmt.h++"

#include "glblvrbl.h++"  
#include "glblfncs.h++"
#include "utilfncs.h++"
#include "parser.h++"    
#include "scanner.h++"
#include "x509cert.h++"
#include "rspnstp.h++"
#include "thrdfncs.h++"
#include "sssndttp.h++"
#include "glsinftp.h++"
#include "scprpmtp.h++"

@q **** (4) Get Key Name.  @>

@ Get Key Name.
\initials{LDF 2011.01.27.}

\LOG
\initials{LDF 2011.01.27.}
Added this function.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::get_key_name| definition@>=

#if HAVE_LIBMYSQLCLIENT
string
Scan_Parse_Parameter_Type::get_key_name(const string& owner)
{

@q ****** (6) @>

    int status = 0;

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    stringstream sql_strm;

    string key_name;

    MYSQL_RES *result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "Entering `Scan_Parse_Parameter_Type::get_key_name'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    if (owner.empty())
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "WARNING!  In `Scan_Parse_Parameter_Type::get_key_name':"
             << endl
             << "`owner' is empty.  Can't query database for `key_name'."
             << endl
             << "Exiting function unsuccessfully with empty `string' "
             << "as return value."
             << endl;
        unlock_cerr_mutex(); 

        return key_name;

    }  /* |if (owner.empty())|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_key_name| definition@>=

    sql_strm << "select key_name from Public_Keys where key_name = '"
             << owner << "'";

    
    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::get_key_name':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with empty `string' as return value."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return key_name;


    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_key_name':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_key_name':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) |owner| unknown.@>

@ |owner| unknown.
\initials{LDF 2011.01.27.}

@<|Scan_Parse_Parameter_Type::get_key_name| definition@>=

    if (row_ctr == 0)  /* |owner| unknown  */
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_key_name':  "
             << "`owner' is unknown."
             << endl 
             << "Exiting function unsuccessfully with empty `string' as return value."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        return key_name;

    }  /* |if (row_ctr == 0)| (|owner| unknown)  */

@
@<|Scan_Parse_Parameter_Type::get_key_name| definition@>=

    else /* |row_ctr > 0| (|owner| known)  */
    {
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::get_key_name':  "
                << "`owner' known."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

    }  /* |else| (|row_ctr > 0|, |owner| known)  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_key_name| definition@>=

    if ((curr_row = mysql_fetch_row(result)) == 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_key_name':"
             << endl 
             << "`mysql_fetch_row' failed:"
             << endl
             << mysql_error(mysql_ptr)
             << endl 
             << "Exiting function unsuccessfully with empty `string' as return value."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        return key_name;

    }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_key_name| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_key_name':"
             << endl 
             << "`curr_row[0]' == " << curr_row[0]
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    if (curr_row[0])
    {
       key_name = curr_row[0];

       mysql_free_result(result);
    
       return key_name;
    }
    else 
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
              << "ERROR!  In `Scan_Parse_Parameter_Type::get_key_name':"
              << endl 
              << "`curr_row[0]' == NULL."
              << endl 
              << "Exiting function unsuccessfully with empty `string' as return value."
              << endl;
        unlock_cerr_mutex(); 

        mysql_free_result(result);

        return key_name;

    }  /* |else|  */

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::get_key_name| definition  */

#endif 



@q **** (4) Store Key_Pair.  @>

@ Store \.{Key\_Pair}.
\initials{LDF 2011.11.04.}

\LOG
\initials{LDF 2011.11.04.}
Added this function.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>=

#if HAVE_LIBMYSQLCLIENT
int
Scan_Parse_Parameter_Type::store_key_pair(const char *filename)
{

@q ****** (6) @>

    int status = 0;

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    stringstream sql_strm;

    MYSQL_RES *result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    bool replaced_key_pair = false;

    int next_key_pair_id = 0;
    int key_pair_id      = 0;

    if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "Entering `Scan_Parse_Parameter_Type::store_key_pair'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    string curr_dn;
  
    int curr_user_id;

    if (effective_user_id > 0)
       curr_user_id = effective_user_id;
    else
       curr_user_id = user_id;

    if (!effective_user_dn.empty())
       curr_dn = effective_user_dn;
    else
       curr_dn = user_dn;

    if (curr_dn.empty())
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
             << endl 
             << "`curr_dn' is empty."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        return 1;

    }  /* |if (curr_dn.empty())|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::store_key_pair':"
             << endl 
             << "`curr_dn' == " << curr_dn << "."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 

    if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "In `Scan_Parse_Parameter_Type::store_key_pair':" << endl 
             << "user_id == " << user_id << endl
             << "effective_user_id == " << effective_user_id << endl
             << "user_name == " << user_name << endl
             << "effective_user_name == " << effective_user_name << endl
             << "user_dn == " << user_dn << endl
             << "effective_user_dn == " << effective_user_dn << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) Open |filename| for reading.  @>

@ Open |filename| for reading.  
\initials{LDF 2011.11.04.}

@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>=

   FILE *fp = fopen(filename, "r");

   if (fp == 0)
   {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
             << endl 
             << "Failed to open `" << filename << "' for reading:"
             << endl;

        perror("fopen error");

        cerr << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        return 1;

   }  /* |if (fp == 0)|  */

   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::store_key_pair':"
            << endl 
            << "Opened `" << filename << "' successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>=   

   sql_strm << "select key_pair_id from Key_Pairs where user_id = " << curr_user_id 
            << " and "
            << "key_name = '" << curr_dn << "'";

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::store_key_pair':"
            << endl 
            << "`sql_strm.str()' == " << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

   status = submit_mysql_query(sql_strm.str(),
                               result, 
                               &row_ctr, 
                               &field_ctr);

   
   sql_strm.str("");
 
   if (status)
   {
       lock_cerr_mutex(); 
       cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
            << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;

   }  /* |if (status)|  */

   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::store_key_pair':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

@q ****** (6) @>

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::store_key_pair':"
            << endl 
            << "row_ctr == " << row_ctr 
            << endl
            << "field_ctr == " << field_ctr 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

@q ****** (6) @>

   if (row_ctr == 0)  /* No rows  */
   {
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned 0 rows."
                << endl
                << "No existing row.  Will insert."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 

@q ******* (7) @>

       mysql_free_result(result);
       result = 0;

       sql_strm.str("");

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>=

       sql_strm << "select key_pair_id from Key_Pairs order by key_pair_id desc";

       status = submit_mysql_query(sql_strm.str(),
                                   result, 
                                   &row_ctr, 
                                   &field_ctr);

    
       sql_strm.str("");
 
       if (status)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                << status << "."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           return 1;

       }  /* |if (status)|  */

       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

@q ******* (7) @>

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "row_ctr == " << row_ctr 
                << endl
                << "field_ctr == " << field_ctr 
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

@q ****** (6) @>

       if (row_ctr == 0)  /* No rows  */
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "WARNING!  In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned 0 rows."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           return 1;

       }  /* |if (row_ctr == 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>=

       if ((curr_row = mysql_fetch_row(result)) == 0)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`mysql_fetch_row' failed:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           if (result)
              mysql_free_result(result);

           return 1;

       }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>=

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`curr_row[0]' == " << curr_row[0]
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>=

       next_key_pair_id = strtol(curr_row[0], (char **) 0, 10);

@q ******* (7) @>

       if (next_key_pair_id == LONG_MIN)
       {

           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`strtol' failed, returning "
                << "`LONG_MIN' (underflow):"
                << endl;
          
           perror("strtol error");
          
           cerr << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           return 1;

       }  /* |if (next_key_pair_id == LONG_MIN)|  */

@q ******* (7) @>

       else if (next_key_pair_id == LONG_MAX)
       {

           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`strtol' failed, returning "
                << "`LONG_MAX' (overflow):"
                << endl;
          
           perror("strtol error");
          
           cerr << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           return 1;

       }  /* |else if (next_key_pair_id == LONG_MAX)|  */

@q ******* (7) @>

       else if (next_key_pair_id < 0)
       {

           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`next_key_pair_id' == " << next_key_pair_id << " (< 0)."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           return 1;

       }  /* |else if (next_key_pair_id < 0)|  */

@q ******* (7) @>

       ++next_key_pair_id;
       key_pair_id = next_key_pair_id;

       mysql_free_result(result);
       result = 0;

@q ******* (7) @>

    if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "In `Scan_Parse_Parameter_Type::store_key_pair':" << endl 
             << "`next_key_pair_id' == " << next_key_pair_id << "." << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */


@q ******* (7) @>

   }  /* |if (row_ctr == 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>=

   else /* |row_ctr > 0|  */
   {
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned " 
                << row_ctr << " rows."
                << endl
                << "Existing row.  Will replace."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 

       replaced_key_pair = true;

@q ******* (7) @>

       if ((curr_row = mysql_fetch_row(result)) == 0)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`mysql_fetch_row' failed:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           if (result)
              mysql_free_result(result);

           return 1;

       }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>=

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`curr_row[0]' == " << curr_row[0]
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>=

       key_pair_id = strtol(curr_row[0], (char **) 0, 10);

@q ******* (7) @>

       if (key_pair_id == LONG_MIN)
       {

           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`strtol' failed, returning "
                << "`LONG_MIN' (underflow):"
                << endl;
          
           perror("strtol error");
          
           cerr << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           return 1;

       }  /* |if (key_pair_id == LONG_MIN)|  */

@q ******* (7) @>

       else if (key_pair_id == LONG_MAX)
       {

           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`strtol' failed, returning "
                << "`LONG_MAX' (overflow):"
                << endl;
          
           perror("strtol error");
          
           cerr << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           return 1;

       }  /* |else if (key_pair_id == LONG_MAX)|  */

@q ******* (7) @>

       else if (key_pair_id < 0)
       {

           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`key_pair_id' == " << key_pair_id << " (< 0)."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           return 1;

       }  /* |else if (key_pair_id < 0)|  */


@q ******* (7) @>       

   }   /* |else| (|row_ctr > 0|)  */

   if (result)
      mysql_free_result(result);
   result = 0;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>=

   const unsigned int BUFFER_SIZE = 65536;  /* $2^{16}$  */

   char buffer[BUFFER_SIZE];
 
   bool first_time = true;

   int chars_read = 0;

   do
   {
       memset(buffer, 0, BUFFER_SIZE);

       chars_read = fread(buffer, 1, BUFFER_SIZE - 1, fp);

       if (chars_read ==  0)
       {
            lock_cerr_mutex(); 
            cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
                 << endl 
                 << "`fread' failed to read from `" << filename << "', returning 0."
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            fclose(fp);

            return 1;
           
       }
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "Read " << chars_read << " characters from `" << filename << "':"
                << endl
                << buffer
                << endl << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */ 


       if (first_time)
       {
           sql_strm << "replace into Key_Pairs (key_pair_id, user_id, "
                    << "key_name, key_pair) "
                    << "values (" << key_pair_id << ", " << curr_user_id << ", '"
                    << curr_dn << "', '" << buffer << "')";

           first_time = false;
       }
       else
       {
           sql_strm << "update Key_Pairs set key_pair = "
                    << "concat(key_pair, '" << buffer << "') where "
                    << "key_pair_id = " << key_pair_id;

       }

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "sql_strm.str() == " << endl << sql_strm.str()
                << endl;
            unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 


       status = submit_mysql_query(sql_strm.str(), result, 0, 0);
   
       sql_strm.str("");
 
       if (status)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                << status << "."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           return 1;

       }  /* |if (status)|  */

       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::store_key_pair':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

       mysql_free_result(result);
       result = 0;


   } /* |do|  */

   while(chars_read == BUFFER_SIZE - 1);

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>=

   fclose(fp);
   fp = 0;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "Exiting `Scan_Parse_Parameter_Type::store_key_pair' successfully "
             << "with return value ";

        if (replaced_key_pair)
           cerr << "2." << endl;
        else
           cerr << "0." << endl;

        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

    if (replaced_key_pair)
       return 2;
    else
       return 0;

}  /* End of |Scan_Parse_Parameter_Type::store_key_pair| definition  */

#endif 

@q **** (4) Store Public Key.  @>

@ Store public key.

\LOG
\initials{LDF 2011.12.12.}
Added this function.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::store_public_key| definition@>=

#if HAVE_LIBMYSQLCLIENT
int
Scan_Parse_Parameter_Type::store_public_key(const char *filename)
{

@q ****** (6) @>

    int status = 0;

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    bool replaced_public_key = false;

    stringstream sql_strm;

    MYSQL_RES *result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "Entering `Scan_Parse_Parameter_Type::store_public_key'."
             << endl;

        cerr << "filename == " << filename << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) Error handling:  Neither |user_id| nor |effective_user_id| is set.  @>

@ Error handling:  Neither |user_id| nor |effective_user_id| is set.  
This should never happen.
\initials{LDF 2011.12.16.}

@<|Scan_Parse_Parameter_Type::store_public_key| definition@>=

    int curr_user_id = (effective_user_id > 0) ? effective_user_id : user_id;

    if (DEBUG)
    {
        cerr << "user_id == " << user_id << endl;
        cerr << "effective_user_id == " << effective_user_id << endl;
        cerr << "curr_user_id == " << curr_user_id << endl;

    }  /* |if (DEBUG)|  */ 

    if (curr_user_id <= 0)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "ERROR!  In `Scan_Parse_Parameter_Type::store_public_key':"
             << endl 
             << "`curr_user_id' == " << curr_user_id
             << endl 
             << "Could not identify user."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        return 1;

    }  /* |if (curr_user_id <= 0)|  */


@q ****** (6) Error handling:  |key_id| is not set.  @>

@ Error handling:  |key_id| is not set.
\initials{LDF 2011.12.16.}

@<|Scan_Parse_Parameter_Type::store_public_key| definition@>=

    if (DEBUG)
    {
        cerr << "key_id == " << key_id << endl;

    }  /* |if (DEBUG)|  */ 

    if (key_id <= 0)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "ERROR!  In `Scan_Parse_Parameter_Type::store_public_key':"
             << endl 
             << "`key_id' == " << key_id
             << endl 
             << "Invalid value for `key_id'."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        return 1;

    }  /* |if (key_id <= 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_public_key| definition@>=

    string curr_dn = (effective_user_dn.empty()) 
                     ? user_dn : effective_user_dn;

    if (curr_dn.empty())
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "ERROR!  In `Scan_Parse_Parameter_Type::store_public_key':"
             << endl 
             << "`user_dn' and `effective_user_dn' are both empty."
             << endl
             << "Can't store public key."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        return 1;

    }
    else if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "In `Scan_Parse_Parameter_Type::store_public_key':"
             << endl 
             << "`curr_dn' == " << curr_dn
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_public_key| definition@>=

    FILE *fp = fopen(filename, "r");

    if (fp == 0)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "ERROR!  In `Scan_Parse_Parameter_Type::store_public_key':"
             << endl 
             << "`fopen' failed, returning NULL:"
             << endl << strerror(errno) << endl
             << "Failed to open `" << filename << "'."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        return 1;

    }  /* |if (fp == 0)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "In `Scan_Parse_Parameter_Type::store_public_key':"
             << endl 
             << "`fopen' opened `" << filename << "' successfully."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 

@q ****** (6) @>
 
    char buffer[4096];  /* $2^{12}$  */

    memset(buffer, 0, 4096);

    status = fread(buffer, 1, 4096, fp);

    if (status == 0)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "ERROR!  In `Scan_Parse_Parameter_Type::store_public_key':"
             << endl 
             << "`fread' failed, returning 0."
             << endl 
             << "Failed to read from `" << filename << "'."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        fclose(fp);

        return 1;

    }
    else if (status == 4096)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "ERROR!  In `Scan_Parse_Parameter_Type::store_public_key':"
             << endl 
             << "`fread' read 4096 characters."
             << endl 
             << "This is not permitted:  `" << filename << "' is too large."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        fclose(fp);

        return 1;

    }
    else if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "In `Scan_Parse_Parameter_Type::store_public_key':"
             << endl 
             << "`fread' read " << status << " characters."
             << endl
             << "`buffer' == " << endl
             << buffer
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 

    fclose(fp);

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_public_key| definition@>=

    if (DEBUG)
    {
        cerr << "strlen(buffer) == " << strlen(buffer) << endl;
        
        cerr << "buffer[strlen(buffer) - 1] == " << static_cast<int>(buffer[strlen(buffer) - 1])  
             << endl;
        cerr << "buffer[strlen(buffer) - 2] == " << static_cast<int>(buffer[strlen(buffer) - 2])  
             << endl;

        cerr << "(buffer[strlen(buffer) - 1] == '\\n' "
             << "&& buffer[strlen(buffer) - 2] == '\\n') == " 
             << (   buffer[strlen(buffer) - 1] == '\n' 
                 && buffer[strlen(buffer) - 2] == '\n') 
             << endl;

    }  /* |if (DEBUG)|  */ 

    if (   buffer[strlen(buffer) - 1] == '\n' 
        && buffer[strlen(buffer) - 2] == '\n')
    {
        buffer[strlen(buffer) - 1] = '\0';
    }

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_public_key| definition@>=

    sql_strm << "select key_id from Public_Keys where user_id = " << curr_user_id 
            << " and "
            << "key_name = '" << curr_dn << "'";

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::store_public_key':"
             << endl 
             << "`sql_strm.str()' == " << sql_strm.str()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

   
    sql_strm.str("");
 
    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::store_public_key':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        return 1;

    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::store_public_key':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::store_public_key':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_public_key| definition@>=

@q ****** (6) @>

   if (row_ctr == 0)  /* No rows  */
   {
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::store_public_key':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned 0 rows."
                << endl
                << "No existing row.  Will insert."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 

@q ******* (7) @>

       mysql_free_result(result);
       result = 0;

       sql_strm.str("");

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::store_public_key| definition@>=

       sql_strm << "insert into Public_Keys (user_id, key_name, key_id) values "
                << "(" << curr_user_id << ", '" << curr_dn << "', " << key_id << ")";

       STORE_PUBLIC_KEY_SUBMIT_SQL_QUERY:

       if (DEBUG)
       {

           cerr << "sql_strm.str() == " << sql_strm.str() << endl;

       }  /* |if (DEBUG)|  */ 


       status = submit_mysql_query(sql_strm.str(),
                                   result, 
                                   0,
                                   0);

    
       sql_strm.str("");
 
       if (status)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::store_public_key':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                << status << "."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           return 1;

       }  /* |if (status)|  */

       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::store_public_key':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

       mysql_free_result(result);
       result = 0;


   }  /* |if (row_ctr == 0)|  */

@q ****** (6) |row_ctr > 0|.  Public key already in database table.  @>

@ |row_ctr > 0|.  Public key already in database table.
\initials{LDF 2011.12.16.}

@<|Scan_Parse_Parameter_Type::store_public_key| definition@>=

@q ****** (6) @>

   else  /* |row_ctr > 0|  */ 
   {
@q ******* (7) @>

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::store_public_key':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned " 
                << row_ctr << " rows."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 

@q ******* (7) @>

       if ((curr_row = mysql_fetch_row(result)) == 0)
       {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
                << "ERROR!  In `Scan_Parse_Parameter_Type::store_public_key':"
                << endl 
                << "`mysql_fetch_row' failed:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           if (result)
              mysql_free_result(result);

           return 1;

       }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::store_public_key| definition@>=

       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::store_public_key':"
                << endl 
                << "`curr_row[0]' == " << curr_row[0]
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */

@q ******* (7) @>

       errno = 0;
       unsigned long int curr_key_id = strtoul(curr_row[0], 0, 0);

       if (curr_key_id == ULONG_MAX)
       {

           lock_cerr_mutex();
           cerr << "[Thread " << thread_ctr 
                << "] ERROR!  In `Scan_Parse_Parameter_Type::store_public_key':  "
                << endl 
                << "`strtoul' failed to convert `curr_row[0]' to `unsigned long int', "
                << endl
                << "returning `ULONG_MAX'."
                << endl;

           if (errno != 0)
               cerr << "strtoul error:  " << strerror(errno)
                    << endl;

           cerr << "`curr_row[0]' == " << curr_row[0]
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           return 1;

       }  /* |if (curr_key_id == ULONG_MAX)|  */

       else if (DEBUG)
       {
           lock_cerr_mutex();
           cerr << "[Thread " << thread_ctr 
                << "] In `Scan_Parse_Parameter_Type::store_public_key':  "
                << endl 
                << "`curr_key_id' == " << curr_key_id
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */ 

@q ******* (7) @>

       if (curr_key_id == key_id)
       {
@q ******** (8) @>

            if (DEBUG)
            {
                lock_cerr_mutex();
                cerr << "[Thread " << thread_ctr 
                     << "] In `Scan_Parse_Parameter_Type::store_public_key':  "
                     << endl 
                     << "`curr_key_id' == `key_id' == " << key_id
                     << endl
                     << "Not replacing entry in `Public_Keys' table."
                     << endl
                     << "Exiting function successfully with return value 4."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */ 

@q ******** (8) @>

            mysql_free_result(result);

            return 4;

@q ******** (8) @>

       }  /* |if (curr_key_id == key_id)|  */

@q ******* (7) @>

       else /* |curr_key_id != key_id|  */
       {
@q ******** (8) @>

            if (DEBUG)
            {
                lock_cerr_mutex();
                cerr << "[Thread " << thread_ctr 
                     << "] In `Scan_Parse_Parameter_Type::store_public_key':  "
                     << endl 
                     << "`curr_key_id' != `key_id':"
                     << endl
                     << "`curr_key_id' == " << curr_key_id
                     << endl
                     << "`key_id'      == " << key_id
                     << endl 
                     << "Replacing entry in `Public_Keys' table."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */ 


           mysql_free_result(result);
           result = 0;

           sql_strm.str("");

           sql_strm << "update Public_Keys set key_id = " << key_id 
                    << " where user_id = " << curr_user_id;

           replaced_public_key = true;

           goto STORE_PUBLIC_KEY_SUBMIT_SQL_QUERY;
       

@q ******** (8) @>

       } /* |else| (|curr_key_id != key_id|)  */

@q ******* (7) @>

   }  /* |else| (|row_ctr > 0|)  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_public_key| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << thread_ctr << "] "
             << "Exiting `Scan_Parse_Parameter_Type::store_public_key' successfully "
             << "with return value ";

        if (replaced_public_key)
             cerr << "2." << endl;
        else
             cerr << "0." << endl;

        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

    if (replaced_public_key)
       return 2;
    else
       return 0;


    return 0;

}  /* End of |Scan_Parse_Parameter_Type::store_public_key| definition  */

#endif 

@q **** (4) Fetch key pair. @>

@ Fetch key pair.
\initials{LDF 2011.11.10.}

\LOG
\initials{LDF 2011.11.10.}
Added this function.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::fetch_key_pair(Response_Type& response)
{
@q ****** (6) @>

   int status;
   int DEBUG = false;  /* |true|  */

   MYSQL_RES* result = 0;
   unsigned int row_ctr       = 0;
   unsigned int field_ctr     = 0;
   
   MYSQL_ROW curr_row;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::fetch_key_pair'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

   stringstream sql_strm;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `fetch_key_pair':"
            << endl 
            << "user_id == " << user_id 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

    sql_strm << "select key_pair, key_name from Key_Pairs where user_id = " 
             << user_id;

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "] "
             << "In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl 
             << "`sql_strm.str()' == " << sql_strm.str()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return 1;


    }  /* |if (status)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) No rows.  @>

@ No rows.
\initials{LDF 2011.11.14.}

@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

    if (row_ctr == 0)  /* No rows  */
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_key_pair':  "
             << "`user_name' is unknown."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        return 1;

    }  /* |if (row_ctr == 0)| (No rows)  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

    else /* |row_ctr > 0|  */
    {
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::fetch_key_pair':  "
                << "`key_pair' found."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */


    }  /* |else| (|row_ctr > 0|)  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

    if ((curr_row = mysql_fetch_row(result)) == 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl 
             << "`mysql_fetch_row' failed:"
             << endl
             << mysql_error(mysql_ptr)
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        return 1;

    }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

    if (!(   curr_row[0] && curr_row[1]
          && strlen(curr_row[0]) && strlen(curr_row[1])))
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl 
             << "Failed to extract data from database:"
             << endl 
             << "`curr_row[0]' == NULL and/or `curr_row[1]' == NULL "
             << "and/or `curr_row[0]' is empty and/or `curr_row[1]' is empty."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        mysql_free_result(result);

        return 1;

    }  /* |if|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl 
             << "`curr_row[0]' == " << curr_row[0]
             << endl
             << "`curr_row[1]' == " << curr_row[1]
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

    char temp_filename[2][14] = {"/tmp/KKXXXXXX", "/tmp/KKXXXXXX"};

    int fd[2];

    fd[0] = mkstemp(temp_filename[0]);
    fd[1] = mkstemp(temp_filename[1]);

    if (fd[0] == -1 || fd[1] == -1)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl 
             << "`mkstemp' failed, returning -1."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        mysql_free_result(result);

        close(fd[0]);
        close(fd[1]);

        return 1;

    }

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl 
             << "`mkstemp' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    close(fd[0]);
    close(fd[1]);

    ofstream key_pair_strm;

    key_pair_strm.open(temp_filename[0]);

    if (!key_pair_strm)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl 
             << "`ofstream::open' failed.  Couldn't open `key_pair_strm'."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        mysql_free_result(result);

        return 1;


    }  /* |if (!key_pair_strm)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl 
             << "Opened `ofstream key_pair_strm' successfully."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    key_pair_strm << curr_row[0];  

    if (key_pair_strm.bad())
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl 
             << "State of `ofstream key_pair_strm' is \"bad\"."
             << endl 
             << "Writing to it probably failed."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        mysql_free_result(result);

        return 1;

    }

    key_pair_strm.close();

    mysql_free_result(result);

    result = 0;

    stringstream system_strm;

    system_strm << "gpg --decrypt " << temp_filename[0] << " >| " 
                << temp_filename[1] << " 2>/dev/null";

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "`system_strm.str()' == " << system_strm.str() << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    status = system(system_strm.str().c_str());

    if (status == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)
    {
        lock_cerr_mutex();
        cerr << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl
             << "`system' failed to decrypt file "
             << "`" << temp_filename[0] << "'."
             << endl 
             << "`status' == " << status << endl
             << "`WIFEXITED(status)' == " << WIFEXITED(status) << endl;

        if (WIFEXITED(status))
             cerr << "WEXITSTATUS(status) == " << WEXITSTATUS(status) << endl;

        cerr << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 
 
        return 1;

    }  /* |if|  */

    else if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << "In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl
             << "`system' decrypted file "
             << "`" << temp_filename[0] << "' successfully."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 
  
    system_strm.str("");

    if (!save_temp_files)
       unlink(temp_filename[0]);

    response.local_filename = temp_filename[1];
    response.type    = Response_Type::KEY_PAIR_TYPE;

    stringstream temp_strm;

    temp_strm << "SERVER SENDING KEY_PAIR <" 
              << curr_row[1] << ">";

    response.command = temp_strm.str();

    temp_strm.str("");

    if (DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::fetch_key_pair':"
             << endl 
             << "`response.command' == " << response.command
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "Exiting `Scan_Parse_Parameter_Type::fetch_key_pair' "
             << "successfully with return value 0."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)| */

    return 0;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::fetch_key_pair| */

#endif /* |#if HAVE_LIBMYSQLCLIENT| */

@q **** (4) Get key pair. @>

@ Get key pair.
\initials{LDF 2011.11.23.}

This function is similar to |Scan_Parse_Parameter_Type::fetch_key_pair| 
(see above), but stores the encrypted key pair data and the key name in 
the |Scan_Parse_Parameter_Type| data members |key_pair_str| 
and |key_name|.
\par
|key_pair_str| is a |char| array of length |MAX_KEY_PAIR_SIZE|.  If 
the length of the string fetched from the database is greater than 
|MAX_KEY_PAIR_SIZE - 1|, |get_key_pair| fails, returning 1.

@:TODO@> !! TODO:  Add code for ensuring that the key pair isn't too
long when it's stored in the database.
\initials{LDF 2011.11.23.}

@:TODO@> !! TODO:  Combine this function with |fetch_key_pair| and 
make it possible to determine what's done with the key pair and key name.
\initials{LDF 2011.11.23.}

\LOG
\initials{LDF 2011.11.23.}
Added this function.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::get_key_pair| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::get_key_pair(void)
{
@q ****** (6) @>

   int status;
   int DEBUG = false;  /* |true|  */

   MYSQL_RES* result = 0;
   unsigned int row_ctr       = 0;
   unsigned int field_ctr     = 0;
   
   MYSQL_ROW curr_row;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::get_key_pair'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */

   unsigned int curr_user_id;
   string curr_user_name;

   if (effective_user_id > 0)
      curr_user_id = effective_user_id;
   else
      curr_user_id = user_id;

   if (!effective_user_name.empty())
      curr_user_name = effective_user_name;
   else
      curr_user_name = user_name;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_key_pair| definition@>=

   stringstream sql_strm;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `get_key_pair':"
            << endl 
            << "user_id == " << user_id 
            << endl 
            << "effective_user_id == " << effective_user_id 
            << endl 
            << "curr_user_id == " << curr_user_id 
            << endl
            << "user_name == " << user_name 
            << endl 
            << "effective_user_name == " << effective_user_name 
            << endl 
            << "curr_user_name == " << curr_user_name 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_key_pair| definition@>=

    sql_strm << "select key_pair, key_name from Key_Pairs where user_id = " 
             << curr_user_id;

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "] "
             << "In `Scan_Parse_Parameter_Type::get_key_pair':"
             << endl 
             << "`sql_strm.str()' == " << sql_strm.str()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_key_pair| definition@>=

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::get_key_pair':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return 1;


    }  /* |if (status)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_key_pair| definition@>=

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_key_pair':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_key_pair| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_key_pair':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) No rows.  @>

@ No rows.
\initials{LDF 2011.11.14.}

@<|Scan_Parse_Parameter_Type::get_key_pair| definition@>=

    if (row_ctr == 0)  /* No rows  */
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_key_pair':  "
             << "`user_name' is unknown."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        return 1;

    }  /* |if (row_ctr == 0)| (No rows)  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_key_pair| definition@>=

    else /* |row_ctr > 0|  */
    {
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]:  "
                << "In `Scan_Parse_Parameter_Type::get_key_pair':  "
                << "`key_pair' found."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */


    }  /* |else| (|row_ctr > 0|)  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_key_pair| definition@>=

    if ((curr_row = mysql_fetch_row(result)) == 0)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_key_pair':"
             << endl 
             << "`mysql_fetch_row' failed:"
             << endl
             << mysql_error(mysql_ptr)
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        return 1;

    }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_key_pair| definition@>=

    if (!(   curr_row[0] && curr_row[1]
          && strlen(curr_row[0]) && strlen(curr_row[1])))
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_key_pair':"
             << endl 
             << "Failed to extract data from database:"
             << endl 
             << "`curr_row[0]' == NULL and/or `curr_row[1]' == NULL "
             << "and/or `curr_row[0]' is empty and/or `curr_row[1]' is empty."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        mysql_free_result(result);

        return 1;

    }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_key_pair| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_key_pair':"
             << endl 
             << "`curr_row[0]' == " << curr_row[0]
             << endl
             << "`curr_row[1]' == " << curr_row[1]
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_key_pair| definition@>=

    if (strlen(curr_row[0]) > MAX_KEY_PAIR_SIZE - 1)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_key_pair':"
             << endl 
             << "`strlen(curr_row[0]' > MAX_KEY_PAIR_SIZE - 1 (" 
             << MAX_KEY_PAIR_SIZE << " - 1)."
             << endl 
             << "Key pair is too large.  Can't store it in `key_pair_str'."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        mysql_free_result(result);

        return 1;

    }  /* |if (strlen(curr_row[0]) > MAX_KEY_PAIR_SIZE)|  */

    strcpy(key_pair_str, curr_row[0]);
    key_name = curr_row[1];

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::get_key_pair':"
             << endl 
             << "Stored key pair in `key_pair_str' and key name in `key_name' "
             << "successfully."
             << endl 
             << "`key_name' == " << key_name 
             << endl
             << "`key_pair_str' == "
             << endl
             << key_pair_str
              << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 

    return 0;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::get_key_pair| */

#endif /* |#if HAVE_LIBMYSQLCLIENT| */



@q **** (4) Install key pair and set trust value.  @>

@ Install key pair and set trust value.
\initials{LDF 2011.11.14.}

\LOG
\initials{LDF 2011.11.14.}
Added this function.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::install_key_pair| definition@>=

int
Scan_Parse_Parameter_Type::install_key_pair(const char *key_name, 
                                            const char *filename)
{
@q ****** (6) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG); 

   int status;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Entering `Scan_Parse_Parameter_Type::install_key_pair'."
            << endl;
       unlock_cerr_mutex(); 


   }  /* |if (DEBUG)|  */ 


@q ****** (6) Call `gpg --list-keys' to set up the \.{.gnupg} directory, @>
@q ****** (6) if it doesn't already exist.                           @>

@ Call `gpg --list-keys' to set up the \.{.gnupg} directory,
if it doesn't already exist.                          
\initials{LDF 2011.11.16.}

\LOG
\initials{LDF 2011.11.16.}
Added this section.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG

@<|Scan_Parse_Parameter_Type::install_key_pair| definition@>=

   status = system("gpg --list-keys >/dev/null 2>/dev/null");

   if (status == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0 )
   {
       lock_cerr_mutex();
       cerr << "ERROR!  In `Scan_Parse_Parameter_Type::install_key_pair':"
            << endl
            << "`gpg --list-keys' failed."
            << "`status' == " << status << endl
            << "`WIFEXITED(status)' == " << WIFEXITED(status) << endl
            << endl;

        if (WIFEXITED(status))
        {
            cerr << "`WEXITSTATUS(status)' == " << WEXITSTATUS(status)
                 << endl 
                 << strerror(WEXITSTATUS(status))
                 << endl;
        }

        cerr << "Exiting function unsuccessfully with return value 1."
             << endl;

       unlock_cerr_mutex(); 
 
       return 1;

   }  /* |if|  */

   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::install_key_pair':"
            << endl
            << "`gpg --list-keys' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::install_key_pair| definition@>=

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::install_key_pair':"
            << endl
            << "`key_name' == " << key_name
            << endl
            << "`filename' == " << filename
            << endl;
       unlock_cerr_mutex(); 


   }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::install_key_pair| definition@>=

   bool already_installed = false;

   stringstream system_strm;

   system_strm << "gpg --import " << filename << " >/dev/null 2>&1";

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::install_key_pair':"
            << endl
            << "`system_strm.str()' == " << system_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 


   status = system(system_strm.str().c_str());

   if (status == -1 || !WIFEXITED(status))
   {
       lock_cerr_mutex();
       cerr << "ERROR!  In `Scan_Parse_Parameter_Type::install_key_pair':"
            << endl
            << "`system' failed to install secret and/or public key from file `"
            << filename << "'."
            << endl 
            << "`status' == " << status << endl
            << "`WIFEXITED(status)' == " << WIFEXITED(status) << endl
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 
 
       return 1;

   }  /* |if (status == -1 || !WIFEXITED(status))|  */


   else if (!(WEXITSTATUS(status) == 0 || WEXITSTATUS(status) == 2))
   {

       lock_cerr_mutex();
       cerr << "ERROR!  In `Scan_Parse_Parameter_Type::install_key_pair':"
            << endl
            << "`system' failed to install secret and/or public key from file `"
            << filename << "."
            << endl 
            << "`status' == " << status << endl
            << endl
            << "`WEXITSTATUS(status)' == " << WEXITSTATUS(status)
            << endl
            << strerror(WEXITSTATUS(status))
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 
 
       return 1;
          
   }
   else if (WEXITSTATUS(status) == 2)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::install_key_pair':"
            << endl
            << "Secret and/or public key already installed."
            << endl 
            << "Continuing."
            << endl;
       unlock_cerr_mutex(); 

       already_installed = true;

   }  /* |else if (WEXITSTATUS(status) == 2)|  */

   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::install_key_pair':"
            << endl
            << "Installed secret and public keys."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */

   system_strm.str("");

@q ****** (6) Set trust.  @>

@ Set trust.  
\initials{LDF 2011.11.16.}

\LOG
\initials{LDF 2011.11.16.}
Added this section.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG

@:NOTE@> !! PLEASE NOTE:  The following shell command depends on the system 
on which the client program \.{optdbcli} is running handling \.{en\_US.UTF-8} 
as the value of the environment variable \.{LANG} properly.  That is, 
\.{gpg --fingerprint} should print out a line containing the word ``fingerprint''
(and not a translation into a different language), so that \.{grep} will 
extract the correct line. I think this should work on up-to-date Linux 
and other Unix-like systems.
\initials{LDF 2011.11.16.}

@<|Scan_Parse_Parameter_Type::install_key_pair| definition@>=

   system_strm << "printf \"%s:5\n\" `env LANG=en_US.UTF-8 gpg --fingerprint \""
               << key_name
               << "\" | grep fingerprint | cut -d\"=\" -f2 | tr -d \" \"` "
               << "| gpg --import-ownertrust >/dev/null 2>/dev/null";

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::install_key_pair':"
            << endl
            << "`system_strm.str()' == " << system_strm.str()
            << endl;
       unlock_cerr_mutex(); 


   }  /* |if (DEBUG)|  */ 

   status = system(system_strm.str().c_str());

   if (status == -1 || !WIFEXITED(status))
   {
       lock_cerr_mutex();
       cerr << "ERROR!  In `Scan_Parse_Parameter_Type::install_key_pair':"
            << endl
            << "`system' failed to set trust value for public key `" 
            << key_name << "'."
            << endl 
            << "`status' == " << status << endl
            << "`WIFEXITED(status)' == " << WIFEXITED(status) << endl
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 
 
       return 1;

   }  /* |if (status == -1 || !WIFEXITED(status))|  */


   else if (WEXITSTATUS(status) != 0)
   {

       lock_cerr_mutex();
       cerr << "ERROR!  In `Scan_Parse_Parameter_Type::install_key_pair':"
            << endl
            << "`system' failed to set trust value for public key `" 
            << key_name << "'."
            << endl 
            << "`status' == " << status << endl
            << endl
            << "`WEXITSTATUS(status)' == " << WEXITSTATUS(status)
            << endl
            << strerror(WEXITSTATUS(status))
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 
 
       return 1;
          
   }
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "In `Scan_Parse_Parameter_Type::install_key_pair':"
            << endl
            << "Set trust value for key `" << key_name << "' successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */

   system_strm.str("");

@q ****** (6) @>
@
\LOG
\initials{LDF 2011.11.17.}
Removed code for signing public key.  This can't be used, because the default key 
for signing might require a passphrase.  \.{optdbcli} has no influence over this.
One could use a non-standard GnuPG directory and the \.{--homedir} option to 
\.{gpg}, but there is no way to prevent a user from storing a private key with
a passphrase in it and having this private key be the default one for signing.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG 

@<|Scan_Parse_Parameter_Type::install_key_pair| definition@>=

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]:  "
            << "Exiting `Scan_Parse_Parameter_Type::install_key_pair' successfully "
            << "with return value 0."
            << endl;

       unlock_cerr_mutex(); 


   }  /* |if (DEBUG)|  */ 

   int return_val = 0;

   if (already_installed)
      return_val += 2;

   return return_val;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::install_key_pair| definition  */

@q **** (4) get_optinum_installer_gpg_pubkey_fingerprint.  @>


@ {\bf get\_optinum\_installer\_gpg\_pubkey\_fingerprint}.  
\initials{LDF 2011.11.21.}

\LOG
\initials{LDF 2011.11.21.}
Added this function.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::get_optinum_installer_gpg_pubkey_fingerprint| definition@>=

int
Scan_Parse_Parameter_Type::get_optinum_installer_gpg_pubkey_fingerprint(void)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG);

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "Entering `get_optinum_installer_gpg_pubkey_fingerprint'." << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_optinum_installer_gpg_pubkey_fingerprint| definition@>=

    stringstream system_strm;
    int status;

    system_strm << "env LANG=en_US.UTF-8 gpg --fingerprint \"optinum_installer (scrinstl)\" "
                << "2>&1";

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `get_optinum_installer_gpg_pubkey_fingerprint':" << endl
             << "system_strm.str() == " << system_strm.str() << endl;
        unlock_cerr_mutex(); 
    }  /* |if (DEBUG)|  */ 


    FILE *fp = popen(system_strm.str().c_str(), "r");

    if (fp == 0)
    {
         
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "ERROR!  In `get_optinum_installer_gpg_pubkey_fingerprint':"
             << endl
             << "`popen' failed to execute `gpg --list-keys'."
             << endl
             << "Exiting function unsuccessfully with "
             << "with return value 1." 
             << endl;
        unlock_cerr_mutex(); 

        return 1;


    }  /* |if (fp == 0)|  */
 
    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `get_optinum_installer_gpg_pubkey_fingerprint':"
             << endl
             << "`popen' succeeded."
             << endl;
        unlock_cerr_mutex(); 
    }  /* |else if (DEBUG)|  */ 


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_optinum_installer_gpg_pubkey_fingerprint| definition@>=

    char buffer[512];
    memset(buffer, 0, 512);

    status = fread(buffer, 1, 512, fp);

    if (status == 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "ERROR!  In `get_optinum_installer_gpg_pubkey_fingerprint':"
             << endl
             << "`fread' failed, returning 0."
             << endl
             << "Exiting function unsuccessfully with "
             << "with return value 1." 
             << endl;
        unlock_cerr_mutex(); 

        pclose(fp);

        return 1;

    }  /* |if (status == 0)|  */
 
    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `get_optinum_installer_gpg_pubkey_fingerprint':"
             << endl
             << "`fread' succeeded."
             << endl
             << "`buffer' == " << endl << buffer << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */       

    pclose(fp);
    fp = 0;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_optinum_installer_gpg_pubkey_fingerprint| definition@>=

    string result_str = buffer;
  
    if (DEBUG)
    {
        cerr << "result_str == " << result_str << endl;

    }  /* |if (DEBUG)|  */ 

    string::size_type s = result_str.find("error");

    if (s != string::npos)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "ERROR!  In `get_optinum_installer_gpg_pubkey_fingerprint':"
             << endl
             << "Failed to find fingerprint for public key "
             << "`optinum_installer (scrinstl)'."
             << endl
             << "Exiting function unsuccessfully with "
             << "with return value 1." 
             << endl;
        unlock_cerr_mutex(); 

        return 1;

    }  /* |if (s != string::npos)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `get_optinum_installer_gpg_pubkey_fingerprint':"
             << endl
             << "Found fingerprint for public key "
             << "`optinum_installer (scrinstl)'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */       

    
@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_optinum_installer_gpg_pubkey_fingerprint| definition@>=

    s = result_str.find("Key fingerprint");

    if (s == string::npos)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "ERROR!  In `get_optinum_installer_gpg_pubkey_fingerprint':"
             << endl
             << "Failed to extract fingerprint for public key "
             << "`optinum_installer (scrinstl)' from GnuPG output."
             << endl
             << "Exiting function unsuccessfully with "
             << "with return value 1." 
             << endl;
        unlock_cerr_mutex(); 

        return 1;

    }  /* |if (s != string::npos)|  */
 
    result_str.erase(0, s);

    if (DEBUG)
    {
       cerr << "result_str after first erase == " << result_str << endl;

    }  /* |if (DEBUG)|  */ 

    s = result_str.find("\n");

    if (s != string::npos)
        result_str.erase(s);

    if (DEBUG)
    {
       cerr << "result_str after second erase == " << result_str << endl;

    }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_optinum_installer_gpg_pubkey_fingerprint| definition@>=

    s = result_str.find_first_of("0123456789");

    if (s == string::npos)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "ERROR!  In `get_optinum_installer_gpg_pubkey_fingerprint':"
             << endl
             << "Failed to extract fingerprint for public key "
             << "`optinum_installer (scrinstl)' from `result_str'."
             << endl
             << "Exiting function unsuccessfully with "
             << "with return value 1." 
             << endl;
        unlock_cerr_mutex(); 

        return 1;

    }  /* |if (s != string::npos)|  */

    result_str.erase(0, s);

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `get_optinum_installer_gpg_pubkey_fingerprint':"
             << endl
             << "`result_str' == " << result_str
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    while((s = result_str.find_first_of(" \t")) != string::npos)
    {
        result_str.erase(s, 1);
    }

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `get_optinum_installer_gpg_pubkey_fingerprint':"
             << endl
             << "`result_str' after erasing blanks == " << result_str
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 

       
    optinum_installer_gpg_pubkey_fingerprint = result_str;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_optinum_installer_gpg_pubkey_fingerprint| definition@>=

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "Exiting `get_optinum_installer_gpg_pubkey_fingerprint' successfully "
             << "with return value 0." << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 


    return 0;

@q ****** (6) @>

}  /* End of 
      |Scan_Parse_Parameter_Type::get_optinum_installer_gpg_pubkey_fingerprint|  
      definition  */ 


@q **** (4) Distribute key pair.  @>

@ Distribute key pair.
\initials{LDF 2011.11.21.}

\LOG
\initials{LDF 2011.11.21.}
Added this function.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::distribute_key_pair| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::distribute_key_pair(Response_Type &response)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG); 

    int status = 0;

    if (DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "Entering `Scan_Parse_Parameter_Type::distribute_key_pair'." << endl;
        unlock_cerr_mutex(); 

    
    }  /* |if (DEBUG)|  */ 
    
@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::distribute_key_pair| definition@>=

    if (response.globus_site_set.size() == 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "ERROR!  In `Scan_Parse_Parameter_Type::distribute_key_pair':" << endl
             << "`response.globus_site_set.size()'  == 0."
             << endl
             << "Can't distribute key pair."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        return 1;

    }  /* |if (response.globus_site_set.size() == 0)| */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::distribute_key_pair':" << endl
             << "`response.globus_site_set.size()'  == "
             << response.globus_site_set.size() << "."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 

@q ****** (6) @>

    if (DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::distribute_key_pair':" << endl
             << "Showing `response.globus_site_set':"
             << endl;

        for (set<string>::const_iterator iter = response.globus_site_set.begin();
            iter != response.globus_site_set.end();
            ++iter)
        {
            cerr << *iter << endl;

        }  /* |for|  */

        cerr << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */         

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::distribute_key_pair| definition@>=

    unsigned int curr_user_id;
    string       curr_user_name;

    if (   (effective_user_id > 0 && effective_user_name.empty())
        || (effective_user_id == 0 && !effective_user_name.empty()))
    {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "]:  "
              << "ERROR!  In `Scan_Parse_Parameter_Type::distribute_key_pair':" 
              << endl
              << "`effective_user_id' > 0 && "
              << "`effective_user_name.empty()' == `true'"
              << endl 
              << "or `effective_user_id' == 0 "
              << "&& effective_user_name.empty() == `false'."
              << endl
              << "Mismatch:  Something has gone wrong with setting "
              << "the \"effective user\"."
              << endl
              << "Exiting function unsuccessfully with return value 1."
              << endl;
         unlock_cerr_mutex(); 

         return 1;        

    }  /* |if|  */

    if (effective_user_id > 0)
        curr_user_id = effective_user_id;
    else
        curr_user_id = user_id;

    if (!effective_user_name.empty())
        curr_user_name = effective_user_name;
    else
        curr_user_name = user_name;

    if (DEBUG)
    {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "]:  "
              << "In `Scan_Parse_Parameter_Type::distribute_key_pair':" 
              << endl
              << "`user_name' == " << user_name
              << endl
              << "`effective_user_name' == " << effective_user_name
              << endl 
              << "`curr_user_name' == " << curr_user_name
              << endl;
         unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::distribute_key_pair| definition@>=

    status = get_key_pair();

    if (status != 0)
    {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "]:  "
              << "ERROR!  In `Scan_Parse_Parameter_Type::distribute_key_pair':" 
              << endl
              << "`Scan_Parse_Parameter_Type::get_key_pair' failed, returning "
              << status << "."
              << endl
              << "Couldn't find key pair for user "
              << "`" << curr_user_name << "'."
              << endl
              << "Exiting function unsuccessfully with return value 1."
              << endl;
         unlock_cerr_mutex(); 

         return 1;


    }  /* |if (status != 0)|  */

    else if (DEBUG)
    {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "]:  "
              << "In `Scan_Parse_Parameter_Type::distribute_key_pair':" 
              << endl
              << "`Scan_Parse_Parameter_Type::get_key_pair' succeeded."
              << endl
              << "`key_name' == " << key_name
              << endl
              << "`key_pair_str' == " 
              << endl
              << key_pair_str
              << endl;
         unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::distribute_key_pair| definition@>=

    GPG_Key_Pair_Type gkpt[response.globus_site_set.size()];

    {
       int i = 0;

@q ****** (6) @>

       for (set<string>::const_iterator iter = response.globus_site_set.begin();
           iter != response.globus_site_set.end();
           ++iter)
       {
@q ******* (7) @>
          
           gkpt[i].param = this;
           gkpt[i].globus_site = *iter;
           gkpt[i].sub_thread_ctr = i;

           status = pthread_create(&(gkpt[i].ptid),
                           0, 
                           sub_distribute_key_pair,
                           static_cast<void*>(&gkpt[i]));

           ++i;

@q ******* (7) @>

       }  /* |for|  */

   }  /* End of group  */

@q ****** (6) @>

   for (int i = 0; i < response.globus_site_set.size(); ++i)
   {
@q ******* (7) @>

       void *temp_ptr = static_cast<void*>(&gkpt[i].return_value); 

       status = pthread_join(gkpt[i].ptid, static_cast<void**>(&temp_ptr));

       /* !! TODO:  LDF 2011.12.06.  Use |pthread_timedjoin_np|.   */

       if (status != 0)
       {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::distribute_key_pair':"
                 << endl 
                 << "`pthread_join' failed, returning " << status << ":"
                 << endl;

            perror("pthread_join error");
    
            cerr << "Exiting `Scan_Parse_Parameter_Type::distribute_key_pair' "
                 << "unsuccessfully with return value 1." 
                 << endl;
  
            unlock_cerr_mutex(); 

            return 1;

       }  /* |if (status != 0)|  */

@q ******* (7) @>

@ There's no need to handle the exit status of the sub-threads here, 
because |sub_distribute_key_pair| puts appropriate responses onto 
|response_deque|.
\initials{LDF 2011.12.07.}

@<|Scan_Parse_Parameter_Type::distribute_key_pair| definition@>=

       else if (DEBUG)
       {
            lock_cerr_mutex(); 
            cerr << "`pthread_join' succeeded for "
                 << "sub-thread " << i << " (id:  " << gkpt[i].ptid << ")." 
                 << endl 
                 << "`sub_distribute_key_pair' returned " 
                 << gkpt[i].return_value << "." 
                 << endl;
            unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */ 

@q ******* (7) @>

   }  /* |for|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::distribute_key_pair| definition@>=

    if (DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "Exiting `Scan_Parse_Parameter_Type::distribute_key_pair' "
             << "successfully with return value 0." 
             << endl;
         unlock_cerr_mutex(); 
    
    }  /* |if (DEBUG)|  */ 

@q ****** (6) @>

    return 0;

}  /* End of |Scan_Parse_Parameter_Type::distribute_key_pair| definition  */

#endif /* |HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Check public key.  @>

@ Check public key.
\initials{LDF 2011.12.12.}

This function is currently not used, but I'm leaving it here in case it 
may be useful sometime.
\initials{LDF 2011.12.12.}

\LOG
\initials{LDF 2011.12.12.}
Added this function.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::check_public_key| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::check_public_key(void)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG); 

    int status = 0;

    stringstream sql_strm;

    int curr_user_id = (effective_user_id > 0) ? effective_user_id : user_id;

    MYSQL_RES *result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    if (DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "Entering `Scan_Parse_Parameter_Type::check_public_key'." 
             << endl;
        unlock_cerr_mutex(); 
    
    }  /* |if (DEBUG)|  */ 
    
@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::check_public_key| definition@>=

    
    sql_strm << "select key_name, key_id from Public_Keys where user_id = "
             << curr_user_id;

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::check_public_key':" 
             << endl
             << "`sql_strm.str()' == " << sql_strm.str()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

@q ****** (6) @>

    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::check_public_key':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value -1."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return -1;


    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::check_public_key':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::check_public_key':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

    mysql_free_result(result);

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::check_public_key| definition@>=

    if (row_ctr == 0)
    {

        if (DEBUG)
        {

            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::check_public_key':"
                 << endl
                 << "Public key not found for user " << curr_user_id << "."
                 << endl 
                 << "Exiting function successfully with return value 0." 
                 << endl;
             unlock_cerr_mutex(); 
    
        }  /* |if (DEBUG)|  */ 

        return 0;

    }  /* |if (row_ctr == 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::check_public_key| definition@>=

    else /* |row_ctr > 0|  */
    {

        if (DEBUG)
        {

            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::check_public_key':"
                 << endl
                 << "Public key found for user " << curr_user_id << "."
                 << endl 
                 << "Exiting function successfully with return value 1." 
                 << endl;
             unlock_cerr_mutex(); 
    
        }  /* |if (DEBUG)|  */ 

        return 1;

    }  /* |else| (|row_ctr > 0|)  */

}  /* End of |Scan_Parse_Parameter_Type::check_public_key| definition  */

#endif /* |HAVE_LIBMYSQLCLIENT|  */

@q **** (4) Delete key pair.  @>

@ Delete key pair.
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this function.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::delete_key_pair| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::delete_key_pair(void)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG); 

    int status = 0;

    stringstream sql_strm;

    int curr_user_id = (effective_user_id > 0) ? effective_user_id : user_id;

    MYSQL_RES *result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    if (DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "Entering `Scan_Parse_Parameter_Type::delete_key_pair'." 
             << endl;
        unlock_cerr_mutex(); 
    
    }  /* |if (DEBUG)|  */ 
    
@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_key_pair| definition@>=

    sql_strm << "select key_pair_id from Key_Pairs where user_id = "
             << curr_user_id;

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_key_pair':" 
             << endl
             << "`sql_strm.str()' == " << sql_strm.str()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

@q ****** (6) @>

    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::delete_key_pair':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return 1;


    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_key_pair':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_key_pair':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>    
@
@<|Scan_Parse_Parameter_Type::delete_key_pair| definition@>=

    if (row_ctr == 0)
    {
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::delete_key_pair':"
                 << endl 
                 << "row_ctr == 0.  No key pair for `user_id` " << curr_user_id
                 << endl
                 << "Exiting function successfully with return value 3."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */

        mysql_free_result(result);

        return 3;

    }  /* |if (row_ctr == 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_key_pair| definition@>=

    mysql_free_result(result);

    result = 0;

    sql_strm.str("");

    sql_strm << "delete from Key_Pairs where user_id = " << curr_user_id;


    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_key_pair':" 
             << endl
             << "`sql_strm.str()' == " << sql_strm.str()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 


    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                0, 
                                0);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::delete_key_pair':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return 1;


    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_key_pair':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */
       
    mysql_free_result(result);
    result = 0;

@q ****** (6) @>

    if (DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::check_public_key':"
             << endl
             << "Exiting function successfully with return value 0." 
             << endl;
         unlock_cerr_mutex(); 
    
    }  /* |if (DEBUG)|  */ 

    return 0;


}  /* End of |Scan_Parse_Parameter_Type::delete_key_pair| definition  */

#endif /* |HAVE_LIBMYSQLCLIENT|  */


@q **** (4) Delete public key.  @>

@ Delete public key.
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this function.

\initials{LDF 2012.01.13.}
Removed the definition of this function from \filename{scprpmtp.web} 
to this file (\filename{spptkyfn.web}).
\ENDLOG

@<|Scan_Parse_Parameter_Type::delete_public_key| definition@>=

#if HAVE_LIBMYSQLCLIENT

int
Scan_Parse_Parameter_Type::delete_public_key(void)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG); 

    int status = 0;

    stringstream sql_strm;

    int curr_user_id = (effective_user_id > 0) ? effective_user_id : user_id;

    MYSQL_RES *result;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    if (DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "Entering `Scan_Parse_Parameter_Type::delete_public_key'." 
             << endl;
        unlock_cerr_mutex(); 
    
    }  /* |if (DEBUG)|  */ 
    
@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_public_key| definition@>=

    sql_strm << "select key_id from Public_Keys where user_id = "
             << curr_user_id;

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_public_key':" 
             << endl
             << "`sql_strm.str()' == " << sql_strm.str()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

@q ****** (6) @>

    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::delete_public_key':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return 1;


    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_public_key':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_public_key':"
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */

@q ****** (6) @>    
@
@<|Scan_Parse_Parameter_Type::delete_public_key| definition@>=

    if (row_ctr == 0)
    {
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "]:  "
                 << "In `Scan_Parse_Parameter_Type::delete_public_key':"
                 << endl 
                 << "row_ctr == 0.  No public key for `user_id` " << curr_user_id
                 << endl
                 << "Exiting function successfully with return value 3."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */

        mysql_free_result(result);

        return 3;

    }  /* |if (row_ctr == 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::delete_public_key| definition@>=

    mysql_free_result(result);

    result = 0;

    sql_strm.str("");

    sql_strm << "delete from Public_Keys where user_id = " << curr_user_id;


    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_public_key':" 
             << endl
             << "`sql_strm.str()' == " << sql_strm.str()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 


    status = submit_mysql_query(sql_strm.str(),
                                result, 
                                0, 
                                0);

    if (status)
    {
        lock_cerr_mutex(); 
        cerr << get_datestamp() << " [Thread " << thread_ctr << "]:  "
             << "WARNING!  In `Scan_Parse_Parameter_Type::delete_public_key':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

       if (result) 
          mysql_free_result(result);

       return 1;


    }  /* |if (status)|  */

    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_public_key':"
             << endl 
             << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */
       
    mysql_free_result(result);
    result = 0;

@q ****** (6) @>

    if (DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "]:  "
             << "In `Scan_Parse_Parameter_Type::delete_public_key':"
             << endl
             << "Exiting function successfully with return value 0." 
             << endl;
         unlock_cerr_mutex(); 
    
    }  /* |if (DEBUG)|  */ 

    return 0;  

}  /* End of |Scan_Parse_Parameter_Type::delete_public_key| definition  */

#endif /* |HAVE_LIBMYSQLCLIENT|  */


@q **** (4) @>
@
@<Garbage@>=

@q **** (4) @>

@q *** (3) Putting `spptkyfn.web.web' together.  @>

@ Putting {\tt spptkyfn.web\PERIOD web} together.

@q **** (4) This is what's compiled.  @>
@ This is what's compiled.
@c
@<Include files@>@;@/
using namespace std;
@<|Scan_Parse_Parameter_Type::store_key_pair| definition@>@;@/
@<|Scan_Parse_Parameter_Type::store_public_key| definition@>@;@/
@<|Scan_Parse_Parameter_Type::fetch_key_pair| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_key_pair| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_key_name| definition@>@;@/
@<|Scan_Parse_Parameter_Type::install_key_pair| definition@>@;@/
@<|Scan_Parse_Parameter_Type::distribute_key_pair| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_optinum_installer_gpg_pubkey_fingerprint| definition@>@;@/
@<|Scan_Parse_Parameter_Type::check_public_key| definition@>@;@/
@<|Scan_Parse_Parameter_Type::delete_key_pair| definition@>@;@/
@<|Scan_Parse_Parameter_Type::delete_public_key| definition@>@;@/
#if 0 
@<Garbage@>@;@/
#endif 

@q **** (4) This is what's written to the header file `spptkyfn.h'.  @>

@ This is what's written to the header file \filename{spptkyfn.h}.

That is, no {\CPLUSPLUS/} code is written to the header file, but it's helpful 
for it to exist, so that this CWEB file can be handled in exactly the same 
way as the others.
\initials{LDF 2012.01.13.}

@(spptkyfn.h@>=
#ifndef SPPTKYFN.WEB_H
#define SPPTKYFN.WEB_H 1
/* Empty  */
#endif 

@q * (1) Emacs-Lisp code for use in indirect buffers  @>

@q (progn (cweb-mode) (outline-minor-mode))                          @>

@q * (1) Local variables for Emacs @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q abbrev-mode:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>
