@q prsrclnt.web  @>
@q Created by Laurence D. Finston (LDF) Wed Nov  4 14:31:22 CET 2009 @>

@q * (1) Top @>

@q * (1) Copyright and License.@>

@q This file is part of the OptiNum Grid Installer @>
@q Copyright (C) 2010, 2011, 2012, 2013 Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen @>

@q The OptiNum Grid Installer is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q The OptiNum Grid Installer is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License          @>
@q along with the OptiNum Grid Installer; if not, write to the Free Software                    @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gwdg.de@>

@q Laurence D. Finston                                                   @>
@q Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen  @>
@q Am Fassberg 11         					         @>
@q 37077 Goettingen              					 @>
@q Germany                           					 @>                                

@q Laurence.Finston@@gwdg.de (@@ stands for a single "at" sign.)@>


@q * (1) Parser for Client.  @>
@* Client Parser.
\initials{LDF 2009.11.04.}
Some of the code contained in this file has been taken from the GNU 3DLDF project.  
The copyright for this code is owned by the Free Software Foundation.
\initials{LDF 2010.01.11.}

@q ** (2) Include files.@>
@ Include files.

@<Include files@>=

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <errno.h>

#include <algorithm>
#include <fstream>
#include <functional>
#include <getopt.h> 
#include <iomanip>
#include <ios>
#include <iostream>
#include <iterator>
#include <map>
#include <new>
#include <string>
#include <ctype.h>
#include <time.h>
#include <math.h>
#include <sstream>   
#include <stdarg.h>
#include <stdexcept>

#include <set>
#include <vector>
#include <deque>

#include <gcrypt.h> /* for |gcry_control| */
#include <gnutls/gnutls.h>

#if HAVE_CONFIG_H
# include <config.h>
#endif

#if IS_ROCKS_GOEGRID
#undef HAVE_LIBMYSQLCLIENT
#endif 

#if HAVE_LIBMYSQLCLIENT
#include <mysql.h>
#endif 

#include "dhprxcrt.h++"
#include "entries.h++"
#include "dstngnmt.h++"
#include "glblvrbl.h++"
#include "glblfncs.h++"
#include "prsrclnt.h++"
#include "scnrclnt.h++"
#include "rspnstp.h++"
#include "glsinftp.h++"

#define IN_PRSRCLNT  /* This prevents a warning about |zzlex| already
                        being a |friend| of |Scan_Parse_Parameter_Type|.  
                        LDF 2012.02.10.  */
#include "scprpmtp.h++"
#undef IN_PRSRCLNT

#include "prsrfncs.h++"
#include "utilfncs.h++"

@q ** (2) Declarations of additional functions.@>
@ Declarations of additional functions.

@<Declarations of additional functions@>=

int 
zzlex(YYSTYPE* lvalp, yyscan_t parameter);

int
zzwrap(void);

int
zzerror(void* v, char const* s);

@q ** (2) Options.@>
@ Options.

@<Options@>=
@=%verbose@>@;@/
@=%pure-parser@>@;@/
@=%parse-param {yyscan_t parameter}@>@;@/
@=%lex-param {yyscan_t parameter}@>@;@/
@=%name-prefix="zz"@>@;@/
@=%debug@>
@=%expect 2@>

@q ** (2) |union| declaration.@>
@ {\bf union} declaration.

@<|union| declaration@>=

@=%union {@>
 
  int int_value;
  unsigned int uint_value;
  float float_value;
  char string_value[256];

@=}@>

@q ** (2) Token and type declarations.@>
@ Token and type declarations.

@q *** (3) Punctuation.  @>
@ Punctuation.

@<Token and type declarations@>=

@=%token<int_value> HYPHEN_ZZ@>@;@/
@=%token<int_value> COLON_ZZ@>@;@/            
@=%token<int_value> SEMI_COLON_ZZ@>@;@/      
@=%token<int_value> EXCLAMATION_POINT_ZZ@>@;@/      

@q *** (3) Start conditions for the scanner.  @>
@ Start conditions for the scanner.
\initials{LDF Undated.}

@<Token and type declarations@>=

@q *** (3) @>
@ Control.

\LOG
\initials{LDF 2010.03.04.}
Added token declaration for |PREREQUISITES|.

\initials{LDF 2010.03.05.}
Added token declaration for |FOUND_ZZ|.

\initials{LDF 2010.03.05.}
Added the token declaration for |ORDER_ZZ|.

\initials{LDF 2010.03.19.}
Added the token declaration for |ENVIRONMENT_ZZ|.

\initials{LDF 2010.03.26.}
Added the token declaration for |DOWNLOAD_COMMAND_ZZ|.

\initials{LDF 2010.03.29.}
Added the token declaration for |DOWNLOAD_INFO_ZZ|.

\initials{LDF 2010.04.16.}
Added the token declarations for |PARSE_ZZ| and |ERROR_ZZ|.

\initials{LDF 2010.05.20.}
Added the token declaration for |REPLACING_ZZ|.

\initials{LDF 2010.05.21.}
Added the token declarations for |SHOW_ZZ|, |ENTRIES_ZZ| and |INFO_ZZ|.

\initials{LDF 2010.06.30.}
Added the token declarations for |SET_ZZ| and |EFFECTIVE_USER_ZZ|.

\initials{LDF 2010.09.09.}
Added the token declarations for |DELETE_ZZ| and |DELETED_ZZ|.

\initials{LDF 2010.09.10.}
|AMBIGUOUS_ZZ| and |MULTIPLE_ZZ|.

\initials{LDF 2010.09.15.}
Added the token declarations for |ADDING_ZZ| and |NOT_ZZ|.

\initials{LDF 2010.09.17.}
Added the token declaration for |SUCCESSFULLY_ZZ|.

\initials{LDF 2010.10.27.}
Added the token declaration for |CERTIFICATES_ZZ|.

\initials{LDF 2010.11.04.}
Added the token declarations for |ALLOWED_ZZ| and |USER_ZZ|.

\initials{LDF 2011.05.06.}
Added the token declaration for |AUTHORIZATION_ZZ|.

\initials{LDF 2011.09.26.}
Added the token declaration for |PROXY_CERTIFICATE_ZZ|.

\initials{LDF 2011.10.14.}
Added token declarations for 
|REMOTE_ZZ|,
|INSTALLATION_ZZ|,
|PACKAGE_NAME_ZZ|,
|PACKAGE_VERSION_ZZ|,
|STDOUT_FILENAME_ZZ| and
|STDERR_FILENAME_ZZ|.

\initials{LDF 2011.10.21.}
Added token declaration for |TIMEOUT_ZZ|.

\initials{LDF 2011.10.27.}
Added token declaration for |NAME_ZZ|.

\initials{LDF 2011.10.28.}
Added token declarations for |WARNING_ZZ|, |PACKAGE_VERSIONS_ZZ|, 
|NO_VERSION_ZZ| and |GLOBUS_SITE_ZZ|.

\initials{LDF 2011.11.03.}
Added token declarations for |GET_ZZ|, |SECRET_KEY_ZZ|, |PUBLIC_KEY_ZZ| and |KEY_PAIR_ZZ|.

\initials{LDF 2011.11.14.}
Added the token declaration for |REPLACED_ZZ|.

\initials{LDF 2011.11.21.}
Added the token declarations for |DISTRIBUTE_ZZ| and |DISTRIBUTING_ZZ|.

\initials{LDF 2011.11.21.}
Added the token declaration for |DISABLED_ZZ|.

\initials{LDF 2011.12.16.}
Added the token declarations for |FROM_ZZ|, |DATABASE_ZZ| and |IN_ZZ|.

\initials{LDF 2011.12.22.}
Added token declaration for |SESSION_ID_ZZ|.

\initials{LDF 2012.01.03.}
Added token declaration for |PRIVATE_KEY_ZZ|.

\initials{LDF 2012.01.13.}
Added token declarations for |MARK_ZZ|,|MARKED_ZZ|, |UNMARK_ZZ|, 
|UNMARKED_ZZ| and |AS_ZZ|.

\initials{LDF 2012.02.07.}
Added token declarations for |EXPIRED_ZZ|, |OTHER_ZZ| and |REASON_ZZ|.

\initials{LDF 2012.03.16.}
Added token declaration for |HOST_ZZ|.

\initials{LDF 2012.03.20.}
Added the token declaration for |SHELLSCRIPT_ZZ|.

\initials{LDF 2012.03.21.}
Added the token declaration for |SHELLSCRIPTS_ZZ|.

\initials{LDF 2012.03.22.}
Added the token declarations for |ADMIN_ZZ|, |STORE_ZZ| and |FETCH_ZZ|.

\initials{LDF 2012.03.26.}
Added the token declarations for |ENABLE_ZZ|, |ENABLED_ZZ|, 
|DISABLE_ZZ|.

\initials{LDF 2012.04.13.}
Added the token declaration for |GLOBUS_SITES_ZZ|.

\initials{LDF 2012.05.02.}
Added the token declarations for |EDIT_ZZ| and |EDITED_ZZ|.

\initials{LDF 2012.05.02.}
Added the token declaration for |SHOWING_ZZ|.

\initials{LDF 2012.05.07.}
Added the token declaration for |PRIVILEGES_ZZ|.

\initials{LDF 2012.05.15.}
Changed |PROXY_CERTIFICATE_ZZ| to |PROXY_CREDENTIAL_ZZ|.
\ENDLOG 

@q **** (4) Code @>

@<Token and type declarations@>=

@=%token<int_value> GET_ZZ@>@;@/
@=%token<int_value> SEND_ZZ@>@;@/
@=%token<int_value> SENDING_ZZ@>@;@/
@=%token<int_value> SERVER_ZZ@>@;@/
@=%token<int_value> FOR_ZZ@>@;@/
@=%token<int_value> ENTRY_ZZ@>@;@/
@=%token<int_value> ENTRIES_ZZ@>   

@=%token<int_value> CERTIFICATE_ZZ@>@;@/
@=%token<int_value> CERTIFICATES_ZZ@>@;@/

@=%token<int_value> PROXY_CREDENTIAL_ZZ@>@;@/
@=%token<int_value> EXPIRED_ZZ@>@;@/

@=%token<int_value> PRIVILEGES_ZZ@>@;@/

@=%token<int_value> END_ZZ@>@;@/

@=%token<int_value> PARSE_ZZ@>@;@/
@=%token<int_value> ERROR_ZZ@>@;@/

@=%token<string_value> SERVER_FINISHED_ZZ@>@;@/

@=%token<int_value> INSTALLATION_SCRIPT_ZZ@>@;@/
@=%token<int_value> INSTALLATION_SCRIPT_ENCRYPTED_ZZ@>@;@/
@=%token<int_value> DOWNLOAD_URL_ZZ@>@;@/
@=%token<int_value> DOWNLOAD_URL_ENCRYPTED_ZZ@>@;@/
@=%token<int_value> DOWNLOAD_COMMAND_ZZ@>@;@/
@=%token<int_value> DOWNLOAD_COMMAND_ENCRYPTED_ZZ@>@;@/
@=%token<int_value> AUTHORIZATION_ZZ@>@;@/
@=%token<int_value> DOWNLOAD_INFO_ZZ@>@;@/
@=%token<int_value> PREREQUISITE_ZZ@>@;@/
@=%token<int_value> PREREQUISITES_ZZ@>@;@/
@=%token<int_value> FOUND_ZZ@>@;@/
@=%token<int_value> NOT_FOUND_ZZ@>@;@/
@=%token<int_value> RECEIVE_ZZ@>@;@/
@=%token<int_value> STORE_ZZ@>@;@/
@=%token<int_value> FILE_ZZ@>@;@/
@=%token<int_value> SUCCEEDED_ZZ@>@;@/
@=%token<int_value> SUCCESSFULLY_ZZ@>@;@/
@=%token<int_value> FAILED_ZZ@>@;@/
@=%token<int_value> ORDER_ZZ@>@;@/

@=%token<int_value> OTHER_ZZ@>@;@/
@=%token<int_value> REASON_ZZ@>@;@/

@=%token<string_value> STRING_ZZ@>@;@/

@=%token<int_value> DISTINGUISHED_NAME_ZZ@>@;@/
@=%token<int_value> VALIDATED_ZZ@>@;@/
@=%token<int_value> VALIDATION_ZZ@>@;@/

@=%token<int_value> REPLACING_ZZ@>@;@/
@=%token<int_value> REPLACED_ZZ@>@;@/
@=%token<int_value> DUPLICATE_ZZ@>@;@/
@=%token<int_value> NO_ZZ@>@;@/
@=%token<int_value> IN_ZZ@>@;@/
@=%token<int_value> TO_ZZ@>@;@/
@=%token<int_value> FROM_ZZ@>@;@/
@=%token<int_value> ADD_ZZ@>@;@/
@=%token<int_value> ADDED_ZZ@>@;@/
@=%token<int_value> ADDING_ZZ@>@;@/

@=%token<int_value> EDIT_ZZ@>@;@/
@=%token<int_value> EDITED_ZZ@>@;@/

@=%token<int_value> NOT_ZZ@>@;@/

@=%token<int_value> DELETE_ZZ@>@;@/
@=%token<int_value> DELETED_ZZ@>@;@/

@=%token<int_value> MARK_ZZ@>@;@/
@=%token<int_value> MARKED_ZZ@>@;@/
@=%token<int_value> UNMARK_ZZ@>@;@/
@=%token<int_value> UNMARKED_ZZ@>@;@/

@=%token<int_value> AS_ZZ@>@;@/

@=%token<int_value> AMBIGUOUS_ZZ@>@;@/
@=%token<int_value> MULTIPLE_ZZ@>@;@/

@=%token<int_value> ENVIRONMENT_ZZ@>   
@=%token<int_value> HOST_ZZ@>   
@=%token<int_value> SHELLSCRIPT_ZZ@>   
@=%token<int_value> SHELLSCRIPTS_ZZ@>   
@=%token<int_value> ADMIN_ZZ@>  
@=%token<int_value> FETCH_ZZ@>    

@=%token<int_value> ENABLE_ZZ@>
@=%token<int_value> ENABLED_ZZ@>
@=%token<int_value> DISABLE_ZZ@> 
@=%token<int_value> DISABLED_ZZ@>

@=%token<int_value> SHOW_ZZ@>   
@=%token<int_value> SHOWING_ZZ@>   

@=%token<int_value> INFO_ZZ@>   

@=%token<int_value> SET_ZZ@>@;@/
@=%token<int_value> EFFECTIVE_USER_ZZ@>@;@/

@=%token<int_value> ALLOWED_ZZ@>@;@/
@=%token<int_value> USER_ZZ@>@;@/
@=%token<int_value> NAME_ZZ@>@;@/

@=%token<int_value> REMOTE_ZZ@>@;@/
@=%token<int_value> INSTALLATION_ZZ@>@;@/
@=%token<int_value> PACKAGE_NAME_ZZ@>@;@/
@=%token<int_value> PACKAGE_VERSION_ZZ@>@;@/
@=%token<int_value> STDOUT_FILENAME_ZZ@>@;@/
@=%token<int_value> STDERR_FILENAME_ZZ@>@;@/
@=%token<int_value> TIMEOUT_ZZ@>@;@/
@=%token<int_value> WARNING_ZZ@>@;@/ 
@=%token<int_value> PACKAGE_VERSIONS_ZZ@>@;@/ 
@=%token<int_value> NO_VERSION_ZZ@>@;@/
@=%token<int_value> GLOBUS_SITE_ZZ@>@;@/
@=%token<int_value> GLOBUS_SITES_ZZ@>@;@/

@=%token<int_value> SECRET_KEY_ZZ@>@;@/
@=%token<int_value> PUBLIC_KEY_ZZ@>@;@/
@=%token<int_value> PRIVATE_KEY_ZZ@>@;@/
@=%token<int_value> KEY_PAIR_ZZ@>@;@/

@=%token<int_value> DISTRIBUTE_ZZ@>@;@/
@=%token<int_value> DISTRIBUTING_ZZ@>@;@/

@=%token<int_value> DATABASE_ZZ@>@;@/

@=%token<int_value> SESSION_ID_ZZ@>@;@/

@q **** (4) Tokens for start conditions.  @>
@ Tokens for start conditions.  
\initials{LDF Date unknown.}

@<Token and type declarations@>=      

@q *** (3) Numbers.  @>
@ Numbers.    

@<Token and type declarations@>=      

@=%token<int_value> INTEGER_ZZ@>@;@/      
@=%token<uint_value> UNSIGNED_INTEGER_ZZ@>@;@/      
@=%token<float_value> FLOAT_ZZ@>@;@/      

@q ** (2) Rules.  @>
@ Rules.

@q *** (3) Program.  @>
@ Program.

@<Rules@>=

@=program: statement_list END_ZZ@>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `program: statement_list END_ZZ'."
            << endl;

    return 0;

};

@q *** (3) statement_list.  @>
@ \<statement list>.
\initials{LDF 2008.08.18.}

\LOG
\initials{LDF 2008.08.18.}
Added this section.
\ENDLOG  

@q **** (4) statement_list --> EMPTY.  @>

@ \<statement list> $\longrightarrow$ \.{EMPTY}.  
This rule ensures that an empty file won't cause an error.
\initials{LDF 2008.07.07.}

@<Rules@>=

@=statement_list: /* Empty  */  @>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement_list: /* Empty */'."
            << endl;

};

@q **** (4) statement_list --> statement_list statement.  @>

@ \<statement list> $\longrightarrow$ \<statement>.
\initials{LDF 2009.10.05.}

@<Rules@>=

@=statement_list: statement_list statement @>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement_list: statement_list statement'."
            << endl;

};

@q *** (3) Statement.  @>
@ Statement.
\initials{LDF 2009.10.05.}

@q **** (4) statement --> SEND_ZZ installation_script STRING_ZZ @>
@q **** (4)  FOR_ZZ ENTRY_ZZ INTEGER_ZZ entry_string_list       @>

@ \<statement> $\longrightarrow$ \.{SEND\_ZZ} \<installation script> 
\.{STRING\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} \.{INTEGER\_ZZ}
\<entry string list>
\initials{LDF 2011.04.20.}

This rule is matched when the server tells the client to send 
the encrypted or unencrypted installation script.
\initials{LDF 2011.04.20.}
\initials{LDF 2011.04.21.}

\LOG
\initials{LDF 2011.04.20.}
Added this rule.

\initials{LDF 2011.04.21.}
Replaced \.{INSTALLATION\_SCRIPT\_ENCRYPTED\_ZZ} with 
\<installation script>.  Removed similar rule with 
\.{INSTALLATION\_SCRIPT\_ZZ}.
\ENDLOG

@<Rules@>=

@=statement: SEND_ZZ installation_script STRING_ZZ FOR_ZZ @>@/
@=ENTRY_ZZ INTEGER_ZZ entry_string_list@>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `SEND_ZZ installation_script STRING_ZZ "
             << "FOR_ZZ ENTRY_ZZ INTEGER_ZZ entry_string_list'."
             << endl;

    bool encrypted = @=$2@>;
   
    Response_Type response;
    response.entry_id        = @=$6@>;

    /* !! TODO:  LDF 2010.03.23.  Add error handling.  */

    response.entry_name      = param->entry_string_vector[0];

    if (param->entry_string_vector.size() > 1)
       response.version         = param->entry_string_vector[1];
    else
       response.version         = "";

    param->entry_string_vector.clear();

    response.local_filename  = @=$3@>;
    response.remote_filename = "";

    response.type = (encrypted) ?   Response_Type::INSTALLATION_SCRIPT_ENCRYPTED_TYPE
                                  : Response_Type::INSTALLATION_SCRIPT_TYPE;

    stringstream temp_strm;
    temp_strm << "CLIENT SENDING INSTALLATION_SCRIPT";

    if (encrypted)
       temp_strm << "_ENCRYPTED";

    temp_strm << " <" << @=$3@> << "> " << @=$6@> << " " << response.type
              << " \"" << response.entry_name << "\"";

    if (param->PARSER_DEBUG) 
       cerr << "temp_strm.str() == " << temp_strm.str() << endl;

    response.command = temp_strm.str();

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_front(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

};

@q **** (4) statement --> SERVER_ZZ SENDING_ZZ installation_script     @>
@q **** (4)               STRING_ZZ FOR_ZZ ENTRY_ZZ entry_string_list  @>
@q **** (4)               ORDER_ZZ INTEGER_ZZ                          @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SENDING\_ZZ} 
\.{INSTALLATION\_SCRIPT\_ZZ} \.{STRING\_ZZ}
\.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list> \.{ORDER\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2010.01.19.}

\LOG
\initials{LDF 2010.01.19.}
Added this rule.

\initials{LDF 2010.03.05.}
Added \.{ORDER\_ZZ} \.{INTEGER\_ZZ}.

\initials{LDF 2010.03.29.}
Changed |STRING_ZZ| to \<entry string list>.  Removed variant rule with
two |STRING_ZZ| symbols.

\initials{LDF 2011.03.31.}
Changed |INSTALLATION_SCRIPT_ZZ| to \<installation script>.

\initials{LDF 2011.04.15.}
Added code for storing the key id of the owner in |Entry e|.

\initials{LDF 2012.02.01.}
Added code for setting |Entry e.encrypted_flag|.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SENDING_ZZ installation_script STRING_ZZ @>@/
@=FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ @>
{

    /* !! TODO:  LDF 2011.12.27.  See if I could use this rule
       in \.{test\_js.web} for saving the installation script 
       in a file in a subdirectory of \filename{/srv/www/htdocs/}
       named for |session_id|.
    */

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));
   
    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ installation_script STRING_ZZ "
            << "FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ'."
            << endl;
 
    if (param->PARSER_DEBUG)
        cerr << "`STRING_ZZ' == " << @=$4@> 
             << endl
             << "`installation_script' == " << @=$3@> 
             << endl;

    int status = accept_data(param, 
                             @=$4@>, 
                             -1, 
                             Response_Type::INSTALLATION_SCRIPT_TYPE);

   Response_Type response;

   response.type    = Response_Type::COMMAND_ONLY_TYPE;

   stringstream temp_strm;

   if (status != 0)
   {
       param->msg_strm.str("");

       param->msg_strm << "ERROR!  In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ "
                       << "installation_script STRING_ZZ FOR_ZZ ENTRY_ZZ "
                       << "entry_string_list ORDER_ZZ INTEGER_ZZ':"
                       << endl
                       << "`accept_data' failed, returning " << status
                       << endl
                       << "`STRING_ZZ' == " << @=$4@> 
                       << endl
                       << "Continuing."
                       << endl;   

       cerr << param->msg_strm.str();
       err_log_strm << param->msg_strm.str();
       log_strm << param->msg_strm.str();

       param->msg_strm.str("");

       temp_strm.str("");

       temp_strm << "RECEIVE INSTALLATION_SCRIPT FAILED FOR ENTRY "
                 << "\"" << param->entry_string_vector[0] << "\"";

       if (   param->entry_string_vector.size() > 1 
           && !param->entry_string_vector[1].empty())

          temp_strm << " <" << param->entry_string_vector[1] << ">";

       response.command = temp_strm.str();
                       
       temp_strm.str("");

       pthread_mutex_unlock(&param->response_deque_mutex);
       param->response_deque.push_front(response);
       pthread_mutex_unlock(&param->response_deque_mutex);

       ++errors_occurred;

   }  /* |if (status != 0)|  */

   else 
   {
 
       if (param->PARSER_DEBUG)
       {

            cerr << "In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ installation_script "
                 << "STRING_ZZ FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ':"
                 << endl
                 << "`accept_data' succeeded." 
                 << endl
                 << "`STRING_ZZ' == " << @=$4@> 
                 << endl;

       }  /* |if (param->PARSER_DEBUG)|  */
   
       if (param->PARSER_DEBUG)
       {

           int i = 0;

           for (vector<string>::const_iterator iter = param->entry_string_vector.begin();
               iter != param->entry_string_vector.end();
               ++iter)
           {
               cerr << "entry_string_vector[" << i++ << "] == " << *iter << endl;
           }
              
       } /* |if (param->PARSER_DEBUG)|  */

       Entry_Type e;
       e.package_name        = param->entry_string_vector[0];

       if (   param->entry_string_vector.size() > 1 
           && !param->entry_string_vector[1].empty())

          e.package_version = param->entry_string_vector[1];

       if (   param->entry_string_vector.size() > 2 
           && !param->entry_string_vector[2].empty())
 
          e.owner = param->entry_string_vector[2];
      
       if (param->entry_string_vector.size() > 3)
       {
          e.owner_key_id = atoi(param->entry_string_vector[3].c_str());

          if (param->PARSER_DEBUG)
          {
              cerr << "param->entry_string_vector[3] == " 
                   << param->entry_string_vector[3] << endl;

          }  /* |if (param->PARSER_DEBUG)|  */
       }

       if (param->PARSER_DEBUG) 
          cerr << "e.owner_key_id == " << e.owner_key_id << endl;

       if (@=$3@>)
       {
          e.installation_script_encrypted = @=$4@>;
          e.encrypted_flag = true;
       }

       else
       {
          e.installation_script = @=$4@>;
          e.encrypted_flag = false;
       }

       e.install_order       = @=$9@>;

       if (param->PARSER_DEBUG)
          e.show("e:");

       param->cond_append(e);

       log_strm << "Received ";

       if (@=$3@>)
          log_strm << "encrypted ";

       log_strm << "installation script for " << e.package_name;

       if (!e.package_version.empty())
          log_strm << " " << e.package_version;
 
       log_strm << endl << endl;

       temp_strm.str("");
 
       temp_strm << "RECEIVE INSTALLATION_SCRIPT SUCCEEDED FOR ENTRY \""
                 << e.package_name << "\"";

       if (!e.package_version.empty())
          temp_strm << " \"" << e.package_version << "\"";

       response.command = temp_strm.str();

       temp_strm.str("");

       pthread_mutex_unlock(&param->response_deque_mutex);
       param->response_deque.push_front(response);
       pthread_mutex_unlock(&param->response_deque_mutex);

       fetch = true;

   }  /* |else|  */ 

   param->entry_string_vector.clear();

};

@q **** (4) installation_script.  @>

@ \<installation script>.
\initials{LDF 2011.03.31.}

\LOG
\initials{LDF 2011.03.31.}
Added this section.
\ENDLOG

@<Type declarations for non-terminal symbols@>=
@=%type <int_value> installation_script@>@/

@q **** (4) @>
@
\LOG
\initials{LDF 2011.03.31.}
Added this section.
\ENDLOG

@<Rules@>=
@=installation_script: INSTALLATION_SCRIPT_ZZ@>
{

   @=$$@> = 0;

};

@q **** (4) @>
@
\LOG
\initials{LDF 2011.03.31.}
Added this section.
\ENDLOG

@<Rules@>=
@=installation_script: INSTALLATION_SCRIPT_ENCRYPTED_ZZ@>
{

   @=$$@> = 1;

};

@q **** (4) statement --> SERVER_ZZ SENDING_ZZ download_info_expression  @>
@q **** (4) FOR_ZZ ENTRY_ZZ entry_string_list                            @>
@q **** (4) ORDER_ZZ INTEGER_ZZ                                          @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SENDING\_ZZ} 
\<download info expression> \.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list>.
 \.{ORDER\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2010.02.02.}

@:NB@> !! NB:  This version is only for {\it unencrypted\/} 
download commands and URLs!  
See below for rules for the encrypted variants.
\initials{LDF 2011.04.15.}

\LOG
\initials{LDF 2010.02.02.}
Added this rule.

\initials{LDF 2010.03.05.}
Added \.{ORDER\_ZZ} \.{INTEGER\_ZZ}.

\initials{LDF 2010.03.26.}
Changed |STRING_ZZ| to \<entry string list>.  Removed variant rule with
three |STRING_ZZ| symbols.

\initials{LDF 2010.03.29.}
Changed |DOWNLOAD_URL_ZZ| to |download_info_expression|.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SENDING_ZZ download_info_expression FOR_ZZ ENTRY_ZZ @>@/
@=entry_string_list ORDER_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));
   
    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ download_info_expression "
            << "FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ'."
            << endl;

   stringstream temp_strm;

   Entry_Type e;
   e.package_name  = param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      e.package_version = param->entry_string_vector[1];

   e.download_url = param->download_url_string;
   e.download_command = param->download_command_string;

   param->download_url_string = param->download_command_string = "";

   temp_strm << e.download_url << " # " << e.download_command
             << " # " << e.package_name;
   
   if (!e.package_version.empty())
      temp_strm << " # " << e.package_version;

   if (output_file_strm.is_open())
      output_file_strm << temp_strm.str() << endl;
   else
      cout << temp_strm.str() << endl;

   temp_strm.str("");

   param->entry_string_vector.clear();
      
   e.install_order = @=$8@>;

   param->cond_append(e);

   Response_Type response;

   response.type    = Response_Type::COMMAND_ONLY_TYPE;

   temp_strm << "RECEIVE DOWNLOAD_INFO SUCCEEDED FOR ENTRY \""
             << e.package_name << "\"";

   log_strm << "Received download info for " << e.package_name;

   if (!e.package_version.empty())
   {
      temp_strm << " \"" << e.package_version << "\"";
      log_strm << " " << e.package_version << endl << endl;
   }

   response.command = temp_strm.str();

   pthread_mutex_lock(&param->response_deque_mutex);
   param->response_deque.push_back(response);
   pthread_mutex_unlock(&param->response_deque_mutex);

   temp_strm.str("");

   fetch = true;

};

@q **** (4) download_info_expression: /* Empty  */  @>

@ \<download info expression> $\longrightarrow$ \.{Empty}.
\initials{LDF 2010.03.29.}

@<Rules@>=

@=download_info_expression: /* Empty  */@>
{

    Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `download_info_expression: /* Empty  */'."
             << endl;

      param->download_url_string = param->download_command_string = "";

};

@q **** (4) download_info_expression: download_info_expression DOWNLOAD_URL_ZZ STRING_ZZ  @>

@ \<download info expression> $\longrightarrow$ \<download info expression>
 \.{DOWNLOAD\_URL\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2010.03.29.}

@<Rules@>=

@=download_info_expression: download_info_expression DOWNLOAD_URL_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `download_info_expression: download_info_expression "
             << "DOWNLOAD_URL_ZZ STRING_ZZ'."
             << endl;

      param->download_url_string = @=$3@>;

};

@q **** (4) download_info_expression: download_info_expression DOWNLOAD_COMMAND_ZZ STRING_ZZ  @>

@ \<download info expression> $\longrightarrow$ \<download info expression>
 \.{DOWNLOAD\_COMMAND\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2010.03.29.}

@<Rules@>=

@=download_info_expression: download_info_expression DOWNLOAD_COMMAND_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `download_info_expression: download_info_expression "
             << "DOWNLOAD_COMMAND_ZZ STRING_ZZ'."
             << endl;

      param->download_command_string = @=$3@>;

};

@q **** (4) statement --> SEND_ZZ download_info_encrypted STRING_ZZ @>
@q **** (4)  FOR_ZZ ENTRY_ZZ INTEGER_ZZ entry_string_list             @>

@ \<statement> $\longrightarrow$ \.{SEND\_ZZ} \<download info encrypted>
\.{STRING\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} \.{INTEGER\_ZZ}
\<entry string list>
\initials{LDF 2011.04.21.}

\LOG
\initials{LDF 2011.04.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SEND_ZZ download_info_encrypted STRING_ZZ FOR_ZZ @>@/
@=ENTRY_ZZ INTEGER_ZZ entry_string_list@>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `SEND_ZZ download_info_encrypted STRING_ZZ "
             << "FOR_ZZ ENTRY_ZZ INTEGER_ZZ entry_string_list'."
             << endl;

    Response_Type response;
    response.entry_id        = @=$6@>;

    int command_or_url;

    if (@=$2@> == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE)
       command_or_url = 0;
    else
       command_or_url = 1;

    /* !! TODO:  LDF 2010.03.23.  Add error handling for the case that
       |entry_string_vector.size() == 0|.  */

    response.entry_name      = param->entry_string_vector[0];

    if (param->entry_string_vector.size() > 1)
       response.version         = param->entry_string_vector[1];
    else
       response.version         = "";

    param->entry_string_vector.clear();

    response.local_filename  = @=$3@>;
    response.remote_filename = "";

    if (command_or_url == 1)
    {
       response.type = Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE;
    }
    else
    {
       response.type = Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE;
    }

    stringstream temp_strm;

    temp_strm << "CLIENT SENDING ";

    if (command_or_url == 1)
       temp_strm << "DOWNLOAD_COMMAND_ENCRYPTED ";
    else 
       temp_strm << "DOWNLOAD_URL_ENCRYPTED ";

    temp_strm << "<" << @=$3@> << "> " << @=$6@> << " " << response.type
              << " \"" << response.entry_name << "\"";

    if (param->PARSER_DEBUG) 
    {
        cerr << "temp_strm.str() == " << temp_strm.str() << endl;

    }

    response.command = temp_strm.str();

    pthread_mutex_unlock(&param->response_deque_mutex);
    param->response_deque.push_front(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

};

@q **** (4) statement --> SERVER_ZZ SENDING_ZZ DOWNLOAD_URL_ENCRYPTED_ZZ @>
@q **** (4) STRING_ZZ FOR_ZZ ENTRY_ZZ entry_string_list                  @>
@q **** (4) ORDER_ZZ INTEGER_ZZ                                          @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SENDING\_ZZ} 
\.{DOWNLOAD\_URL\_ENCRYPTED\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} 
\<entry string list>  \.{ORDER\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2011.02.04.}

\LOG
\initials{LDF 2011.02.04.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SENDING_ZZ DOWNLOAD_URL_ENCRYPTED_ZZ @>@/
@=FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ DOWNLOAD_URL_ENCRYPTED_ZZ "
            << "FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ'."
            << endl;

    string curr_filename;

    stringstream temp_strm;

    Response_Type response;

    Entry_Type e;

    e.encrypted_flag = true;

    e.package_name  = param->entry_string_vector[0];

    if (param->entry_string_vector.size() > 1 && param->entry_string_vector[1] != "-1")
       e.package_version = param->entry_string_vector[1];

    if (param->entry_string_vector.size() > 2)
       e.owner = param->entry_string_vector[2];

    if (param->entry_string_vector.size() > 3)
    {
       e.owner_key_id = atoi(param->entry_string_vector[3].c_str());

       if (param->PARSER_DEBUG)
       {
           cerr << "param->entry_string_vector[3] == " << param->entry_string_vector[3] << endl;

       }  /* |if (param->PARSER_DEBUG)|  */
    }

    if (param->PARSER_DEBUG) 
       cerr << "e.owner_key_id == " << e.owner_key_id << endl;

    int status = create_temp_file(curr_filename, 0, "TT");

    if (status != 0)
    {
        param->msg_strm.str("");

        param->msg_strm << "ERROR!  In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ "
                       << "DOWNLOAD_URL_ENCRYPTED_ZZ "
                       << "FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ':"
                       << endl 
                       << "`create_temp_file' failed.  Will try to continue."
                       << endl;
        cerr << param->msg_strm.str();
        err_log_strm << param->msg_strm.str();
        log_strm << param->msg_strm.str();

        param->msg_strm.str("");

        temp_strm << "RECEIVE DOWNLOAD_URL ENCRYPTED FAILED FOR ENTRY \""
                  << e.package_name << "\"";

        log_strm << "Failed to received encrypted download URL for " << e.package_name;

        if (!e.package_version.empty())
        {
           temp_strm << " \"" << e.package_version << "\"";
           log_strm << " " << e.package_version << endl << endl;
        }

        response.command = temp_strm.str();

        pthread_mutex_lock(&param->response_deque_mutex);
        param->response_deque.push_back(response);
        pthread_mutex_unlock(&param->response_deque_mutex);

        ++errors_occurred;

    }  /* |if (status != 0)|  */

    else
    {
        if (param->PARSER_DEBUG)
        {

            cerr << "In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ DOWNLOAD_URL_ENCRYPTED_ZZ "
                 << "FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ':"
                 << endl
                 << "`create_temp_file' succeeded."
                 << endl
                 << "`curr_filename' == " << curr_filename
                 << endl;

        }  /* |if (param->PARSER_DEBUG)|  */ 

        status = accept_data(param, 
                             const_cast<char*>(curr_filename.c_str()),
                             -1, 
                             Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE);

        e.download_url_encrypted = curr_filename;
           
        e.install_order = @=$8@>;

        param->cond_append(e);

        param->entry_string_vector.clear();

        response.type    = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm << "RECEIVE DOWNLOAD_URL ENCRYPTED SUCCEEDED FOR ENTRY \""
                  << e.package_name << "\"";

        log_strm << "Received encrypted download URL for " << e.package_name;

        if (!e.package_version.empty())
        {
           temp_strm << " \"" << e.package_version << "\"";
           log_strm << " " << e.package_version << endl << endl;
        }

        response.command = temp_strm.str();

        pthread_mutex_lock(&param->response_deque_mutex);
        param->response_deque.push_back(response);
        pthread_mutex_unlock(&param->response_deque_mutex);

        temp_strm.str("");

        fetch = true;

        param->entry_string_vector.clear();

    }  /* |else| (|create_temp_file| succeeded)  */

};

@q **** (4) statement --> SERVER_ZZ SENDING_ZZ DOWNLOAD_COMMAND_ENCRYPTED_ZZ @>
@q **** (4) STRING_ZZ FOR_ZZ ENTRY_ZZ entry_string_list                      @>
@q **** (4) ORDER_ZZ INTEGER_ZZ                                              @>  

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SENDING\_ZZ} 
\.{DOWNLOAD\_COMMAND\_ENCRYPTED\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} 
\<entry string list>  \.{ORDER\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2011.03.30.}

\LOG
\initials{LDF 2011.03.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SENDING_ZZ DOWNLOAD_COMMAND_ENCRYPTED_ZZ @>@/
@=FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ DOWNLOAD_COMMAND_ENCRYPTED_ZZ "
            << "FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ'."
            << endl;

    string curr_filename;

    stringstream temp_strm;

    Response_Type response;

    Entry_Type e;

    e.encrypted_flag = true;

    e.package_name  = param->entry_string_vector[0];

    if (param->entry_string_vector.size() > 1 && param->entry_string_vector[1] != "-1")
       e.package_version = param->entry_string_vector[1];

    if (param->entry_string_vector.size() > 2)
       e.owner = param->entry_string_vector[2];

    if (param->entry_string_vector.size() > 3)
    {
       e.owner_key_id = atoi(param->entry_string_vector[3].c_str());

       if (param->PARSER_DEBUG)
       {
           cerr << "param->entry_string_vector[3] == " << param->entry_string_vector[3] << endl;

       }  /* |if (param->PARSER_DEBUG)|  */
    }

    if (param->PARSER_DEBUG) 
       cerr << "e.owner_key_id == " << e.owner_key_id << endl;

    int status = create_temp_file(curr_filename, 0, "UU");

    if (status != 0)
    {
        param->msg_strm.str("");

        param->msg_strm << "ERROR!  In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ "
                       << "DOWNLOAD_COMMAND_ENCRYPTED_ZZ "
                       << "FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ':"
                       << endl 
                       << "`create_temp_file' failed.  Will try to continue."
                       << endl;
        cerr << param->msg_strm.str();
        err_log_strm << param->msg_strm.str();
        log_strm << param->msg_strm.str();

        param->msg_strm.str("");

        temp_strm << "RECEIVE DOWNLOAD_COMMAND ENCRYPTED FAILED FOR ENTRY \""
                  << e.package_name << "\"";

        log_strm << "Failed to received encrypted download command for " << e.package_name;

        if (!e.package_version.empty())
        {
           temp_strm << " \"" << e.package_version << "\"";
           log_strm << " " << e.package_version << endl << endl;
        }

        response.command = temp_strm.str();

        pthread_mutex_lock(&param->response_deque_mutex);
        param->response_deque.push_back(response);
        pthread_mutex_unlock(&param->response_deque_mutex);

        ++errors_occurred;

    }  /* |if (status != 0)|  */

    else
    {
        if (param->PARSER_DEBUG)
        {

            cerr << "In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ DOWNLOAD_COMMAND_ENCRYPTED_ZZ "
                 << "FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ':"
                 << endl
                 << "`create_temp_file' succeeded."
                 << endl
                 << "`curr_filename' == " << curr_filename
                 << endl;

        }  /* |if (param->PARSER_DEBUG)|  */ 

        status = accept_data(param, 
                             const_cast<char*>(curr_filename.c_str()),
                             -1, 
                             Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE);

        e.download_command_encrypted = curr_filename;
           
        e.install_order = @=$8@>;

        param->cond_append(e);

        param->entry_string_vector.clear();

        response.type    = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm << "RECEIVE DOWNLOAD_COMMAND ENCRYPTED SUCCEEDED FOR ENTRY \""
                  << e.package_name << "\"";

        log_strm << "Received encrypted download command for " << e.package_name;

        if (!e.package_version.empty())
        {
           temp_strm << " \"" << e.package_version << "\"";
           log_strm << " " << e.package_version << endl << endl;
        }

        response.command = temp_strm.str();

        pthread_mutex_lock(&param->response_deque_mutex);
        param->response_deque.push_back(response);
        pthread_mutex_unlock(&param->response_deque_mutex);

        temp_strm.str("");

        fetch = true;

        param->entry_string_vector.clear();

    }  /* |else| (|create_temp_file| succeeded)  */

};

@q **** (4) statement --> SEND_ZZ AUTHORIZATION_ZZ STRING_ZZ @>
@q **** (4) FOR_ZZ ENTRY_ZZ INTEGER_ZZ entry_string_list             @>

@ \<statement> $\longrightarrow$ \.{SEND\_ZZ} \.{AUTHORIZATION\_ZZ}
\.{STRING\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} \.{INTEGER\_ZZ}
\<entry string list>
\initials{LDF 2011.05.06.}

\LOG
\initials{LDF 2011.05.06.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SEND_ZZ AUTHORIZATION_ZZ STRING_ZZ FOR_ZZ @>@/
@=ENTRY_ZZ INTEGER_ZZ entry_string_list@>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `SEND_ZZ AUTHORIZATION_ZZ STRING_ZZ "
             << "FOR_ZZ ENTRY_ZZ INTEGER_ZZ entry_string_list'."
             << endl;

    Response_Type response;
    response.entry_id        = @=$6@>;

    /* !! TODO:  LDF 2010.03.23.  Add error handling for the case that
       |entry_string_vector.size() == 0|.  */

    response.entry_name      = param->entry_string_vector[0];

    if (param->entry_string_vector.size() > 1)
       response.version         = param->entry_string_vector[1];
    else
       response.version         = "";

    param->entry_string_vector.clear();

    response.local_filename  = @=$3@>;
    response.remote_filename = "";

    response.type = Response_Type::AUTHORIZATION_TYPE;
  
    stringstream temp_strm;

    temp_strm << "CLIENT SENDING AUTHORIZATION <" << @=$3@> << "> " 
              << @=$6@> << " " << response.type
              << " \"" << response.entry_name << "\"";

    if (param->PARSER_DEBUG) 
    {
        cerr << "temp_strm.str() == " << temp_strm.str() << endl;

    }

    response.command = temp_strm.str();

    pthread_mutex_unlock(&param->response_deque_mutex);
    param->response_deque.push_front(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

};

@q **** (4) statement --> SERVER_ZZ SENDING_ZZ AUTHORIZATION_ZZ @>
@q **** (4) STRING_ZZ FOR_ZZ ENTRY_ZZ entry_string_list         @>
@q **** (4) ORDER_ZZ INTEGER_ZZ                                 @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SENDING\_ZZ} 
\.{AUTHORIZATION\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} 
\<entry string list>  \.{ORDER\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2011.05.06.}

\LOG
\initials{LDF 2011.05.06.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SENDING_ZZ AUTHORIZATION_ZZ @>@/
@=FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ AUTHORIZATION_ZZ "
            << "FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ'."
            << endl;

    string curr_filename;

    stringstream temp_strm;

    Response_Type response;

    Entry_Type e;

    e.encrypted_flag = true;

    e.package_name  = param->entry_string_vector[0];

    if (param->entry_string_vector.size() > 1 && param->entry_string_vector[1] != "-1")
       e.package_version = param->entry_string_vector[1];

    if (param->entry_string_vector.size() > 2)
       e.owner = param->entry_string_vector[2];

    int status = create_temp_file(curr_filename, 0, "VV");

    if (status != 0)
    {
        param->msg_strm.str("");

        param->msg_strm << "ERROR!  In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ "
                       << "AUTHORIZATION_ZZ "
                       << "FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ':"
                       << endl 
                       << "`create_temp_file' failed.  Will try to continue."
                       << endl;
        cerr << param->msg_strm.str();
        err_log_strm << param->msg_strm.str();
        log_strm << param->msg_strm.str();

        param->msg_strm.str("");

        temp_strm << "RECEIVE AUTHORIZATION FAILED FOR ENTRY \""
                  << e.package_name << "\"";

        log_strm << "Failed to received authorization for " << e.package_name;

        if (!e.package_version.empty())
        {
           temp_strm << " \"" << e.package_version << "\"";
           log_strm << " " << e.package_version << endl << endl;
        }

        response.command = temp_strm.str();

        pthread_mutex_lock(&param->response_deque_mutex);
        param->response_deque.push_back(response);
        pthread_mutex_unlock(&param->response_deque_mutex);

        ++errors_occurred;

    }  /* |if (status != 0)|  */

    else
    {
        if (param->PARSER_DEBUG)
        {

            cerr << "In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ AUTHORIZATION_ZZ "
                 << "FOR_ZZ ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ':"
                 << endl
                 << "`create_temp_file' succeeded."
                 << endl
                 << "`curr_filename' == " << curr_filename
                 << endl;

        }  /* |if (param->PARSER_DEBUG)|  */ 

        status = accept_data(param, 
                             const_cast<char*>(curr_filename.c_str()),
                             -1, 
                             Response_Type::AUTHORIZATION_TYPE);

        e.authorization = curr_filename;

        if (param->PARSER_DEBUG)
           cerr << "e.authorization == " << e.authorization << endl;

        e.install_order = @=$8@>;

        param->cond_append(e);

        param->entry_string_vector.clear();

        response.type    = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm << "RECEIVE AUTHORIZATION SUCCEEDED FOR ENTRY \""
                  << e.package_name << "\"";

        log_strm << "Received authorization for " << e.package_name;

        if (!e.package_version.empty())
        {
           temp_strm << " \"" << e.package_version << "\"";
           log_strm << " " << e.package_version << endl << endl;
        }

        response.command = temp_strm.str();

        pthread_mutex_lock(&param->response_deque_mutex);
        param->response_deque.push_back(response);
        pthread_mutex_unlock(&param->response_deque_mutex);

        temp_strm.str("");

        fetch = true;

        param->entry_string_vector.clear();

    }  /* |else| (|create_temp_file| succeeded)  */

};

@q **** (4) statement --> RECEIVE_ZZ AUTHORIZATION_ZZ SUCCEEDED_ZZ @>
@q **** (4) FOR_ZZ ENTRY_ZZ entry_string_list                      @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_ZZ} \.{AUTHORIZATION\_ZZ}
\.{SUCCEEDED\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2011.05.06.}

\LOG
\initials{LDF 2011.05.06.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: RECEIVE_ZZ AUTHORIZATION_ZZ SUCCEEDED_ZZ FOR_ZZ @>@/
@=ENTRY_ZZ entry_string_list@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `statement: statement --> "
             << "RECEIVE_ZZ AUTHORIZATION_ZZ SUCCEEDED_ZZ FOR_ZZ "
             << "ENTRY_ZZ entry_string_list'."
             << endl;

     log_strm << "Receive authorization for entry " 
              << left << setw(12) << param->entry_string_vector[0];
  
     if (   param->entry_string_vector.size() > 1 
         && !param->entry_string_vector[1].empty())

        log_strm << " " << param->entry_string_vector[1];

     log_strm << " " << setw(8) << "" << " succeeded" << endl;

     param->entry_string_vector.clear();

};

@q **** (4) statement --> RECEIVE_ZZ AUTHORIZATION_ZZ FAILED_ZZ @>
@q **** (4) FOR_ZZ ENTRY_ZZ entry_string_list                         @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_ZZ} \.{AUTHORIZATION\_ZZ}
\.{FAILED\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2011.05.06.}

\LOG
\initials{LDF 2011.05.06.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: RECEIVE_ZZ AUTHORIZATION_ZZ FAILED_ZZ FOR_ZZ ENTRY_ZZ @>@/
@=entry_string_list@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
   
         cerr << "In `zzparse':  Rule `statement: statement --> "
              << "RECEIVE_ZZ AUTHORIZATION_ZZ FAILED_ZZ FOR_ZZ ENTRY_ZZ STRING_ZZ'."
              << endl;

     int command_or_url =@=$2@>;

     param->msg_strm << "Error:  Receive authorization for entry " 
                     << left << setw(12) << param->entry_string_vector[0];
  
     if (   param->entry_string_vector.size() > 1 
         && !param->entry_string_vector[1].empty())

        param->msg_strm << " " << param->entry_string_vector[1];

     param->msg_strm << " " << setw(8) << "" << "failed" << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     param->entry_string_vector.clear();

     param->msg_strm.str("");

     ++errors_occurred;

};

@q **** (4) statement --> SERVER_ZZ AUTHORIZATION_ZZ NOT_FOUND_ZZ NOT_FOUND_ZZ @>
@q **** (4)               FOR_ZZ ENTRY_ZZ entry_string_list                    @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} 
\.{AUTHORIZATION\_ZZ} \.{NOT\_FOUND\_ZZ}
\.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2011.05.06.}

\LOG
\initials{LDF 2011.05.06.}
Added this rule.

\initials{LDF 2011.05.31.}
Removed error message.  The \.{authorization} field for 
non-encrypted entries will be empty.  At the time the ``\.{fetch}'' 
command is put onto the command stack, it's not known whether an entry 
is encrypted or not.  If an authorization is needed and not found, the error will 
occur later on during the run.
\ENDLOG

@<Rules@>=
  
@=statement: SERVER_ZZ AUTHORIZATION_ZZ NOT_FOUND_ZZ FOR_ZZ ENTRY_ZZ entry_string_list@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)

        cerr << "In `zzparse':  Rule `statement: SERVER_ZZ AUTHORIZATION_ZZ "
             << "NOT_FOUND_ZZ FOR_ZZ ENTRY_ZZ entry_string_list'."
             << endl;

};

@q **** (4) statement --> SERVER_FINISHED_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_FINISHED\_ZZ}.
\initials{LDF 2010.01.12.}

@<Rules@>=

@=statement: SERVER_FINISHED_ZZ@>
{

     if (static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter))->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `statement: SERVER_FINISHED_ZZ'."
             << endl;

    static_cast<Scan_Parse_Parameter_Type*>(
       zzget_extra(parameter))->server_finished = true;

};

@q **** (4) statement --> RECEIVE_ZZ INSTALLATION_SCRIPT_ZZ SUCCEEDED_ZZ @>
@q **** (4) FOR_ZZ ENTRY_ZZ entry_string_list                            @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_ZZ} \.{INSTALLATION\_SCRIPT\_ZZ} 
\.{SUCCEEDED\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2010.03.11.}

\LOG
\initials{LDF 2010.03.11.}
Added this rule.

\initials{LDF 2010.03.29.}
Changed |STRING_ZZ| to \<entry string list>.  Removed variant rule with
two |STRING_ZZ| symbols.
\ENDLOG

@<Rules@>=

@=statement: RECEIVE_ZZ INSTALLATION_SCRIPT_ZZ SUCCEEDED_ZZ FOR_ZZ @>@/
@=ENTRY_ZZ entry_string_list@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `statement: statement --> "
             << "RECEIVE_ZZ INSTALLATION_SCRIPT_ZZ SUCCEEDED_ZZ FOR_ZZ "
             << "ENTRY_ZZ entry_string_list'."
             << endl;

     log_strm << "Receive installation script for entry " 
              << left << setw(12) << param->entry_string_vector[0];
  
     if (   param->entry_string_vector.size() > 1 
         && !param->entry_string_vector[1].empty())

        log_strm << " " << param->entry_string_vector[1];

     log_strm << " " << setw(8) << "" << " succeeded" << endl;

     param->entry_string_vector.clear();

};

@q **** (4) statement --> RECEIVE_ZZ INSTALLATION_SCRIPT_ZZ FAILED_ZZ @>
@q **** (4) FOR_ZZ ENTRY_ZZ entry_string_list                         @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_ZZ} \.{INSTALLATION\_SCRIPT\_ZZ} 
\.{FAILED\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2010.03.11.}

\LOG
\initials{LDF 2010.03.11.}
Added this rule.

\initials{LDF 2010.03.29.}
Changed |STRING_ZZ| to \<entry string list>.  Removed variant rule with
two |STRING_ZZ| symbols.
\ENDLOG

@<Rules@>=

@=statement: RECEIVE_ZZ INSTALLATION_SCRIPT_ZZ FAILED_ZZ FOR_ZZ ENTRY_ZZ @>@/
@=entry_string_list@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
   
         cerr << "In `zzparse':  Rule `statement: statement --> "
              << "RECEIVE_ZZ INSTALLATION_SCRIPT_ZZ FAILED_ZZ FOR_ZZ ENTRY_ZZ STRING_ZZ'."
              << endl;

     param->msg_strm << "Error:  Receive installation script for entry "
              << left << setw(12) << param->entry_string_vector[0];
  
     if (   param->entry_string_vector.size() > 1 
         && !param->entry_string_vector[1].empty())

        param->msg_strm << " " << param->entry_string_vector[1];

     param->msg_strm << " " << setw(8) << "" << "failed" << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     param->entry_string_vector.clear();

     param->msg_strm.str("");

     ++errors_occurred;

};

@q **** (4) statement --> RECEIVE_ZZ download_info_encrypted SUCCEEDED_ZZ @>
@q **** (4) FOR_ZZ ENTRY_ZZ entry_string_list                               @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_ZZ} \<download info encrypted>
\.{SUCCEEDED\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2011.04.21.}

\LOG
\initials{LDF 2011.04.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: RECEIVE_ZZ download_info_encrypted SUCCEEDED_ZZ FOR_ZZ @>@/
@=ENTRY_ZZ entry_string_list@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `statement: statement --> "
             << "RECEIVE_ZZ download_info_encrypted SUCCEEDED_ZZ FOR_ZZ "
             << "ENTRY_ZZ entry_string_list'."
             << endl;

     int command_or_url;

     if (@=$2@> == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE)
        command_or_url = 0;
     else
        command_or_url = 1;

     log_strm << "Receive download ";

     if (command_or_url == 1)
        log_strm << "command ";
     else 
        log_strm << "URL ";

     log_strm << "for entry " 
              << left << setw(12) << param->entry_string_vector[0];
  
     if (   param->entry_string_vector.size() > 1 
         && !param->entry_string_vector[1].empty())

        log_strm << " " << param->entry_string_vector[1];

     log_strm << " " << setw(8) << "" << " succeeded" << endl;

     param->entry_string_vector.clear();

};

@q **** (4) statement --> RECEIVE_ZZ download_info_encrypted FAILED_ZZ @>
@q **** (4) FOR_ZZ ENTRY_ZZ entry_string_list                         @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_ZZ} \<download info encrypted>
\.{FAILED\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2011.04.21.}

\LOG
\initials{LDF 2011.04.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: RECEIVE_ZZ download_info_encrypted FAILED_ZZ FOR_ZZ ENTRY_ZZ @>@/
@=entry_string_list@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
   
         cerr << "In `zzparse':  Rule `statement: statement --> "
              << "RECEIVE_ZZ download_info_encrypted FAILED_ZZ FOR_ZZ ENTRY_ZZ STRING_ZZ'."
              << endl;

     int command_or_url;

     if (@=$2@> == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE)
        command_or_url = 0;
     else
        command_or_url = 1;

     param->msg_strm << "Error:  Receive download ";

     if (command_or_url == 1)
        param->msg_strm << "command ";
     else 
        param->msg_strm << "URL ";

     param->msg_strm << "for entry " 
                     << left << setw(12) << param->entry_string_vector[0];
  
     if (   param->entry_string_vector.size() > 1 
         && !param->entry_string_vector[1].empty())

        param->msg_strm << " " << param->entry_string_vector[1];

     param->msg_strm << " " << setw(8) << "" << "failed" << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     param->entry_string_vector.clear();

     param->msg_strm.str("");

     ++errors_occurred;

};

@q **** (4) statement --> SERVER_ZZ DOWNLOAD_INFO_ZZ NOT_FOUND_ZZ NOT_FOUND_ZZ @>
@q **** (4)               FOR_ZZ ENTRY_ZZ entry_string_list                   @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} 
\.{DOWNLOAD\_INFO\_ZZ}\.{NOT\_FOUND\_ZZ}
\.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2010.02.02.}

\LOG
\initials{LDF 2010.02.02.}
Added this rule.

\initials{LDF 2010.03.11.}
Added 
``\.{FOR\_ZZ} \.{ENTRY\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}''.

\initials{LDF 2010.03.26.}
Replaced \.{STRING\_ZZ} \.{STRING\_ZZ} with \<entry string list>.
\ENDLOG

@<Rules@>=
  
@=statement: SERVER_ZZ DOWNLOAD_INFO_ZZ NOT_FOUND_ZZ FOR_ZZ ENTRY_ZZ entry_string_list@>
{
     /* !! TODO:  LDF 2011.10.31.  Use \<download info> instead 
        of |DOWNLOAD_INFO_ZZ|.  */

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)

        cerr << "In `zzparse':  Rule `statement: SERVER_ZZ DOWNLOAD_INFO_ZZ "
             << "NOT_FOUND_ZZ FOR_ZZ ENTRY_ZZ entry_string_list'."
             << endl;

     param->msg_strm.str("");

     param->msg_strm << "ERROR!  In `zzparse'," 
                     << endl 
                     << "Rule `statement: SERVER_ZZ DOWNLOAD_INFO_ZZ "
                     << "NOT_FOUND_ZZ FOR_ZZ ENTRY_ZZ entry_string_list':"
                     << endl
                     << "Download information not found for "
                     << param->entry_string_vector[0];

     if (param->entry_string_vector.size() > 1)
        param->msg_strm << " " << param->entry_string_vector[1];

     param->msg_strm << endl;

     param->entry_string_vector.clear();

     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();
     cerr << param->msg_strm.str();

     param->msg_strm.str("");

};

@q **** (4) statement --> SERVER_ZZ PREREQUISITES_ZZ NOT_FOUND_ZZ FOR_ZZ @>
@q **** (4) ENTRY_ZZ entry_string_list                                   @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} 
\.{PREREQUISITES\_ZZ}\.{NOT\_FOUND\_ZZ}
\.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2010.03.04.}

\LOG
\initials{LDF 2010.03.04.}
Added this rule.

\initials{LDF 2010.03.12.}
Added \.{FOR\_ZZ} \.{ENTRY\_ZZ} \.{STRING\_ZZ}.

\initials{LDF 2010.03.29.}
Changed \.{STRING\_ZZ} to \<entry string list> and removed variant rule with two 
\.{STRING\_ZZ} symbols.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ PREREQUISITES_ZZ NOT_FOUND_ZZ @>@/
@=FOR_ZZ ENTRY_ZZ entry_string_list@>
{
   
     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     param->msg_strm << "In `zzparse':  Rule `statement: SERVER_ZZ PREREQUISITES_ZZ "
                     << "NOT_FOUND_ZZ FOR_ZZ ENTRY_ZZ entry_string_list'."
                     << endl;

     param->msg_strm << param->msg_strm.str() 
                     << endl
                     << "`param->entry_string_vector[0]' == " << param->entry_string_vector[0]
                     << endl;

     if (   param->entry_string_vector.size() > 1 
         && !param->entry_string_vector[1].empty())
 
        param->msg_strm << "`param->entry_string_vector[1]' == " << param->entry_string_vector[1]
             << endl;
     else
        param->msg_strm << "`param->entry_string_vector[1]' doesn't exist or is empty."
                              << endl;

     if (param->PARSER_DEBUG)
     {
         cerr << param->msg_strm.str();          

     }  /* |if (param->PARSER_DEBUG)|  */

     log_strm << param->msg_strm.str();

     param->msg_strm.str("");

};

@q **** (4) statement --> SERVER_ZZ PREREQUISITES_ZZ FOR_ZZ ENTRY_ZZ @>
@q **** (4) entry_string_list FOUND_ZZ prerequisite_list   @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{PREREQUISITES\_ZZ} 
\.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list> \.{FOUND\_ZZ}.
\initials{LDF 2010.03.05.}

\LOG
\initials{LDF 2010.03.05.}
Added this rule.

\initials{LDF 2010.09.16.}
Changed {STRING\_ZZ} \.{STRING\_ZZ} to \<entry string list>.  Removed rule 
with one {STRING\_ZZ}
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ PREREQUISITES_ZZ FOR_ZZ ENTRY_ZZ entry_string_list @>@/
@=FOUND_ZZ prerequisite_list @>
{

     Scan_Parse_Parameter_Type *param 
        = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));   

     if (param->PARSER_DEBUG)
     {
        cerr << "In `zzparse':  Rule `statement: SERVER_ZZ PREREQUISITES_ZZ "
             << "FOR_ZZ ENTRY_ZZ entry_string_list FOUND_ZZ prerequisite_list'."
             << endl;

        cerr << "`param->prerequisite_list':" 
             << endl
             << param->prerequisite_list
             << endl;

     }  /* |if (param->PARSER_DEBUG)|  */

     string curr_package_name = param->entry_string_vector[0];
     string curr_package_version;

     if (   param->entry_string_vector.size() > 1 
         && !param->entry_string_vector[1].empty())
        curr_package_version = param->entry_string_vector[1];

     param->entry_string_vector.clear();

     int status = param->request_prerequisites(curr_package_name, curr_package_version);

     if (status != 0)
     {
          param->msg_strm.str("");

          param->msg_strm << "ERROR!  In `zzparse':  Rule `statement: SERVER_ZZ PREREQUISITES_ZZ "
                          << "FOR_ZZ ENTRY_ZZ entry_string_list FOUND_ZZ prerequisite_list':"
                          << endl
                          << "`Scan_Parse_Parameter_Type::request_prerequisites' failed, "
                          << "returning " << status
                          << endl
                          << "Exiting function unsuccessfully with return value 1."
                          << endl;

          cerr << param->msg_strm.str();
          err_log_strm << param->msg_strm.str();
          log_strm << param->msg_strm.str();

          param->msg_strm.str("");

          ++errors_occurred;

          param->prerequisite_list = "";

          return 1;

     }  /* |if (status != 0)|  */

     else if (param->PARSER_DEBUG)
     {
        cerr << "In `zzparse':  Rule `statement: SERVER_ZZ PREREQUISITES_ZZ "
             << "FOR_ZZ ENTRY_ZZ entry_string_list FOUND_ZZ prerequisite_list':"
             << endl
             << "`Scan_Parse_Parameter_Type::request_prerequisites' succeeded."
             << endl;

     }  /* |else if (param->PARSER_DEBUG)|  */ 

     param->prerequisite_list = "";

};

@q **** (4) prerequisite_list.  @>
@ \<prerequisite list>.
\initials{LDF 2010.03.05.}

\LOG
\initials{LDF 2010.03.05.}
Added this type declaration.
\ENDLOG

@<Type declarations for non-terminal symbols@>=
@=%type <int_value> prerequisite_list@>@/

@q ***** (5) prerequisite_list: /* Empty  */  @>

@ \<prerequisite list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2010.03.05.}

\LOG
\initials{LDF 2010.03.05.}
Added this rule.
\ENDLOG

@<Rules@>=

@=prerequisite_list: /* Empty  */@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `prerequisite_list: /* Empty  */'."
             << endl;

     param->prerequisite_list = "";

};

@q ***** (5) prerequisite_list: prerequisite_list STRING_ZZ.   @>

@ \<prerequisite list> $\longrightarrow$ \<prerequisite list> \.{STRING\_ZZ}. 
\initials{LDF 2010.03.05.}

\LOG
\initials{LDF 2010.03.05.}
Added this rule.
\ENDLOG

@<Rules@>=

@=prerequisite_list: prerequisite_list STRING_ZZ @>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)

        cerr << "In `zzparse':  "
             << "Rule `prerequisite_list: prerequisite_list STRING_ZZ'."
             << endl;

     param->prerequisite_list += @=$2@>;

};

@q **** (4) statement --> SERVER_ZZ DISTINGUISHED_NAME_ZZ NOT_FOUND_ZZ  @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} 
\.{DISTINGUISHED\_NAME\_ZZ}\.{NOT\_FOUND\_ZZ}.
\initials{LDF 2010.02.11.}

\LOG
\initials{LDF 2010.02.11.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DISTINGUISHED_NAME_ZZ NOT_FOUND_ZZ @>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `statement: SERVER_ZZ DISTINGUISHED_NAME_ZZ "
             << "NOT_FOUND_ZZ'."
             << endl;

     param->msg_strm.str("");

     param->msg_strm << "ERROR!  In `zzparse':  Rule `statement: SERVER_ZZ DISTINGUISHED_NAME_ZZ "
                     << "NOT_FOUND_ZZ':"
                     << endl
                     << "\"Distinguished Name\" not found.  Failed to verify user."
                     << endl 
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;   

     err_log_strm << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     cerr << param->msg_strm.str();

     param->msg_strm.str("");

     ++errors_occurred;

     return 1;
    
};

@q **** (4) statement --> SERVER_ZZ DISTINGUISHED_NAME_ZZ VALIDATED_ZZ  @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} 
\.{DISTINGUISHED\_NAME\_ZZ}\.{VALIDATED\_ZZ}.
\initials{LDF 2010.02.11.}

\LOG
\initials{LDF 2010.02.11.}
Added this rule.

\initials{LDF 2011.09.26.}
Added code to account for the case where a proxy credential is transferred.

\initials{LDF 2011.10.03.}
Removed code that issued warnings.  No longer relevant.

\initials{LDF 2012.02.27.}
Removed code for showing entries.  It's no longer needed, since the client 
can send input from a file or standard input to the server in this case, i.e.,
when the user has identified himself with a proxy credential.

\initials{LDF 2012.03.19.}
Added code for fetching ``environment'' shellscript.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DISTINGUISHED_NAME_ZZ VALIDATED_ZZ @>
{
@q ***** (5) @>
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement: SERVER_ZZ DISTINGUISHED_NAME_ZZ "
            << "VALIDATED_ZZ'."
            << endl;

@q ***** (5) @>

   if (param->PARSER_DEBUG) 
   {
@q ****** (6) @>

       int i = 0;

       cerr << "`fetch' == " << fetch
            << endl 
            << "`install' == " << install
            << endl 
            << "`transfer_proxy_cred' == " << transfer_proxy_cred
            << endl 
            << "`globus_site' == " << globus_site
            << endl;

       if (package_names.size() == 0)
          cerr << "`package_names.size()' == 0"
               << endl;

       else
       {
          for (vector<string>::const_iterator iter = package_names.begin();
               iter != package_names.end();
               ++iter)
             cerr << "`package_names[" << i++ << "]' == " << *iter
               << endl;
       }

       if (package_versions.size() == 0)
          cerr << "`package_versions.size()' == 0"
               << endl;

       else
       {

           i = 0;

           for (vector<string>::const_iterator iter = package_versions.begin();
                iter != package_versions.end();
                ++iter)
              cerr << "`package_versions[" << i++ << "]' == " << *iter
                << endl;

       }

       if (transfer_proxy_cred)
          cerr << "transfer_proxy_cred_filename == " 
               << transfer_proxy_cred_filename << endl;

@q ****** (6) @>

   }  /* |if (param->PARSER_DEBUG)|  */

@q ***** (5) @>

   stringstream temp_strm;

   Response_Type response;
   response.type  = Response_Type::COMMAND_ONLY_TYPE;

   if (package_names.size() > 0)
   {

      temp_strm.str("");
 
      string s;

      vector<string>::const_iterator version_iter 
         = package_versions.begin();

      string temp_str;

@q ****** (6) @>

      for (vector<string>::const_iterator iter = package_names.begin();
           iter != package_names.end();
           ++iter)
      {
@q ******* (7) @>
@
\LOG
\initials{LDF 2011.05.06.}
Added code to account for ``authorization''.

\initials{LDF 2011.08.10.}
@:BUG FIX@> BUG FIX:  Now using $\langle\ldots\rangle$ instead of |""| to delimit 
the package name and the package version.
@:TODO@> !! TODO:  Find out why this is necessary.  I would have thought that the 
quotation marks would have worked.
\ENDLOG 

@<Rules@>=

          temp_str = *iter;

          while(isblank(temp_str[temp_str.size() - 1]))
              temp_str.erase(temp_str.size() - 1);

          s = "";
          temp_strm.str("");

          temp_strm << "FETCH INSTALLATION_SCRIPT FOR ENTRY " 
                    << "<" << temp_str << ">";
         
          if (package_versions.size() > 0 && *version_iter != "")
             temp_strm << " <" << *version_iter++ << ">";

          temp_strm << " ORDER 0"; 

          if (param->PARSER_DEBUG)
          {
              lock_cerr_mutex(); 
              cerr << "`temp_strm.str()' == " << temp_strm.str() 
                   << endl;
              unlock_cerr_mutex(); 

          }  /* |if (param->PARSER_DEBUG)|  */

          response.command = temp_strm.str();

          pthread_mutex_unlock(&param->response_deque_mutex);
          param->response_deque.push_front(response);
          pthread_mutex_unlock(&param->response_deque_mutex);

          s = temp_strm.str();
          s.replace(strlen("FETCH") + 1, 
                    strlen("INSTALLATION_SCRIPT"), 
                    "DOWNLOAD_INFO");

          if (param->PARSER_DEBUG)
          {
               cerr << "`s' == " << s << endl;

          }  /* |if (param->PARSER_DEBUG)|  */

          response.command = s;

          pthread_mutex_unlock(&param->response_deque_mutex);
          param->response_deque.push_front(response);
          pthread_mutex_unlock(&param->response_deque_mutex);

          s = temp_strm.str();
          s.replace(strlen("FETCH") + 1, 
                    strlen("INSTALLATION_SCRIPT"), 
                    "AUTHORIZATION");

          if (param->PARSER_DEBUG)
          {
               cerr << "`s' == " << s << endl;

          }  /* |if (param->PARSER_DEBUG)|  */

          response.command = s;

          pthread_mutex_unlock(&param->response_deque_mutex);
          param->response_deque.push_front(response);
          pthread_mutex_unlock(&param->response_deque_mutex);

          if (resolve_dependencies)
          {

             s.replace(strlen("FETCH") + 1, 
                       strlen("DOWNLOAD_INFO"), 
                       "PREREQUISITES");

             s.erase(s.find(" ORDER 0"));

             if (param->PARSER_DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << "`s' == " << s
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (param->PARSER_DEBUG)|  */ 

             response.command = s;

             pthread_mutex_unlock(&param->response_deque_mutex);
             param->response_deque.push_front(response);
             pthread_mutex_unlock(&param->response_deque_mutex);

          } /* |if (resolve_dependencies)|  */

@q ******* (7) @>

     }  /* |for|  */

@q ****** (6) @>

   }  /* |else if (package_names.size() > 0)|  */

@q ***** (5) Set up for transferring a proxy credential.  @>

@ Set up for transferring a proxy credential.  

\LOG
\initials{LDF 2011.09.26.}
Added this section.
\ENDLOG

@<Rules@>=

   if (transfer_proxy_cred)
   {

       if (param->PARSER_DEBUG)
       {

            lock_cerr_mutex(); 
            cerr << "Will transfer proxy credential '" 
                 << transfer_proxy_cred_filename << "'."
                 << endl;
            unlock_cerr_mutex(); 

       }  /* |if (param->PARSER_DEBUG)|  */

       int status = handle_proxy_cred(transfer_proxy_cred_filename);

       if (status != 0)
       {
           param->msg_strm.str("");

           param->msg_strm  << "ERROR!  In `zzparse':  In rule `statement: "
                << "SERVER_ZZ DISTINGUISHED_NAME_ZZ "
                << "VALIDATED_ZZ':"
                << endl
                << "`handle_proxy_cred' failed, returning " << status << "."
                << endl
                << "proxy credential `" << transfer_proxy_cred_filename << "' "
                << "is invalid.  Not sending to server `optdbsrv'."
                << endl
                << "Will try to continue."
                << endl;

           err_log_strm << param->msg_strm.str();
           log_strm << param->msg_strm.str();

           lock_cerr_mutex(); 
           cerr << param->msg_strm.str();
           unlock_cerr_mutex(); 

           param->msg_strm.str("");

           temp_strm.str("");

           temp_strm << "PROXY_CREDENTIAL <" << transfer_proxy_cred_filename 
                     << "> INVALID CLIENT NOT TO TRANSFER";

           response.command = temp_strm.str();

           temp_strm.str("");
           param->msg_strm.str("");

       }
       else
       {

          if (param->PARSER_DEBUG)
          {
             lock_cerr_mutex(); 
             cerr << "In `zzparse':  In rule `statement: "
                  << "SERVER_ZZ DISTINGUISHED_NAME_ZZ "
                  << "VALIDATED_ZZ':"
                  << endl
                  << "`handle_proxy_cred' succeeded."
                  << endl;
             unlock_cerr_mutex(); 
 
          }  /* |if (param->PARSER_DEBUG)|  */ 

          response.command = "CLIENT TO TRANSFER PROXY_CREDENTIAL <";
          response.command += transfer_proxy_cred_filename;
          response.command += ">";

       }  /* |else| (|handle_proxy_cred| succeeded.)  */

       pthread_mutex_lock(&param->response_deque_mutex);
       param->response_deque.push_back(response);
       pthread_mutex_unlock(&param->response_deque_mutex);

#if 0 
       param->client_finished = false;
       param->server_finished = false;
#endif 

   }  /* |if (transfer_proxy_cred)|  */

@q ***** (5) Fetch environment script.  @>

@ Fetch environment script.
\initials{LDF 2012.03.19.}

\LOG
\initials{LDF 2012.03.19.}
Added this section.
\ENDLOG

@<Rules@>=

   if (!globus_site.empty())
   {
       temp_strm.str("");

       response.command = "FETCH ENVIRONMENT SHELLSCRIPTS FOR GLOBUS_SITE <";
       response.command += globus_site;
       response.command += ">";

       pthread_mutex_lock(&param->response_deque_mutex);
       param->response_deque.push_back(response);
       pthread_mutex_unlock(&param->response_deque_mutex);

       if (param->PARSER_DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "In `zzparse':  In rule `statement: "
                << "SERVER_ZZ DISTINGUISHED_NAME_ZZ "
                << "VALIDATED_ZZ':"
                << endl
                << "`response.command' == " << response.command
                << endl;
           unlock_cerr_mutex(); 
 
       }  /* |if (param->PARSER_DEBUG)|  */ 

   }  /* |if (globus_site)|  */

   else if (param->PARSER_DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `zzparse':  In rule `statement: "
            << "SERVER_ZZ DISTINGUISHED_NAME_ZZ "
            << "VALIDATED_ZZ':"
            << endl
            << "`globus_site' is empty.  Not fetching environment shellscript."
            << endl;
       unlock_cerr_mutex(); 
 
   }  /* |else if (param->PARSER_DEBUG)|  */ 

@q ***** (5) @>

};  /* End of rule |@=statement: SERVER_ZZ DISTINGUISHED_NAME_ZZ VALIDATED_ZZ@>|  */

@q **** (4) statement --> SERVER_ZZ DISTINGUISHED_NAME_ZZ VALIDATION_ZZ FAILED_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{DISTINGUISHED\_NAME\_ZZ} 
\.{VALIDATION\_ZZ} \.{FAILED\_ZZ}.
\initials{LDF 2010.04.27.}

\LOG
\initials{LDF 2010.04.27.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DISTINGUISHED_NAME_ZZ VALIDATION_ZZ FAILED_ZZ @>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ DISTINGUISHED_NAME_ZZ "
            << "VALIDATION_ZZ FAILED_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "ERROR!  Server failed to validate distinguished name."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   ++errors_occurred;

};

@q **** (4) statement --> SERVER_ZZ CERTIFICATE_ZZ VALIDATION_ZZ FAILED_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{CERTIFICATE\_ZZ} 
\.{VALIDATION\_ZZ} \.{FAILED\_ZZ}.
\initials{LDF 2010.04.29.}

\LOG
\initials{LDF 2010.04.29.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ CERTIFICATE_ZZ VALIDATION_ZZ FAILED_ZZ @>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ CERTIFICATE_ZZ "
            << "VALIDATION_ZZ FAILED_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "ERROR!  Server failed to validate certificate."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   ++errors_occurred;

};

@q **** (4) statement -->  REPLACING_ZZ DUPLICATE_ZZ ENTRY_ZZ entry_string_list @>

@ \<statement> $\longrightarrow$ \.{REPLACING\_ZZ} \.{DUPLICATE\_ZZ} \.{ENTRY\_ZZ} 
\<entry string list>.
\initials{LDF 2010.03.15.}

\LOG
\initials{LDF 2010.03.15.}
Added this rule.

\initials{LDF 2010.05.20.}
Added token \.{REPLACING\_ZZ}.  Removed warning.

\initials{LDF 2010.09.23.}
Replaced \.{STRING\_ZZ} with \<entry string list>.  Removed other rule with 
\.{STRING\_ZZ} \.{STRING\_ZZ}.
\ENDLOG

@<Rules@>=

@=statement: REPLACING_ZZ DUPLICATE_ZZ ENTRY_ZZ entry_string_list @>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  REPLACING_ZZ DUPLICATE_ZZ "
            << "ENTRY_ZZ entry_string_list'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Duplicate entry \""  << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "\":  " << "Replacing." << endl;

   cerr << param->msg_strm.str();

   log_strm << param->msg_strm.str();

   param->entry_string_vector.clear();
   param->msg_strm.str("");

};

@q **** (4) statement --> PREREQUISITE_ZZ prerequisite_string_list FOR_ZZ  @>
@q **** (4) ENTRY_ZZ entry_string_list NOT_FOUND_ZZ                        @>

@ \<statement> $\longrightarrow$ 
\.{PREREQUISITE\_ZZ} \<prerequisite string list> \.{FOR\_ZZ} \.{ENTRY\_ZZ}
\<entry string list> \.{NOT\_FOUND\_ZZ}.
\initials{LDF 2010.03.15.}

\LOG
\initials{LDF 2010.03.15.}
Added this rule.

\initials{LDF 2010.09.23.}
Changed \.{STRING\_ZZ} to \<prerequisite string list> and \<entry string list>,
respectively.  Removed similar rules with different numbers of \.{STRING\_ZZ} 
tokens.
\ENDLOG

@<Rules@>=

@=statement: PREREQUISITE_ZZ prerequisite_string_list FOR_ZZ ENTRY_ZZ @>@/
@=entry_string_list NOT_FOUND_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `PREREQUISITE_ZZ "
            << "prerequisite_string_list FOR_ZZ "
            << "ENTRY_ZZ prerequisite_string_list NOT_FOUND_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "ERROR!  Prerequisite `" << param->prerequisite_string_vector[0];

   if (param->prerequisite_string_vector.size() > 1)
      param->msg_strm << " " << param->prerequisite_string_vector[1];

   param->msg_strm << "' not found for entry `" << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "'.  Continuing."
                   << endl;

   lock_cerr_mutex(); 
   cerr << param->msg_strm.str();
   unlock_cerr_mutex(); 

   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   param->entry_string_vector.clear();
   param->prerequisite_string_vector.clear();

   ++errors_occurred;

};

@q **** (4) statement --> DUPLICATE_ZZ PREREQUISITE_ZZ prerequisite_string_list @>
@q **** (4) FOR_ZZ ENTRY_ZZ entry_string_list                                   @>

@ \<statement> $\longrightarrow$ 
\.{DUPLICATE\_ZZ} \.{PREREQUISITE\_ZZ} \<prerequisite string list>  \.{FOR\_ZZ} 
\.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2010.03.15.}

\LOG
\initials{LDF 2010.03.15.}
Added this rule.

\initials{LDF 2010.09.23.}
Changed \.{STRING\_ZZ} to \<prerequisite string list> and \<entry string list>,
respectively.  Removed similar rules with different numbers of \.{STRING\_ZZ} 
tokens.
\ENDLOG

@<Rules@>=

@=statement: DUPLICATE_ZZ PREREQUISITE_ZZ prerequisite_string_list FOR_ZZ @>@/
@=ENTRY_ZZ entry_string_list@>  
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `DUPLICATE_ZZ PREREQUISITE_ZZ "
            << "prerequisite_string_list FOR_ZZ "
            << "ENTRY_ZZ entry_string_list'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Duplicate prerequisite `" 
                   << param->prerequisite_string_vector[0];

   if (param->prerequisite_string_vector.size() > 1)
      param->msg_strm << " " << param->prerequisite_string_vector[1];

   param->msg_strm << "' for entry `" << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "'.  Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   param->entry_string_vector.clear();
   param->prerequisite_string_vector.clear();

   ++warnings_occurred;

};

@q **** (4) statement --> FAILED_ZZ TO_ZZ ADD_ZZ PREREQUISITE_ZZ prerequisite_string_list @>
@q **** (4) FOR_ZZ ENTRY_ZZ entry_string_list                                             @>

@ \<statement> $\longrightarrow$ \.{FAILED\_ZZ} \.{TO\_ZZ} \.{ADD\_ZZ} 
\.{PREREQUISITE\_ZZ} \<prerequisite string list> \.{FOR\_ZZ} \.{ENTRY\_ZZ} 
\<entry string list>.
\initials{LDF 2010.09.10.}

\LOG
\initials{LDF 2010.09.10.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: FAILED_ZZ TO_ZZ ADD_ZZ PREREQUISITE_ZZ prerequisite_string_list @>@/
@=FOR_ZZ ENTRY_ZZ entry_string_list@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `FAILED_ZZ TO_ZZ ADD_ZZ PREREQUISITE_ZZ "
            << "prerequisite_string_list FOR_ZZ ENTRY_ZZ entry_string_list'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "ERROR!  Failed to add prerequisite `"
                   << param->prerequisite_string_vector[0];

   if (param->prerequisite_string_vector.size() > 1)
      param->msg_strm << " " << param->prerequisite_string_vector[1];

   param->msg_strm << "' for entry `"
                   << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "'.  Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   ++errors_occurred;

};

@q **** (4) statement --> MULTIPLE_ZZ ENTRIES_ZZ FOR_ZZ STRING_ZZ     @>
@q **** (4) NOT_ZZ ADDING_ZZ PREREQUISITE_ZZ prerequisite_string_list @>

@ \<statement> $\longrightarrow$ \.{MULTIPLE\_ZZ} \.{ENTRIES\_ZZ} 
\.{FOR\_ZZ} \.{STRING\_ZZ} \.{NOT\_ZZ} \.{ADDING\_ZZ} \.{PREREQUISITE\_ZZ} 
\<prerequisite string list>.
\initials{LDF 2010.09.15.}

\LOG
\initials{LDF 2010.09.15.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: MULTIPLE_ZZ ENTRIES_ZZ FOR_ZZ STRING_ZZ @>@/
@=NOT_ZZ ADDING_ZZ PREREQUISITE_ZZ prerequisite_string_list@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `MULTIPLE_ZZ ENTRIES_ZZ "
            << "FOR_ZZ STRING_ZZ NOT_ZZ ADDING_ZZ PREREQUISITE_ZZ "
            << "prerequisite_string_list'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Multiple entries for `" << @=$4@> << "'.  "
                   << "Not adding prerequisite `"
                   << param->prerequisite_string_vector[0];

   if (param->prerequisite_string_vector.size() > 1)
      param->msg_strm << " " << param->prerequisite_string_vector[1];

   param->msg_strm << "'.  Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->prerequisite_string_vector.clear();

   ++warnings_occurred;

};

@q **** (4) statement --> AMBIGUOUS_ZZ PREREQUISITE_ZZ STRING_ZZ  @>
@q **** (4) FOR_ZZ ENTRY_ZZ entry_string_list NOT_ZZ ADDING_ZZ    @>

@ \<statement> $\longrightarrow$ \.{AMBIGUOUS\_ZZ} \.{PREREQUISITE\_ZZ} 
\.{STRING\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list>. \.{NOT\_ZZ} \.{ADDING\_ZZ}.
\initials{LDF 2010.09.15.}

\LOG
\initials{LDF 2010.09.15.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: AMBIGUOUS_ZZ PREREQUISITE_ZZ STRING_ZZ FOR_ZZ ENTRY_ZZ entry_string_list @>@/
@=NOT_ZZ ADDING_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `AMBIGUOUS_ZZ PREREQUISITE_ZZ "
            << "STRING_ZZ FOR_ZZ ENTRY_ZZ entry_string_list NOT_ZZ ADDING_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Ambiguous prerequisite `" << @=$3@> 
                   << "' for entry `" << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "'.  Not adding.  Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

   ++warnings_occurred;

};

@q **** (4) statement --> DELETED_ZZ ENTRY_ZZ entry_string_list @>

@ \<statement> $\longrightarrow$ \.{DELETED\_ZZ} \.{ENTRY\_ZZ} 
\<entry string list>.
\initials{LDF 2010.09.09.}

\LOG
\initials{LDF 2010.09.09.}
Added this rule.

\initials{LDF 2010.09.23.}
Replaced \.{STRING\_ZZ} with \<entry string list>.  Removed rule with two
\.{STRING\_ZZ} tokens.
\ENDLOG

@<Rules@>=

@=statement: DELETED_ZZ ENTRY_ZZ entry_string_list@> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `DELETED_ZZ ENTRY_ZZ entry_string_list'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Deleted entry `" << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "'."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

};

@q **** (4) statement --> DELETED_ZZ ENTRIES_ZZ entry_string_list @>

@ \<statement> $\longrightarrow$ \.{DELETED\_ZZ} \.{ENTRIES\_ZZ}.
\initials{LDF 2010.10.14.}

\LOG
\initials{LDF 2010.10.14.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DELETED_ZZ ENTRIES_ZZ@> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `DELETED_ZZ ENTRIES_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Deleted entries."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   param->msg_strm.str("");
};

@q **** (4) statement --> FAILED_ZZ TO_ZZ DELETE_ZZ ENTRY_ZZ entry_string_list @>

@ \<statement> $\longrightarrow$ \.{FAILED\_ZZ} \.{TO\_ZZ} \.{DELETE\_ZZ} 
\.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2010.09.09.}

\LOG
\initials{LDF 2010.09.09.}
Added this rule.

\initials{LDF 2010.09.23.}
Replaced \.{STRING\_ZZ} with \<entry string list>.  Removed rule with two
\.{STRING\_ZZ} tokens.
\ENDLOG

@<Rules@>=

@=statement: FAILED_ZZ TO_ZZ DELETE_ZZ ENTRY_ZZ entry_string_list@> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`FAILED_ZZ TO_ZZ DELETE_ZZ ENTRY_ZZ entry_string_list'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Failed to delete entry `" << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "'.  Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

   ++warnings_occurred;

};

@q **** (4) statement --> FAILED_ZZ TO_ZZ DELETE_ZZ ENTRIES_ZZ @>

@ \<statement> $\longrightarrow$ \.{FAILED\_ZZ} \.{TO\_ZZ} \.{DELETE\_ZZ} 
\.{ENTRIES\_ZZ}.
\initials{LDF 2010.10.14.}

\LOG
\initials{LDF 2010.10.14.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: FAILED_ZZ TO_ZZ DELETE_ZZ ENTRIES_ZZ@> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`FAILED_ZZ TO_ZZ DELETE_ZZ ENTRIES_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Failed to delete entries.  Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   ++warnings_occurred;

};

@q **** (4) statement --> MARKED_ZZ ENTRY_ZZ entry_string_list @>
@q **** (4)               AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ     @>

@ \<statement> $\longrightarrow$ \.{MARKED\_ZZ} \.{ENTRY\_ZZ} 
\<entry string list> \.{AS\_ZZ} \.{DELETED\_ZZ} \.{SUCCESSFULLY\_ZZ}.
\initials{LDF 2012.01.13.}

\LOG
\initials{LDF 2012.01.13.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: MARKED_ZZ ENTRY_ZZ entry_string_list @>@/
@=AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ @> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`MARKED_ZZ ENTRY_ZZ entry_string_list "
            << "AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Marked entry `" << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "' as deleted successfully."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

};

@q **** (4) statement --> MARKED_ZZ ENTRIES_ZZ entry_string_list @>
@q **** (4)               AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ       @>

@ \<statement> $\longrightarrow$ \.{MARKED\_ZZ} \.{ENTRIES\_ZZ}
\.{AS\_ZZ} \.{DELETED\_ZZ} \.{SUCCESSFULLY\_ZZ}.
\initials{LDF 2012.01.13.}

\LOG
\initials{LDF 2012.01.13.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: MARKED_ZZ ENTRIES_ZZ AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ@> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `MARKED_ZZ ENTRIES_ZZ "
            << "AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Marked all entries as deleted successfully."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   param->msg_strm.str("");
};

@q **** (4) statement --> UNMARKED_ZZ ENTRY_ZZ entry_string_list @>
@q **** (4)               AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ       @>

@ \<statement> $\longrightarrow$ \.{UNMARKED\_ZZ} \.{ENTRY\_ZZ} 
\<entry string list> \.{AS\_ZZ} \.{DELETED\_ZZ} \.{SUCCESSFULLY\_ZZ}.
\initials{LDF 2012.01.13.}

\LOG
\initials{LDF 2012.01.13.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: UNMARKED_ZZ ENTRY_ZZ entry_string_list @>@/
@=AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ @> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`UNMARKED_ZZ ENTRY_ZZ entry_string_list "
            << "AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Unmarked entry `" << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "' as deleted successfully."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

};

@q **** (4) statement --> UNMARKED_ZZ ENTRIES_ZZ entry_string_list @>
@q **** (4)               AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ         @>

@ \<statement> $\longrightarrow$ \.{UNMARKED\_ZZ} \.{ENTRIES\_ZZ}
\.{AS\_ZZ} \.{DELETED\_ZZ} \.{SUCCESSFULLY\_ZZ}.
\initials{LDF 2012.01.13.}

\LOG
\initials{LDF 2012.01.13.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: UNMARKED_ZZ ENTRIES_ZZ AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ@> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `UNMARKED_ZZ ENTRIES_ZZ "
            << "AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Unmarked all entries as deleted successfully."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   param->msg_strm.str("");
};

@q **** (4) mark_or_unmark.  @>

@ \<mark or unmark>.
\initials{LDF 2012.05.14.}

\LOG
\initials{LDF 2012.05.14.}
Added this type declaration.
\ENDLOG

@<Type declarations for non-terminal symbols@>=
@=%type <int_value> mark_or_unmark@>@/

@q **** (4) mark_or_unmark: MARK_ZZ@>
@ \<mark or unmark> $\longrightarrow$  \.{MARK\_ZZ}.
\initials{LDF 2012.05.14.}

\LOG
\initials{LDF 2011.03.31.}
Added this rule.
\ENDLOG

@<Rules@>=
@=mark_or_unmark: MARK_ZZ@>
{
     
   @=$$@> = 0;

};

@q **** (4) mark_or_unmark: UNMARK_ZZ@>
@ \<mark or unmark> $\longrightarrow$  \.{UNMARK\_ZZ}.
\initials{LDF 2012.05.14.}

\LOG
\initials{LDF 2011.03.31.}
Added this rule.
\ENDLOG

@<Rules@>=
@=mark_or_unmark: UNMARK_ZZ@>
{
     
   @=$$@> = 1;

};

@q **** (4) statement --> FAILED_ZZ TO_ZZ mark_or_unmark ENTRY_ZZ entry_string_list @>
@q **** (4) AS_ZZ DELETED_ZZ INTEGER_ZZ                                             @>

@ \<statement> $\longrightarrow$ \.{FAILED\_ZZ} \.{TO\_ZZ} \<mark or unmark>
\.{ENTRY\_ZZ} \<entry string list> \.{AS\_ZZ} \.{DELETED\_ZZ}
\.{INTEGER\_ZZ}.
\initials{LDF 2012.01.13.}

\LOG
\initials{LDF 2012.01.13.}
Added this rule.

\initials{LDF 2012.05.14.}
Added `\.{INTEGER\_ZZ}' for error code.  
Replaced \.{MARK\_ZZ} with \<mark or unmark>.  Removed corresponding 
``\.{UNMARK\_ZZ}'' rule.
\ENDLOG

@<Rules@>=

@=statement: FAILED_ZZ TO_ZZ mark_or_unmark ENTRY_ZZ entry_string_list AS_ZZ DELETED_ZZ @>
@=INTEGER_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
   {
         cerr << "In `zzparse':  Rule `statement:  "
            << "`FAILED_ZZ TO_ZZ mark_or_unmark ENTRY_ZZ entry_string_list AS_ZZ "
            << "DELETED_ZZ INTEGER_ZZ."
            << endl
            << "`INTEGER_ZZ' (error code) == " << @=$8@>       
            << endl;

   }  /* |if (param->PARSER_DEBUG)|  */

   string mark_or_unmark_str = (@=$3@> == 0) ? "mark" : "unmark";

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Failed to " << mark_or_unmark_str 
                   << " entry `" << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "' as deleted:"
                   << endl;

   if (@=$8@>  == 0)
   {
        param->msg_strm << "No entry to " << mark_or_unmark_str << ".";
   }
   else if (@=$8@>  == 1)
   {
        param->msg_strm << "Server-side MySQL error.";
   }
   else if (@=$8@>  == 2)
   {
        param->msg_strm << "Entry already " << mark_or_unmark_str << "ed for deletion.";
   }
   else 
   {
        param->msg_strm << "Unspecified server-side error.";
   }

   param->msg_strm << endl 
                   << "Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

   ++warnings_occurred;

};

@q **** (4) statement --> FAILED_ZZ TO_ZZ MARK_ZZ ENTRIES_ZZ @>
@q **** (4) AS_ZZ DELETED_ZZ INTEGER_ZZ                      @>

@ \<statement> $\longrightarrow$ \.{FAILED\_ZZ} \.{TO\_ZZ} \.{MARK\_ZZ} 
\.{ENTRIES\_ZZ} \.{AS\_ZZ} \.{DELETED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.01.13.}

\LOG
\initials{LDF 2012.01.13.}
Added this rule.

\initials{LDF 2012.05.14.}
Added \.{INTEGER\_ZZ} for error code.
\ENDLOG

@<Rules@>=

@=statement: FAILED_ZZ TO_ZZ MARK_ZZ ENTRIES_ZZ @>@/
@=AS_ZZ DELETED_ZZ INTEGER_ZZ@> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`FAILED_ZZ TO_ZZ MARK_ZZ ENTRIES_ZZ AS_ZZ DELETED_ZZ INTEGER_ZZ'."
            << endl
            << "`INTEGER_ZZ' (error code) == " << @=$7@>
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Failed to mark entries as deleted:"
                   << endl;

   if (@=$7@>  == 0)
   {
        param->msg_strm << "No entries to mark.";
   }
   else if (@=$7@>  == 1)
   {
        param->msg_strm << "Server-side MySQL error.";
   }
   else if (@=$7@>  == 2)
   {
        param->msg_strm << "Entries already marked for deletion.";
   }
   else 
   {
        param->msg_strm << "Unspecified server-side error.";
   }

   param->msg_strm << endl 
                   << "Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   ++warnings_occurred;

};

@q **** (4) statement --> FAILED_ZZ TO_ZZ UNMARK_ZZ ENTRIES_ZZ @>
@q **** (4) AS_ZZ DELETED_ZZ INTEGER_ZZ                        @>

@ \<statement> $\longrightarrow$ \.{FAILED\_ZZ} \.{TO\_ZZ} \.{UNMARK\_ZZ} 
\.{ENTRIES\_ZZ} \.{AS\_ZZ} \.{DELETED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.01.13.}

\LOG
\initials{LDF 2012.01.13.}
Added this rule.

\initials{LDF 2012.05.14.}
Added \.{INTEGER\_ZZ} for error code.
\ENDLOG

@<Rules@>=

@=statement: FAILED_ZZ TO_ZZ UNMARK_ZZ ENTRIES_ZZ @>@/
@=AS_ZZ DELETED_ZZ INTEGER_ZZ@>
{
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`FAILED_ZZ TO_ZZ UNMARK_ZZ ENTRIES_ZZ AS_ZZ DELETED_ZZ INTEGER_ZZ'."
            << endl 
            << "`INTEGER_ZZ' (error code) == " << @=$7@>
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Failed to unmark entries as deleted:"
                   << endl;

   if (@=$7@> == 0)
   {
        param->msg_strm << "No entries to unmark.";
   }
   else if (@=$7@> == 1)
   {
        param->msg_strm << "Server-side MySQL error.";
   }
   else if (@=$7@> == 2)
   {
        param->msg_strm << "Entries already unmarked for deletion.";
   }
   else 
   {
        param->msg_strm << "Unspecified server-side error.";
   }

   param->msg_strm << endl 
                   << "Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   ++warnings_occurred;

};

@q **** (4) statement --> ADDED_ZZ PREREQUISITE_ZZ prerequisite_string_list @>
@q **** (4) FOR_ZZ ENTRY_ZZ entry_string_list                               @>

@ \<statement> $\longrightarrow$ \.{ADDED\_ZZ} 
\.{PREREQUISITE\_ZZ} \<prerequisite string list> \.{FOR\_ZZ} \.{ENTRY\_ZZ} 
\<entry string list>.
\initials{LDF 2010.03.16.}

\LOG
\initials{LDF 2010.03.16.}
Added this rule.

\initials{LDF 2010.09.23.}
Replaced \.{STRING\_ZZ} with \<prerequisite string list> and \<entry string
list>, respectively.  Removed variant rules with more \.{STRING\_ZZ} tokens.
\ENDLOG

@<Rules@>=

@=statement: ADDED_ZZ PREREQUISITE_ZZ prerequisite_string_list FOR_ZZ ENTRY_ZZ @>@/
@=entry_string_list@> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `ADDED_ZZ PREREQUISITE_ZZ "
            << "prerequisite_string_list FOR_ZZ ENTRY_ZZ entry_string_list'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Added prerequisite `" << param->prerequisite_string_vector[0];

   if (param->prerequisite_string_vector.size() > 1)
      param->msg_strm << " " << param->prerequisite_string_vector[1];

   param->msg_strm << "' for entry `" << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "'."
                   << endl;

   log_strm << param->msg_strm.str();

   cerr << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();
   param->prerequisite_string_vector.clear();

};

@q **** (4) statement --> DELETED_ZZ PREREQUISITE_ZZ prerequisite_string_list @>
@q **** (4) FOR_ZZ ENTRY_ZZ entry_string_list                                 @>

@ \<statement> $\longrightarrow$ \.{DELETED\_ZZ} 
\.{PREREQUISITE\_ZZ} \<prerequisite string list> \.{FOR\_ZZ} \.{ENTRY\_ZZ} 
\<entry string list>.
\initials{LDF 2010.09.09.}

\LOG
\initials{LDF 2010.09.09.}
Added this rule.

\initials{LDF 2010.09.23.}
Replaced \.{STRING\_ZZ} with \<prerequisite string list> and \<entry string
list>, respectively.  Removed variant rules with more \.{STRING\_ZZ} tokens.
\ENDLOG

@<Rules@>=

@=statement: DELETED_ZZ PREREQUISITE_ZZ prerequisite_string_list FOR_ZZ ENTRY_ZZ @>@/
@=entry_string_list@>
{

   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `DELETED_ZZ PREREQUISITE_ZZ "
            << "prerequisite_string_list FOR_ZZ ENTRY_ZZ entry_string_list'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Deleted prerequisite `" << param->prerequisite_string_vector[0];

   if (param->prerequisite_string_vector.size() > 1)
      param->msg_strm << " " << param->prerequisite_string_vector[1];

   param->msg_strm << "' for entry `" << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "'."
                   << endl;

   log_strm << param->msg_strm.str();

   cerr << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();
   param->prerequisite_string_vector.clear();

};

@q **** (4) statement --> DELETED_ZZ PREREQUISITES_ZZ FOR_ZZ ENTRY_ZZ @>
@q **** (4) entry_string_list                                         @>

@ \<statement> $\longrightarrow$ 
\.{DELETED\_ZZ} \.{PREREQUISITES\_ZZ} \.{FOR\_ZZ} 
\.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2010.09.09.}

\LOG
\initials{LDF 2010.09.09.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DELETED_ZZ PREREQUISITES_ZZ FOR_ZZ ENTRY_ZZ @>@/
@=entry_string_list@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `DELETED_ZZ PREREQUISITES_ZZ "
            << "STRING_ZZ FOR_ZZ ENTRY_ZZ entry_string_list'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Deleted prerequisites for entry `"
                   << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)

      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "'."
                   << endl;

   log_strm << param->msg_strm.str();

   cerr << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

};

@q **** (4) statement --> FAILED_ZZ TO_ZZ DELETE_ZZ PREREQUISITE_ZZ    @>
@q **** (4) prerequisite_string_list FOR_ZZ ENTRY_ZZ entry_string_list @>

@ \<statement> $\longrightarrow$ \.{FAILED\_ZZ} \.{TO\_ZZ} \.{DELETE\_ZZ} 
\.{PREREQUISITE\_ZZ} \<prerequisite string list> \.{FOR\_ZZ} \.{ENTRY\_ZZ} 
\<entry string list>.
\initials{LDF 2010.09.09.}

\LOG
\initials{LDF 2010.09.09.}
Added this rule.

\initials{LDF 2010.09.23.}
Replaced \.{STRING\_ZZ} with \<prerequisite string list> and 
\<entry string list>, respectively.  Removed variant rules with more \.{STRING\_ZZ} tokens.
\ENDLOG

@<Rules@>=

@=statement: FAILED_ZZ TO_ZZ DELETE_ZZ PREREQUISITE_ZZ prerequisite_string_list @>@/
@=FOR_ZZ ENTRY_ZZ entry_string_list@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `FAILED_ZZ TO_ZZ DELETE_ZZ PREREQUISITE_ZZ "
            << "prerequisite_string_list FOR_ZZ ENTRY_ZZ entry_string_list'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Failed to delete prerequisite `" 
                   << param->prerequisite_string_vector[0];

   if (param->prerequisite_string_vector.size() > 1)
      param->msg_strm << " " << param->prerequisite_string_vector[1];

   param->msg_strm << "' for entry `" << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "'."
                   << endl;

   err_log_strm << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   if (param->PARSER_DEBUG)
      cerr << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();
   param->prerequisite_string_vector.clear();

   ++warnings_occurred;

};

@q **** (4) statement --> FAILED_ZZ TO_ZZ DELETE_ZZ PREREQUISITES_ZZ @>
@q **** (4) FOR_ZZ ENTRY_ZZ entry_string_list                        @>

@ \<statement> $\longrightarrow$ \.{FAILED\_ZZ} \.{TO\_ZZ} \.{DELETE\_ZZ} 
\.{PREREQUISITES\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2010.09.09.}

\LOG
\initials{LDF 2010.09.09.}
Added this rule.

\initials{LDF 2010.09.23.}
Replaced \.{STRING\_ZZ} with \<entry string list>, respectively.  
Removed similar rule with two \.{STRING\_ZZ} tokens. 
\ENDLOG

@<Rules@>=

@=statement: FAILED_ZZ TO_ZZ DELETE_ZZ PREREQUISITES_ZZ FOR_ZZ ENTRY_ZZ @>@/
@=entry_string_list@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `FAILED_ZZ TO_ZZ DELETE_ZZ PREREQUISITES_ZZ "
            << "FOR_ZZ ENTRY_ZZ entry_string_list'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Failed to delete prerequisites for entry `"
                   << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "'."
                   << endl;

   err_log_strm << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   if (param->PARSER_DEBUG)
      cerr << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

   ++warnings_occurred;

};

@q **** (4) statement --> NO_ZZ INSTALLATION_SCRIPT_ZZ FOR_ZZ ENTRY_ZZ entry_string_list  @>

@ \<statement> $\longrightarrow$ 
\.{NO\_ZZ} \.{INSTALLATION\_SCRIPT\_ZZ} \.{FOR\_ZZ} \.{ENTRY\_ZZ} \<entry string list>.
\initials{LDF 2010.03.16.}

\LOG
\initials{LDF 2010.03.16.}
Added this rule.

\initials{LDF 2010.03.29.}
Changed \.{STRING\_ZZ} to \<entry string list>.

\initials{LDF 2010.05.19.}
Changed the code that's written to the default shellscript.

\initials{LDF 2010.11.19.}
Minor bug fixes in the code for the default installation script.

\initials{LDF 2011.07.06.}
Now setting |INSTALL_DIR| to the value of |string install_directory| 
instead of \.{\$HOME/Installer} in the default installation script.

\initials{LDF 2012.01.13.}
Added code for setting and exporting the following environment variables:
\.{PATH}\hfil\break
\.{CFLAGS}\hfil\break
\.{CPPFLAGS}\hfil\break
\.{CXXFLAG}\hfil\break
\.{LDFLAGS}\hfil\break
\.{LD\_LIBRARY\_PATH}.
\ENDLOG

@<Rules@>=

@=statement: NO_ZZ INSTALLATION_SCRIPT_ZZ FOR_ZZ ENTRY_ZZ entry_string_list @>@/
@=ORDER_ZZ INTEGER_ZZ@>

{
@q ***** (5) @>   

   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `NO_ZZ INSTALLATION_SCRIPT_ZZ FOR_ZZ "
            << "ENTRY_ZZ entry_string_list ORDER_ZZ INTEGER_ZZ'."
            << endl;

   ofstream temp_file_strm;

   param->msg_strm.str("");

   string script_filename;
   string package_name;
   string package_version;

   param->msg_strm << "No installation script for entry `" << param->entry_string_vector[0] 
                   << "'";

   package_name = param->entry_string_vector[0];

   script_filename = package_name;

   if (param->entry_string_vector.size() > 1 && !param->entry_string_vector[1].empty())
   {
      package_version = param->entry_string_vector[1];
      param->msg_strm << " `" << param->entry_string_vector[1] << "'";
      script_filename += "_";
      script_filename += param->entry_string_vector[1];

   }

   script_filename += "_install.sh";

   param->msg_strm << ".  Creating default script."
                   << endl;

   log_strm << param->msg_strm.str();
   cerr << param->msg_strm.str();
 
   param->msg_strm.str("");

   temp_file_strm.open(script_filename.c_str());

   temp_file_strm << "#! /bin/bash" 
                  << endl << endl 
                  << "# " << script_filename << " (Default script)"
                  << endl << endl
                  << "#### Created " << get_datestamp()
                  << endl
                  << "#### by 'optdbcli'."
                  << endl << endl
                  << "SCRIPT_NAME=" << script_filename
                  << endl 
                  << "PACKAGE_NAME=" << package_name 
                  << endl
                  << "PACKAGE_VERSION=" << package_version
                  << endl 
                  << "INSTALL_DIR=" << install_directory << "/" << package_name;

   if (!package_version.empty())
       temp_file_strm << "_" << package_version;

   temp_file_strm << endl << endl
                  << "export PATH=\"$PATH:$HOME/bin\""
                  << endl 
                  << "export CFLAGS=\"$CFLAGS -I$HOME/include\""
                  << endl 
                  << "export CPPFLAGS=\"$CPPFLAGS -I$HOME/include\""
                  << endl 
                  << "export CXXFLAGS=\"$CXXFLAGS -I$HOME/include\""
                  << endl 
                  << "export LDFLAGS=\"$LDFLAGS -L$HOME/lib\""
                  << endl 
                  << "export LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:$HOME/lib\""
                  << endl << endl 
                  << "cd $HOME/installer_work/" << package_name;

   if (!package_version.empty())
         temp_file_strm << "_" << package_version;

   temp_file_strm << endl << endl;

@q ***** (5) @>
@
\LOG
\initials{LDF 2010.05.19.}
Added this section.
\ENDLOG

@<Rules@>=

   temp_file_strm << "for i in *.tar.gz"
                  << endl 
                  << "do"
                  << endl 
                  << "tar xvfz $i >&2"
                  << endl 
                  << "if test $? -ne 0"
                  << endl 
                  << "then"
                  << endl 
                  << "s=\"Failed to unpack $i.  "
                  << "Exiting $SCRIPT_NAME unsuccessfully with exit status 1\""
                  << endl 
                  << "echo \"$s\""
                  << endl 
                  << "echo \"$s\" >&2"
                  << endl 
                  << "exit 1"
                  << endl 
                  << "else"
                  << endl 
                  << "echo \"Unpacked $i successfully\" >&2"
                  << endl 
                  << "fi"
                  << endl 
                  << "done"
                  << endl << endl; 

@q ***** (5) @>

@ The point of this |for| loop in the shellscript is that the name of the 
directory may not be ``\<package name> (underline) \<package version>''.
The loop looks for a subdirectory in the working directory and enters it 
(with \.{cd}).  This way, the precise name of the subdirectory needn't be 
known within the shellscript.  It is most likely that there will only be one directory and 
the shellscript itself in the working directory.  The \.{if test} construction ensures 
that the shellscript will skip over any files that aren't directories (such as the 
shellscript file itself) and won't try to \.{cd} into them.  The loop breaks after 
the first (and probably only) directory is found.  
\initials{LDF 2010.03.29.}

\LOG
\initials{LDF 2010.09.15.}
Added code for deleting \.{\$INSTALL\_DIR} if there's an error. 

\initials{LDF 2011.07.06.}
Now using \.{\$INSTALL\_DIR} as the argument to the \.{--prefix} option 
of \.{configure}.
\ENDLOG 

@<Rules@>=

   temp_file_strm << "for i in *"
                  << endl 
                  << "do"
                  << endl 
                  << "if test -d $i" 
                  << endl 
                  << "then"
                  << endl 
                  << "cd $i"
                  << endl 
                  << "./configure --prefix $INSTALL_DIR >&2"
                  << endl
                  << "if test $? -ne 0"
                  << endl
                  << "then"
                  << endl
                  << "s=\"configure failed.  "
                  << "Exiting $SCRIPT_NAME unsuccessfully with exit status 1\""
                  << endl
                  << "echo \"$s\""
                  << endl 
                  << "echo \"$s\" >&2"
                  << endl 
                  << "rm -rf $INSTALL_DIR"
                  << endl 
                  << "exit 1"
                  << endl
                  << "else"
                  << endl
                  << "echo \"configure succeeded\" >&2"
                  << endl
                  << "fi"
                  << endl
                  << "make >&2" 
                  << endl
                  << "if test $? -ne 0"
                  << endl
                  << "then"
                  << endl
                  << "s=\"make failed.  "
                  << "Exiting $SCRIPT_NAME unsuccessfully with exit status 1\""
                  << endl
                  << "echo \"$s\""
                  << endl 
                  << "echo \"$s\" >&2"
                  << endl 
                  << "rm -rf $INSTALL_DIR"
                  << endl 
                  << "exit 1"
                  << endl
                  << "else"
                  << endl
                  << "echo \"make succeeded\" >&2"
                  << endl
                  << "fi"
                  << endl
                  << "make install >&2"
                  << endl
                  << "if test $? -ne 0"
                  << endl
                  << "then"
                  << endl
                  << "s=\"make install failed.  "
                  << "Exiting $SCRIPT_NAME unsuccessfully with exit status 1\""
                  << endl
                  << "echo \"$s\""
                  << endl 
                  << "echo \"$s\" >&2"
                  << endl 
                  << "rm -rf $INSTALL_DIR"
                  << endl 
                  << "exit 1"
                  << endl
                  << "else"
                  << endl
                  << "echo \"make install succeeded\" >&2"
                  << endl
                  << "fi"
                  << endl
                  << "break"
                  << endl
                  << "fi"
                  << endl
                  << "done"
                  << endl << endl
                  << "s=\"In $SCRIPT_NAME:  Installed $PACKAGE_NAME\""
                  << endl
                  << "if test -n $PACKAGE_VERSION"
                  << endl
                  << "then"
                  << endl
                  << "s=\"$s $PACKAGE_VERSION\""
                  << endl
                  << "fi"
                  << endl
                  << "s=\"$s successfully in $INSTALL_DIR\""
                  << endl
                  << "echo \"$s\""
                  << endl 
#if 0 
/* Commented-out.  This causes the same message to be written to |stderr|.
\initials{LDF 2010.11.17.}  */
                  << "echo \"$s\" >&2"
#endif 
                  << endl 
                  << "cd $INSTALL_DIR"
                  << endl
                  << "s=\"\""
                  << endl
                  << "t=\"\""
                  << endl
                  << "#### The following 'export' commands only have an effect"
                  << endl
                  << "#### if this shellscript is executed using 'source' or equivalently '.'."
                  << endl
                  << "#### However, they are are also written to standard output and can be copied"
                  << endl
                  << "#### and pasted into another shell, if desired."
                  << endl
                  << endl           
                  << "if test -d bin"
                  << endl
                  << "then"
                  << endl
                  << "s=\"bin subdirectory exists\\n\""
                  << endl
                  << "export PATH=$PATH:$HOME/bin"
                  << endl
                  << "t=\"export PATH=\\$PATH:$HOME/bin\\n\""
                  << endl
                  << "else"
                  << endl
                  << "s=\"no bin subdirectory\\n\""
                  << endl
                  << "t=\"\\n\""
                  << endl
                  << "fi"
                  << endl
                  << endl 
                  << endl
                  << "if test -d include"
                  << endl
                  << "then"
                  << endl
                  << "s=\"${s}include subdirectory exists\\n\""
                  << endl
                  << "export CFLAGS=\"$CFLAGS -I$HOME/include\""
                  << endl
                  << "t=\"${t}export CFLAGS=\\\"\\$CFLAGS -I$HOME/include\\\"\\n\""
                  << endl
                  << "export CXXFLAGS=\"$CXXFLAGS -I$HOME/include\""
                  << endl
                  << "t=\"${t}export CXXFLAGS=\\\"\\$CXXFLAGS -I$HOME/include\\\"\\n\""
                  << endl
                  << "else"
                  << endl
                  << "s=\"${s}no include subdirectory\\n\""
                  << endl
                  << "fi"
                  << endl
                  << endl 
                  << endl
                  << "if test -d lib"
                  << endl
                  << "then"
                  << endl
                  << "s=\"${s}lib subdirectory exists\\n\""
                  << endl
                  << "export LDFLAGS=\"$LDFLAGS -L$HOME/lib\""
                  << endl
                  << "t=\"${t}export LDFLAGS=\\\"\\$LDFLAGS -L$HOME/lib\\\"\\n\""
                  << endl
                  << "export LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:$HOME/lib\""
                  << endl
                  << "t=\"${t}export LD_LIBRARY_PATH=\\\"\\$LD_LIBRARY_PATH:$HOME/lib\\\"\\n\""
                  << endl
                  << "if test -f ./lib/lib$PACKAGE_NAME.so -o -f ./lib/lib$PACKAGE_NAME.a"
                  << endl
                  << "then"
                  << endl
                  << "s=\"${s}lib/lib$PACKAGE_NAME.so or lib/lib$PACKAGE_NAME.a exists\\n\""
                  << endl
                  << "t=\"${t}export LIBS=\\\"\\$LIBS -l$PACKAGE_NAME\\\"\\n\""
                  << endl
                  << "export LIBS=\"$LIBS -l$PACKAGE_NAME\""
                  << endl
                  << "else"
                  << endl
                  << "s=\"${s}./lib/lib$PACKAGE_NAME.so or ./lib/lib$PACKAGE_NAME.a "
                  << "doesn't exist\\n\""
                  << endl
                  << "fi"
                  << endl
                  << "else"
                  << endl
                  << "s=\"${s}no lib subdirectory\\n\""
                  << endl
                  << "fi"
                  << endl
                  << endl 
                  << endl
                  << "if test -n \"$s\""
                  << endl
                  << "then"
                  << endl
                  << "echo -e \"$s\""
                  << endl
                  << "#else"
                  << endl
                  << "#echo \"Nothing missing.\""
                  << endl
                  << "fi"
                  << endl
                  << endl 
                  << endl
                  << "if test -n \"$t\""
                  << endl
                  << "then"
                  << endl
                  << "echo -e \"Execute the following commands in a shell "
                  << "to set its environment (if desired):\\n\""
                  << endl
                  << "echo -e \"$t\""
                  << endl
                  << "#else"
                  << endl
                  << "#echo \"Nothing present.\""
                  << endl
                  << "fi"
                  << endl
                  << "exit 0"
                  << endl 
                  << endl;         

   temp_file_strm.close();

   Entry_Type e;
   e.package_name        = package_name;

   if (!package_version.empty())
      e.package_version = package_version;

   e.install_order       = @=$7@>;
   e.installation_script = script_filename;

   param->cond_append(e);

   fetch = true;

   param->entry_string_vector.clear();

@q ***** (5) @>

};

@q **** (4) statement --> SEND_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ STRING_ZZ  @>
@q **** (4) GLOBUS_SITE_ZZ STRING_ZZ admin_optional                        @>

@ \<statement> $\longrightarrow$ 
\.{SEND\_ZZ} \.{ENVIRONMENT\_ZZ} \.{SHELLSCRIPT\_ZZ} \.{STRING\_ZZ} 
\.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} \<admin optional>.
\initials{LDF 2012.03.16.}

\LOG
\initials{LDF 2012.03.16.}
Added this rule.

\initials{LDF 2012.03.22.}
Added \<admin optional>.
\ENDLOG

@<Rules@>=

@=statement: SEND_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ STRING_ZZ @>@/
@=GLOBUS_SITE_ZZ STRING_ZZ admin_optional@>
{
@q ***** (5) @>

   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `SEND_ZZ ENVIRONMENT_ZZ "
            << "SHELLSCRIPT_ZZ STRING_ZZ GLOBUS_SITE_ZZ STRING_ZZ admin_optional'."
            << endl;

@q ***** (5) @>

   param->msg_strm.str("");

   Response_Type response;
   response.type = Response_Type::SEND_ENVIRONMENT_SHELLSCRIPT_TYPE;

   FILE *fp = 0;
   char c = 0;

   fp = fopen(@=$4@>, "r");

   if (fp != 0)
   {
@q ****** (6) @>
       c = fgetc(fp);

       if (c == EOF)
       {
           param->msg_strm << "WARNING!  In `zzparse:  "
                           << "Rule `statement:  `SEND_ZZ ENVIRONMENT_ZZ "
                           << "SHELLSCRIPT_ZZ STRING_ZZ GLOBUS_SITE_ZZ STRING_ZZ admin_optional':"
                           << endl 
                           << "environment shellscript file `" << @=$4@> << "' is empty."
                           << endl 
                           << "Not sending.  Continuing."
                           << endl;

           lock_cerr_mutex(); 
           cerr << param->msg_strm.str();
           unlock_cerr_mutex(); 
 
           log_strm << param->msg_strm.str();
           err_log_strm << param->msg_strm.str();

           ++warnings_occurred;

           fclose(fp);
           fp = 0;

           param->msg_strm.str("");

       }  /* |if (c == EOF)|  */

       response.command = "CLIENT SENDING ENVIRONMENT SHELLSCRIPT GLOBUS_SITE <";
       response.command += @=$6@>;
       response.command += ">";

       if (@=$7@> > 0)
       {
          response.command += " ADMIN";
       }

       response.local_filename = @=$4@>;

       pthread_mutex_lock(&param->response_deque_mutex);
       param->response_deque.push_back(response);
       pthread_mutex_unlock(&param->response_deque_mutex);

       fclose(fp);
       fp = 0;

       if (param->PARSER_DEBUG) 
       {
          response.show("response:");

       }
@q ****** (6) @>

   }  /* |if (fp != 0)|  */

@q ***** (5) @>

   else 
   {
       param->msg_strm << "WARNING!  In `zzparse':"
                       << endl 
                       << "Rule `statement:  `SEND_ZZ ENVIRONMENT_ZZ "
                       << "SHELLSCRIPT_ZZ STRING_ZZ GLOBUS_SITE_ZZ STRING_ZZ "
                       << "admin_optional':"
                       << endl 
                       << "Failed to open "
                       << "environment shellscript file `" << @=$4@> << "'."
                       << endl 
                       << "Continuing. "
                       << endl;

       lock_cerr_mutex(); 
       cerr << param->msg_strm.str();
       unlock_cerr_mutex(); 
 
       log_strm << param->msg_strm.str();
       err_log_strm << param->msg_strm.str();

       ++warnings_occurred;

       param->msg_strm.str("");
 
   }  /* |else|  */ 

   cerr << param->msg_strm.str();
   
   err_log_strm << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   param->msg_strm.str("");

@q ***** (5) @>

};

@q **** (4) admin_optional  @>
@ \<admin optional>.

\LOG
\initials{LDF 2012.03.22.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> admin_optional@>

@q **** (4) admin_optional:  /* Empty  */  @>

@ \<admin optional> $\longrightarrow$ \.{Empty}.
\initials{LDF 2012.03.22.}

\LOG
\initials{LDF 2012.03.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=admin_optional:  /* Empty  */  @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `admin_optional:  /* Empty  */.'"
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 0;

};

@q **** (4) admin_optional:  ADMIN_ZZ  @>

@ \<admin optional> $\longrightarrow$ \.{ADMIN\_ZZ}.
\initials{LDF 2012.03.22.}

\LOG
\initials{LDF 2012.03.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=admin_optional:  ADMIN_ZZ @>
{

    Scan_Parse_Parameter_Type* param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `yyparse':  `admin_optional:  "
             << "ADMIN_ZZ'."
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 1;

};

@q **** (4) statement --> SERVER_ZZ RECEIVE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ @>
@q **** (4) GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ                               @>

@ \<statement> $\longrightarrow$ 
\.{SERVER\_ZZ} \.{RECEIVE\_ZZ} \.{ENVIRONMENT\_ZZ} \.{SHELLSCRIPT\_ZZ}
\.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} \.{FAILED\_ZZ}.
\initials{LDF Date unknown (03.2012).}

\LOG
\initials{LDF Date unknown (03.2012).}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ RECEIVE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ @>@/
@=GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ RECEIVE_ZZ "
            << "ENVIRONMENT_ZZ SHELLSCRIPT_ZZ GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "ERROR!  Server failed to receive and/or store "
                   << "environment shellscript file `" 
                   << @=$6@> << "'.  "
                   << "Continuing." << endl;

   cerr << param->msg_strm.str();
   
   err_log_strm << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   ++errors_occurred;

   param->msg_strm.str("");

};

@q **** (4) statement --> SERVER_ZZ NO_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ @>
@q **** (4) FOUND_ZZ FOR_ZZ GLOBUS_SITE_ZZ STRING_ZZ                     @>

@ \<statement> $\longrightarrow$ 
\.{SERVER\_ZZ} \.{NO\_ZZ} \.{ENVIRONMENT\_ZZ} \.{SHELLSCRIPTS\_ZZ}
\.{FOUND\_ZZ} \.{FOR\_ZZ} \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.03.22.}

\LOG
\initials{LDF 2012.03.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ NO_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ @>@/
@=FOUND_ZZ FOR_ZZ GLOBUS_SITE_ZZ STRING_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ NO_ZZ "
            << "ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ FOUND_ZZ FOR_ZZ GLOBUS_SITE_ZZ STRING_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "No environment shellscripts found for Globus site `" 
                   << @=$8@> << "'.  "
                   << "Continuing." << endl;

   cerr << param->msg_strm.str();
   
   err_log_strm << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   param->msg_strm.str("");

};

@q **** (4) statement --> SERVER_ZZ RECEIVE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ  @>
@q **** (4) GLOBUS_SITE_ZZ STRING_ZZ SUCCEEDED_ZZ                             @>

@ \<statement> $\longrightarrow$ 
\.{SERVER\_ZZ} \.{RECEIVE\_ZZ} \.{ENVIRONMENT\_ZZ} \.{SHELLSCRIPT\_ZZ} 
\.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} \.{SUCCEEDED\_ZZ}.
\initials{LDF Date unknown (03.2012.}

\LOG
\initials{LDF Date unknown (03.2012).}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ RECEIVE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ @>@/
@=GLOBUS_SITE_ZZ STRING_ZZ SUCCEEDED_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`SERVER_ZZ RECEIVE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
            << "GLOBUS_SITE_ZZ STRING_ZZ "
            << "SUCCEEDED_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Server received environment shellscript file for Globus site `"
                   << @=$6@> << "' successfully." << endl;

   cerr << param->msg_strm.str();
   
   log_strm << param->msg_strm.str();

   param->msg_strm.str("");

};

@q **** (4) statement: SERVER_ZZ SENDING_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ @>
@q **** (4)            GLOBUS_SITE_ZZ STRING_ZZ                           @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SENDING\_ZZ} \.{ENVIRONMENT\_ZZ} 
\.{SHELLSCRIPT\_ZZ} \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.03.20.}

\LOG
\initials{LDF 2012.03.20.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SENDING_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ @>@/
@=GLOBUS_SITE_ZZ STRING_ZZ@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
            << "GLOBUS_SITE_ZZ STRING_ZZ'."
            << endl;
 
    if (param->PARSER_DEBUG)
        cerr << "Globus site == " << @=$6@> 
             << endl;

@q ***** (5) @>
@
@<Rules@>=

    Response_Type response;

    response.type    = Response_Type::COMMAND_ONLY_TYPE;

    stringstream temp_strm;

    char temp_filename[] = "/tmp/RRXXXXXX";

    int status;

    int fd = mkstemp(temp_filename);

    if (fd == -1)
    {
        param->msg_strm.str("");

        param->msg_strm << "ERROR!  In `zzparse':  Rule `statement: SERVER_ZZ "
                        << "SENDING_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
                        << "GLOBUS_SITE_ZZ STRING_ZZ':"
                        << endl
                        << "`mkstemp' failed, returning -1:"
                        << endl
                        << strerror(errno)
                        << endl
                        << "Can't store environment shellscript for Globus site `"
                        << @=$6@> << "'."
                        << endl 
                        << "Will try to continue."
                        << endl;   

        lock_cerr_mutex(); 
        cerr << param->msg_strm.str();
        unlock_cerr_mutex(); 

        err_log_strm << param->msg_strm.str();
        log_strm << param->msg_strm.str();

        param->msg_strm.str("");

        temp_strm.str("");

        temp_strm << "RECEIVE ENVIRONMENT SHELLSCRIPT FAILED FOR GLOBUS_SITE <"
                  << @=$6@> << ">";

        response.command = temp_strm.str();
                        
        temp_strm.str("");

        pthread_mutex_unlock(&param->response_deque_mutex);
        param->response_deque.push_front(response);
        pthread_mutex_unlock(&param->response_deque_mutex);

        ++errors_occurred;

        goto END_SERVER_SENDING_ENVIRONMENT_SHELLSCRIPT;

    }  /* |if (fd == -1)|  */

@q ***** (5) @>
@
@<Rules@>=

    else if (param->PARSER_DEBUG)
    {

       cerr << "In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
            << "GLOBUS_SITE_ZZ STRING_ZZ':"
            << endl
            << "Opened temporary file `" << temp_filename << "' successfully."
            << endl;

    }  /* |else if (param->PARSER_DEBUG)|  */

    close(fd);

@q ***** (5) @>
@
@<Rules@>=

    status = accept_data(param, 
                         temp_filename, 
                         -1, 
                         Response_Type::RETURN_ENVIRONMENT_SHELLSCRIPT_TYPE);

   if (status != 0)
   {
       param->msg_strm.str("");

       param->msg_strm << "ERROR!  In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ "
                       << "ENVIRONMENT_ZZ SHELLSCRIPT_ZZ GLOBUS_SITE_ZZ STRING_ZZ':"
                       << endl
                       << "`accept_data' failed, returning " << status
                       << endl
                       << "Can't store environment shellscript for Globus site `"
                       << @=$6@> << "'.  "
                       << "Continuing."
                       << endl;   

       cerr << param->msg_strm.str();
       err_log_strm << param->msg_strm.str();
       log_strm << param->msg_strm.str();

       param->msg_strm.str("");

       temp_strm.str("");

       temp_strm << "RECEIVE ENVIRONMENT SHELLSCRIPT FAILED FOR GLOBUS_SITE <"
                 << @=$6@> << ">";

       response.command = temp_strm.str();
                       
       temp_strm.str("");

       pthread_mutex_unlock(&param->response_deque_mutex);
       param->response_deque.push_front(response);
       pthread_mutex_unlock(&param->response_deque_mutex);

       ++errors_occurred;

   }  /* |if (status != 0)|  */

   else 
   {
 
       if (param->PARSER_DEBUG)
       {

            cerr << "In `zzparse':  Rule `SERVER_ZZ SENDING_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
                 << "GLOBUS_SITE_ZZ STRING_ZZ':"
                 << endl
                 << "`accept_data' succeeded." 
                 << endl;

       }  /* |if (param->PARSER_DEBUG)|  */

       param->environment_shellscript_filename_vector.push_back(temp_filename);
   
       temp_strm.str("");
 
       temp_strm << "RECEIVE ENVIRONMENT SHELLSCRIPT SUCCEEDED FOR GLOBUS_SITE <"
                 << @=$6@> << ">";

       response.command = temp_strm.str();

       temp_strm.str("");

       pthread_mutex_unlock(&param->response_deque_mutex);
       param->response_deque.push_front(response);
       pthread_mutex_unlock(&param->response_deque_mutex);

       param->msg_strm.str("");

       param->msg_strm << "In `zzparse':  Rule `statement: SERVER_ZZ "
                       << "SENDING_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
                       << "GLOBUS_SITE_ZZ STRING_ZZ':"
                       << endl
                       << "Received environment shellscript for Globus site "
                       << "`" << @=$6@> << "' successfully."
                       << endl
                       << "Stored in `" << temp_filename << "'."
                       << endl;   

       lock_cerr_mutex(); 
       cerr << param->msg_strm.str();
       unlock_cerr_mutex(); 

       err_log_strm << param->msg_strm.str();
       log_strm << param->msg_strm.str();

       param->msg_strm.str("");

   }  /* |else|  */ 

@q ***** (5) @>

   END_SERVER_SENDING_ENVIRONMENT_SHELLSCRIPT:

   ;

@q ***** (5) @>

};

@q **** (4) statement --> SERVER_ZZ STORE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ @>
@q **** (4) GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ                             @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{STORE\_ZZ} 
\.{ENVIRONMENT\_ZZ} \.{SHELLSCRIPT\_ZZ} \.{GLOBUS\_SITE\_ZZ} 
\.{STRING\_ZZ} \.{FAILED\_ZZ}.
\initials{LDF 2012.03.22.}

\LOG
\initials{LDF 2012.03.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ STORE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ @>@/
@=GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ STORE_ZZ "
            << "ENVIRONMENT_ZZ SHELLSCRIPT_ZZ GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "ERROR!  Server failed to store environment shellscript "
                   << "file in database.  "
                   << "Continuing." << endl;

   cerr << param->msg_strm.str();
   
   err_log_strm << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   ++errors_occurred;

   param->msg_strm.str("");

};

@q **** (4) statement --> SERVER_ZZ STORE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ @>
@q **** (4) GLOBUS_SITE_ZZ STRING_ZZ SUCCEEDED_ZZ                          @>

@ \<statement> $\longrightarrow$ 
\.{SERVER\_ZZ} \.{STORE\_ZZ} \.{ENVIRONMENT\_ZZ} \.{SHELLSCRIPT\_ZZ} 
\.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} \.{SUCCEEDED\_ZZ}.
\initials{LDF 2012.03.22.}

\LOG
\initials{LDF 2012.03.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ STORE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ @>@/
@=GLOBUS_SITE_ZZ STRING_ZZ SUCCEEDED_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
   {
       cerr << "In `zzparse':  Rule `statement:  "
            << "`SERVER_ZZ STORE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
            << "GLOBUS_SITE_ZZ STRING_ZZ "
            << "SUCCEEDED_ZZ'."
            << endl;

       param->msg_strm.str("");

       param->msg_strm << "Server stored environment shellscript file for Globus site `"
                       << @=$6@> << "' in database successfully." << endl;

       cerr << param->msg_strm.str();
       log_strm << param->msg_strm.str();
       param->msg_strm.str("");

   }

};

@q **** (4) statement --> SERVER_ZZ FETCH_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ @>
@q **** (4) GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ INTEGER_ZZ                   @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{FETCH\_ZZ} 
\.{ENVIRONMENT\_ZZ} \.{SHELLSCRIPTS\_ZZ} \.{GLOBUS\_SITE\_ZZ} 
\.{STRING\_ZZ} \.{FAILED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.03.22.}

\LOG
\initials{LDF 2012.03.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ FETCH_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ @>@/
@=GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ INTEGER_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ FETCH_ZZ "
            << "ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ GLOBUS_SITE_ZZ STRING_ZZ "
            << "FAILED_ZZ INTEGER_ZZ'."
            << endl;

   param->msg_strm.str("");

   if (@=$8@> == 1)
   {
      param->msg_strm << "ERROR!  Environment shellscript "
                      << "for Globus site `" << @=$6@> << "' is NULL or empty."
                      << endl 
                      << "Server not sending.  "
                      << "Continuing." << endl;
   }
   else if (@=$8@> == 2)
   {
      param->msg_strm << "ERROR!  Server-side error:  Server failed to write "
                      << "environment shellscript "
                      << "for Globus site `" << @=$6@> << "' to file."
                      << endl 
                      << "Server not sending.  "
                      << "Continuing." << endl;
   }
   else if (@=$8@> == 3)
   {
      param->msg_strm << "ERROR!  Server-side error:  Globus site is NULL.  "
                      << endl 
                      << "Server can't send environment shellscript.  "
                      << "Continuing." << endl;
   }
   else
   {
      param->msg_strm << "ERROR!  Server failed to fetch environment shellscripts "
                      << "for Globus site `" << @=$6@> << "' from database."
                      << endl 
                     << "Will try to continue." << endl;
   }

   cerr << param->msg_strm.str();
   
   err_log_strm << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   ++errors_occurred;

   param->msg_strm.str("");

};

@q **** (4) entry_string_list:  /* Empty  */  @>

@ \<entry string list>. $\longrightarrow$ \.{EMPTY}. 
\initials{LDF 2010.03.23.}

\LOG
\initials{LDF 2010.03.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=entry_string_list: /* Empty  */  @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " 
             << static_cast<Scan_Parse_Parameter_Type*>(
                   zzget_extra(parameter))->thread_ctr 
             << "] In `zzparse':  `entry_string_list: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->entry_string_vector.clear();

};

@q **** (4) entry_string_list:  entry_string_list STRING_ZZ @>

@ \<entry string list>. $\longrightarrow$ \<entry string list> \.{STRING\_ZZ}. 
\initials{LDF 2010.03.23.}

\LOG
\initials{LDF 2010.03.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=entry_string_list: entry_string_list STRING_ZZ  @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " 
             << static_cast<Scan_Parse_Parameter_Type*>(
                   zzget_extra(parameter))->thread_ctr 
             << "] In `zzparse':  `entry_string_list: entry_string_list STRING_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->entry_string_vector.push_back(@=$2@>);

};

@q **** (4) prerequisite_string_list:  /* Empty  */  @>

@ \<prerequisite string list>. $\longrightarrow$ \.{EMPTY}. 
\initials{LDF 2010.09.10.}

\LOG
\initials{LDF 2010.09.10.}
Added this rule.
\ENDLOG

@<Rules@>=

@=prerequisite_string_list: /* Empty  */  @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " 
             << static_cast<Scan_Parse_Parameter_Type*>(
                   zzget_extra(parameter))->thread_ctr 
             << "] In `zzparse':  `prerequisite_string_list: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->prerequisite_string_vector.clear();

};

@q **** (4) prerequisite_string_list:  prerequisite_string_list STRING_ZZ @>

@ \<prerequisite string list>. $\longrightarrow$ \<prerequisite string list> \.{STRING\_ZZ}. 
\initials{LDF 2010.03.23.}

\LOG
\initials{LDF 2010.03.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=prerequisite_string_list: prerequisite_string_list STRING_ZZ  @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " 
             << static_cast<Scan_Parse_Parameter_Type*>(
                   zzget_extra(parameter))->thread_ctr 
             << "] In `zzparse':  `prerequisite_string_list: prerequisite_string_list STRING_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->prerequisite_string_vector.push_back(@=$2@>);

};

@q **** (4) statement:  SERVER_ZZ PARSE_ZZ ERROR_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{PARSE\_ZZ} \.{ERROR\_ZZ}.
\initials{LDF 2010.04.16.}

\LOG
\initials{LDF 2010.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  SERVER_ZZ PARSE_ZZ ERROR_ZZ @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " 
             << static_cast<Scan_Parse_Parameter_Type*>(
                   zzget_extra(parameter))->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ PARSE_ZZ ERROR_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->msg_strm.str("");

    param->msg_strm << "ERROR!  In `zzparse':  "
                    << "Rule `statement:  SERVER_ZZ PARSE_ZZ ERROR_ZZ':"
                    << endl
                    << "Server-side parse error.  Exiting `zzparse' unsuccessfully "
                    << "With return value 1."
                    << endl;

    cerr << param->msg_strm.str();
    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    ++errors_occurred;

    param->msg_strm.str("");

    return 1;

};

@q **** (4) statement:  SERVER_ZZ SHOW_ZZ ENTRIES_ZZ FAILED_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SHOW\_ZZ} 
\.{ENTRIES\_ZZ} \.{FAILED\_ZZ}.
\initials{LDF 2010.05.21.}

\LOG
\initials{LDF 2010.05.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SHOW_ZZ ENTRIES_ZZ FAILED_ZZ @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ SHOW_ZZ ENTRIES_ZZ FAILED_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->msg_strm.str("");

    param->msg_strm << "ERROR!  In `zzparse':  "
                    << "Rule `statement:  SERVER_ZZ SHOW_ZZ ENTRIES_ZZ FAILED_ZZ':  "
                    << "Can't show entries.  Continuing."
                    << endl;

    cerr << param->msg_strm.str();
    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    ++errors_occurred;

    param->msg_strm.str("");

};

@q **** (4) certificate_or_certificates @>

@ \<certificate or certificates>.
\initials{LDF 2012.05.09.}

\LOG
\initials{LDF 2012.05.09.}
Added this type declaration.
\ENDLOG

@<Type declarations for non-terminal symbols@>=
@=%type <int_value> certificate_or_certificates@>@/

@q ***** (5) certificate_or_certificates: CERTIFICATE_ZZ @>
@ \<certificate or certificates> $\longrightarrow$ \.{CERTIFICATE ZZ}.
\initials{LDF 2012.05.09.}

\LOG
\initials{LDF 2012.05.09.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_or_certificates: CERTIFICATE_ZZ@>
{
    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `certificate_or_certificates: CERTIFICATE_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 1;

};

@q ***** (5) certificate_or_certificates: CERTIFICATES_ZZ @>
@ \<certificate or certificates> $\longrightarrow$ \.{CERTIFICATES\_ZZ}.
\initials{LDF 2012.05.09.}

\LOG
\initials{LDF 2012.05.09.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_or_certificates: CERTIFICATES_ZZ@>
{
    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `certificate_or_certificates: CERTIFICATES_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    @=$$@> = 2;

};

@q **** (4) statement:  SERVER_ZZ SHOW_ZZ certificate_or_certificates FAILED_ZZ INTEGER_ZZ@>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SHOW\_ZZ} 
\<certificate or certificates> \.{FAILED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2010.10.27.}

\LOG
\initials{LDF 2010.10.27.}
Added this rule.

\initials{LDF 2012.05.09.}
Changed \.{CERTIFICATE\_ZZ} to \<certificate or certificates> and added 
\.{INTEGER\_ZZ} for error code.  Removed the corresponding rule with 
\.{CERTIFICATES\_ZZ}.  Removed rules for specific errors;  now using 
the error code stored in \.{INTEGER\_ZZ} instead.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SHOW_ZZ certificate_or_certificates FAILED_ZZ INTEGER_ZZ@>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ SHOW_ZZ "
             << "certificate_or_certificates FAILED_ZZ INTEGER_ZZ'." 
             << endl 
             << "`INTEGER_ZZ' (error code) == " << @=$5@>
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    string cert_str = "certificate";

    if (@=$3@> > 1)
        cert_str += "s";

    param->msg_strm.str("");

    string error_or_warning;
    stringstream temp_strm;

    if (@=$5@> == 0)
    {
        error_or_warning = "ERROR!  ";
        ++errors_occurred;
        temp_strm << "No " << cert_str << " to show.  This should never occur!";
    }
    else if (@=$5@> == 1)
    {
        error_or_warning = "ERROR!  ";
        ++errors_occurred;
        temp_strm << "Server-side MySQL error.  Can't show " << cert_str << ".";
    }
    else if (@=$5@> == 2)
    {
        error_or_warning = "WARNING!  ";
        ++warnings_occurred;
        temp_strm << "User not permitted to view other users' certificates.";
    }

@ Other error codes are not relevant for users on the client-side.  
See the table before the definition of |Scan_Parse_Parameter_Type::show_certificates|
in \filename{scprpmtp.web} for a complete list of the error codes.
\initials{LDF 2012.05.09.}

@<Rules@>=

    else  
    {
        error_or_warning = "ERROR!  ";
        ++errors_occurred;
        temp_strm << "Unspecified server-side error.  Can't show " << cert_str << ".";
    }

@
@<Rules@>=

    param->msg_strm << error_or_warning << "In `zzparse':  "
                    << "Rule `statement:  SERVER_ZZ SHOW_ZZ certificate_or_certificates "
                    << "FAILED_ZZ INTEGER_ZZ':"
                    << endl
                    << temp_strm.str()
                    << endl 
                    << "Continuing."
                    << endl;

    cerr << param->msg_strm.str();
    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

};

@q **** (4) statement:  SERVER_ZZ SENDING_ZZ ENTRY_ZZ INFO_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SENDING\_ZZ} \.{ENTRY\_ZZ} 
\.{INFO\_ZZ}
\initials{LDF 2010.05.21.}

\LOG
\initials{LDF 2010.05.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SENDING_ZZ ENTRY_ZZ INFO_ZZ @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ SENDING_ZZ ENTRY_ZZ INFO_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    Response_Type response;
    response.type    = Response_Type::COMMAND_ONLY_TYPE;
 
    int status = accept_data(param, 
                             0,
                             -1, 
                             Response_Type::SHOW_ENTRIES_TYPE);

    if (status != 0)
    {
        param->msg_strm.str("");

        param->msg_strm << "ERROR!  In `zzparse':  "
                        << "Rule `statement:  SERVER_ZZ SENDING_ZZ ENTRY_ZZ INFO_ZZ':"
                        << endl
                        << "`accept_data' failed, returning " << status
                        << "Continuing."
                        << endl;   

        lock_cerr_mutex();
        cerr << param->msg_strm.str();
        unlock_cerr_mutex(); 

        err_log_strm << param->msg_strm.str();
        log_strm << param->msg_strm.str();

        param->msg_strm.str("");

        ++errors_occurred;

        response.command = "CLIENT RECEIVE ENTRY INFO FAILED";

    }  /* |if (status != 0)|  */

    else 
    {

        response.command = "CLIENT RECEIVE ENTRY INFO SUCCEEDED";

        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex();
            cerr << "In `zzparse':  "
                 << "Rule `statement:  SERVER_ZZ SENDING_ZZ ENTRY_ZZ INFO_ZZ':"
                 << endl
                 << "`accept_data' succeeded." 
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */

    }  /* |else|  */      

    pthread_mutex_unlock(&param->response_deque_mutex);
    param->response_deque.push_front(response);
    pthread_mutex_unlock(&param->response_deque_mutex);
 
};

@q **** (4) statement:  SERVER_ZZ NO_ZZ ENTRIES_ZZ FOUND_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{NO\_ZZ} \.{ENTRIES\_ZZ} 
\.{FOUND\_ZZ}
\initials{LDF 2010.05.21.}

\LOG
\initials{LDF 2010.05.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ NO_ZZ ENTRIES_ZZ FOUND_ZZ @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ NO_ZZ ENTRIES_ZZ FOUND_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->msg_strm.str("");

    param->msg_strm << "*** No Entries Found ***" << endl;

    cout << param->msg_strm.str();

    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

};

@q **** (4) statement --> SET_ZZ EFFECTIVE_USER_ZZ SUCCEEDED_ZZ @>

@ \<statement> $\longrightarrow$ \.{SET\_ZZ} \.{EFFECTIVE\_USER\_ZZ} 
\.{SUCCEEDED\_ZZ}.
\initials{LDF 2012.05.23.}

\LOG
\initials{LDF 2012.05.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SET_ZZ EFFECTIVE_USER_ZZ SUCCEEDED_ZZ @>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
   
         cerr << "In `zzparse':  Rule `statement: statement --> "
              << "SET_ZZ EFFECTIVE_USER_ZZ SUCCEEDED_ZZ'."
              << endl;

     param->msg_strm << "Set effective user succeeded." 
                     << endl;
  
     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();

     param->entry_string_vector.clear();

     param->msg_strm.str("");

};

@q **** (4) statement --> SET_ZZ EFFECTIVE_USER_ZZ FAILED_ZZ @>

@ \<statement> $\longrightarrow$ \.{SET\_ZZ} \.{EFFECTIVE\_USER\_ZZ} 
\.{FAILED\_ZZ}.
\initials{LDF 2010.06.30.}

\LOG
\initials{LDF 2010.06.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SET_ZZ EFFECTIVE_USER_ZZ FAILED_ZZ @>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
   
         cerr << "In `zzparse':  Rule `statement: statement --> "
              << "SET_ZZ EFFECTIVE_USER_ZZ FAILED_ZZ'."
              << endl;

     param->msg_strm << "ERROR:  In `zzparse':" << endl 
                     << "Set effective user failed." 
                     << endl
                     << "Exiting `zzparse' unsuccessfully With return value 1."
                     << endl;
  
     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     param->entry_string_vector.clear();

     param->msg_strm.str("");

     ++errors_occurred;

     return 1;

};

@q **** (4) statement:  SERVER_ZZ ENTRY_ZZ entry_string_list NOT_FOUND_ZZ @>
@q          NOT_ZZ ADDING_ZZ INSTALLATION_SCRIPT_ZZ STRING_ZZ             @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{ENTRY\_ZZ} \.{NOT\_FOUND\_ZZ} 
\.{NOT\_ZZ} \.{ADDING\_ZZ} \.{INSTALLATION\_SCRIPT\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2010.10.01.}

\LOG
\initials{LDF 2010.10.01.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ ENTRY_ZZ entry_string_list NOT_FOUND_ZZ @>@/
@=NOT_ZZ ADDING_ZZ INSTALLATION_SCRIPT_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ ENTRY_ZZ "
             << "entry_string_list NOT_FOUND_ZZ NOT_ZZ ADDING_ZZ "
             << "INSTALLATION_SCRIPT_ZZ STRING_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->msg_strm << "ERROR:  In `zzparse':  Entry `" << param->entry_string_vector[0];

    if (param->entry_string_vector.size() > 1)
       param->msg_strm << " " << param->entry_string_vector[1];

    param->msg_strm << "' not found.  Not adding installation script `"
                    << @=$8@> << "'."
                    << endl
                    << "Continuing."
                    << endl;
  
    cerr << param->msg_strm.str();
    log_strm << param->msg_strm.str();
    err_log_strm << param->msg_strm.str();

    param->entry_string_vector.clear();

    param->msg_strm.str("");

    ++errors_occurred;

};

@q **** (4) statement:  SERVER_ZZ ENTRY_ZZ entry_string_list NOT_FOUND_ZZ @>
@q          NOT_ZZ ADDING_ZZ download_info STRING_ZZ                      @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{ENTRY\_ZZ} \.{NOT\_FOUND\_ZZ} 
\.{NOT\_ZZ} \.{ADDING\_ZZ} \<download info> \.{STRING\_ZZ}.
\initials{LDF 2011.06.08.}

\LOG
\initials{LDF 2011.06.08.}
Added this rule.

\initials{LDF 2011.10.31.}
Changed \<download info encrypted> to \<download info>.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ ENTRY_ZZ entry_string_list NOT_FOUND_ZZ @>@/
@=NOT_ZZ ADDING_ZZ download_info STRING_ZZ@>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ ENTRY_ZZ "
             << "entry_string_list NOT_FOUND_ZZ NOT_ZZ ADDING_ZZ "
             << "download_info STRING_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->msg_strm << "ERROR:  In `zzparse':  Entry `" << param->entry_string_vector[0];

    if (param->entry_string_vector.size() > 1)
       param->msg_strm << " " << param->entry_string_vector[1];

    param->msg_strm << "' not found.  Not adding ";
    
    if (@=$7@> == Response_Type::DOWNLOAD_URL_TYPE)
       param->msg_strm << "download URL (unencrypted) ";

    else if (@=$7@> == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE)
       param->msg_strm << "encrypted download URL ";

    else if (@=$7@> == Response_Type::DOWNLOAD_COMMAND_TYPE)
       param->msg_strm << "download command (unencrypted) ";

    else if (@=$7@> == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE)
       param->msg_strm << "encrypted download command ";

    param->msg_strm << "`" << @=$8@> << "'."
                    << endl
                    << "Continuing."
                    << endl;
  
    cerr << param->msg_strm.str();
    log_strm << param->msg_strm.str();
    err_log_strm << param->msg_strm.str();

    param->entry_string_vector.clear();

    param->msg_strm.str("");

    ++errors_occurred;

};

@q **** (4) statement:  SERVER_ZZ SENDING_ZZ CERTIFICATE_ZZ INFO_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SENDING\_ZZ} \.{CERTIFICATE\_ZZ} 
\.{INFO\_ZZ}
\initials{LDF 2010.10.27.}

\LOG
\initials{LDF 2010.10.27.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SENDING_ZZ CERTIFICATE_ZZ INFO_ZZ @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ SENDING_ZZ CERTIFICATE_ZZ INFO_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    int status = accept_data(param, 
                             0,
                             -1, 
                             Response_Type::SHOW_CERTIFICATES_TYPE);

};

@q **** (4) download_info and download_info_encrypted.  @>

@ \<download info> and \<download info encrypted>.
\initials{LDF 2011.04.21.}

\LOG
\initials{LDF 2011.04.21.}
Added this section.

\initials{LDF 2011.10.31.}
Added type declaration for \<download info>.
\ENDLOG

@<Type declarations for non-terminal symbols@>=

@=%type <int_value> download_info@>@/@/
@=%type <int_value> download_info_encrypted@>@/

@q **** (4) download_info: DOWNLOAD_URL_ZZ.  @>

@ \<download info encrypted> $\longrightarrow$ \.{DOWNLOAD\_URL\_ZZ}.
\initials{LDF 2011.10.31.}

\LOG
\initials{LDF 2011.10.31.}
Added this section.
\ENDLOG

@<Rules@>=
@=download_info: DOWNLOAD_URL_ZZ@>
{

   @=$$@> = Response_Type::DOWNLOAD_URL_TYPE;

};

@q **** (4) download_info: DOWNLOAD_COMMAND_ZZ.  @>

@ \<download info encrypted> $\longrightarrow$ \.{DOWNLOAD\_COMMAND\_ZZ}.
\initials{LDF 2011.10.31.}

\LOG
\initials{LDF 2011.10.31.}
Added this section.
\ENDLOG

@<Rules@>=
@=download_info: DOWNLOAD_COMMAND_ZZ@>
{

   @=$$@> = Response_Type::DOWNLOAD_COMMAND_TYPE;

};

@q **** (4) download_info: download_info_encrypted.  @>

@ \<download info encrypted> $\longrightarrow$ \<download info encrypted>.
\initials{LDF 2011.10.31.}

\LOG
\initials{LDF 2011.10.31.}
Added this section.
\ENDLOG

@<Rules@>=
@=download_info: download_info_encrypted@>
{

   @=$$@> = @=$1@>;

};

@q **** (4) @>
@
\LOG
\initials{LDF 2011.04.21.}
Added this section.

\initials{LDF 2011.10.31.}
Now setting |@=$$$@>| to |Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE|.
\ENDLOG

@<Rules@>=
@=download_info_encrypted: DOWNLOAD_URL_ENCRYPTED_ZZ@>
{
     
   @=$$@> = Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE;

};

@q **** (4) @>
@
\LOG
\initials{LDF 2011.04.21.}
Added this section.

\initials{LDF 2011.10.31.}
Now setting |@=$$$@>| to |Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE|.
\ENDLOG

@<Rules@>=
@=download_info_encrypted: DOWNLOAD_COMMAND_ENCRYPTED_ZZ@>
{

   @=$$@> = Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE;

};

@q **** (4) statement --> SEND_ZZ PROXY_CREDENTIAL_ZZ @>

@ \<statement> $\longrightarrow$ \.{SEND\_ZZ} \.{PROXY\_CERTIFICATE\_ZZ}.
\initials{LDF 2011.09.26.}

\LOG
\initials{LDF 2011.09.26.}
Added this rule.

\initials{LDF 2011.10.27.}
Added code for testing validity of proxy credential.
\ENDLOG

@<Rules@>=

@=statement: SEND_ZZ PROXY_CREDENTIAL_ZZ @>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `SEND_ZZ PROXY_CREDENTIAL_ZZ'."
             << endl;

    stringstream temp_strm;

    Response_Type response;

    int status = handle_proxy_cred(transfer_proxy_cred_filename);

    if (status != 0)
    {

        param->msg_strm.str("");

        param->msg_strm << "ERROR!  In `zzparse':  In rule `statement: "
                        << "SEND_ZZ PROXY_CREDENTIAL_ZZ':"
                        << endl
                        << "`handle_proxy_cred' failed, returning " << status << "."
                        << endl
                        << "proxy credential `" << transfer_proxy_cred_filename << "' "
                        << "is invalid.  Not sending to server `optdbsrv'."
                        << endl
                        << "Will try to continue."
                        << endl;  

        err_log_strm << param->msg_strm.str();
        log_strm << param->msg_strm.str();

        lock_cerr_mutex(); 
        cerr << param->msg_strm.str();
        unlock_cerr_mutex(); 

        param->msg_strm.str("");

        temp_strm << "PROXY_CREDENTIAL <" << transfer_proxy_cred_filename 
                  << "> INVALID CLIENT NOT TO TRANSFER";

        if (param->PARSER_DEBUG) 
        {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

        }

        response.type = Response_Type::COMMAND_ONLY_TYPE;
        response.command = temp_strm.str();

    }
    else
    {

       if (param->PARSER_DEBUG)
       {
          lock_cerr_mutex(); 
          cerr << "In `zzparse':  In rule `statement: "
               << "SEND_ZZ PROXY_CREDENTIAL_ZZ':"
               << endl
               << "`handle_proxy_cred' succeeded."
               << endl;
          unlock_cerr_mutex(); 
 
       }  /* |if (param->PARSER_DEBUG)|  */

       temp_strm << "CLIENT SENDING PROXY_CREDENTIAL";
                 
       if (param->PARSER_DEBUG) 
       {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

       }

       response.type = Response_Type::PROXY_CREDENTIAL_TYPE;
       response.command = temp_strm.str();
       response.local_filename  = transfer_proxy_cred_filename;

    }  /* |else| (|handle_proxy_cred| succeeded.)  */

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

};

@q **** (4) statement --> SEND_ZZ PROXY_CREDENTIAL_ZZ STRING_ZZ @>

@ \<statement> $\longrightarrow$ \.{SEND\_ZZ} \.{PROXY\_CERTIFICATE\_ZZ}
\.{STRING\_ZZ}.

\initials{LDF 2011.09.29.}

\LOG
\initials{LDF 2011.09.29.}
Added this rule.

\initials{LDF 2011.10.27.}
Added code for testing validity of proxy credential.
\ENDLOG

@<Rules@>=

@=statement: SEND_ZZ PROXY_CREDENTIAL_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `SEND_ZZ PROXY_CREDENTIAL_ZZ STRING_ZZ'."
             << endl;

    Response_Type response;
    stringstream temp_strm;

    int status = handle_proxy_cred(string(@=$3@>));

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "ERROR!  In `zzparse':  In rule `statement: "
             << "SEND_ZZ PROXY_CREDENTIAL_ZZ STRING_ZZ':"
             << endl
             << "`handle_proxy_cred' failed, returning " << status << "."
             << endl
             << "proxy credential `" << @=$3@> << "' "
             << "is invalid.  Not sending to server `optdbsrv'."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        temp_strm << "PROXY_CREDENTIAL <" << @=$3@>
                  << "> INVALID CLIENT NOT TO TRANSFER";

        if (param->PARSER_DEBUG) 
        {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

        }

        response.type = Response_Type::COMMAND_ONLY_TYPE;
        response.command = temp_strm.str();

    }
    else
    {

       if (param->PARSER_DEBUG)
       {
          lock_cerr_mutex(); 
          cerr << "In `zzparse':  In rule `statement: "
               << "SEND_ZZ PROXY_CREDENTIAL_ZZ  STRING_ZZ':"
               << endl
               << "`handle_proxy_cred' succeeded."
               << endl;
          unlock_cerr_mutex(); 
 
       }  /* |if (param->PARSER_DEBUG)|  */

       temp_strm << "CLIENT SENDING PROXY_CREDENTIAL";
                 
       if (param->PARSER_DEBUG) 
       {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

       }

       response.type = Response_Type::PROXY_CREDENTIAL_TYPE;
       response.command = temp_strm.str();
       response.local_filename  = @=$3@>;

    }  /* |else| (|handle_proxy_cred| succeeded.)  */

    pthread_mutex_lock(&param->response_deque_mutex);
    param->response_deque.push_back(response);
    pthread_mutex_unlock(&param->response_deque_mutex);

};

@q **** (4) statement --> RECEIVE_ZZ PROXY_CREDENTIAL_ZZ SUCCEEDED_ZZ STRING_ZZ @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_ZZ} \.{PROXY\_CERTIFICATE\_ZZ}
\.{SUCCEEDED\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2011.09.26.}

\LOG
\initials{LDF 2011.09.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: RECEIVE_ZZ PROXY_CREDENTIAL_ZZ SUCCEEDED_ZZ STRING_ZZ@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
        cerr << "In `zzparse':  Rule `statement: statement --> "
             << "RECEIVE_ZZ PROXY_CREDENTIAL_ZZ SUCCEEDED_ZZ STRING_ZZ'."
             << endl;

     cerr << "Receive proxy credential succeeded." << endl
          << "Proxy filename == " << @=$4@> << endl;

     log_strm << "Receive proxy credential succeeded." << endl
              << "Proxy filename == " << @=$4@> << endl;

};

@q **** (4) statement --> RECEIVE_ZZ PROXY_CREDENTIAL_ZZ FAILED_ZZ @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_ZZ} \.{PROXY\_CERTIFICATE\_ZZ}
\.{FAILED\_ZZ}.
\initials{LDF 2011.09.26.}

\LOG
\initials{LDF 2011.09.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: RECEIVE_ZZ PROXY_CREDENTIAL_ZZ FAILED_ZZ @>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
   
         cerr << "In `zzparse':  Rule `statement: statement --> "
              << "RECEIVE_ZZ PROXY_CREDENTIAL_ZZ FAILED_ZZ'."
              << endl;

     param->msg_strm << "Error:  Receive proxy credential failed" << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     param->entry_string_vector.clear();

     param->msg_strm.str("");

     ++errors_occurred;

};

@q **** (4) statement --> SEND_ZZ KEY_PAIR_ZZ @>

@ \<statement> $\longrightarrow$ \.{SEND\_ZZ} \.{KEY\_PAIR\_ZZ}.
\initials{LDF 2011.11.03.}

\LOG
\initials{LDF 2011.11.03.}
Added this rule.

\initials{LDF 2011.11.16.}
Added code for sending public key along with private key.
\ENDLOG

@<Rules@>=

@=statement: SEND_ZZ KEY_PAIR_ZZ @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    int status;
    int fd[3];
    Response_Type response;
    stringstream system_strm;
    stringstream temp_strm;
    char temp_filename[]   = "/tmp/HHXXXXXX";
    char temp_filename_1[] = "/tmp/NNXXXXXX";
    char temp_filename_2[] = "/tmp/PPXXXXXX";

    FILE *fp = 0;

    string curr_filename;
    string curr_dn;

    bool proxy_or_normal = false;

@q ***** (5) @>
@
@<Rules@>=

    pthread_mutex_lock(&global_variable_mutex);
    if (optinum_installer_gpg_pubkey_fingerprint.empty())
    {

        status = param->get_optinum_installer_gpg_pubkey_fingerprint();

@q ****** (6) @>

        if (status != 0)
        {
           param->msg_strm << "ERROR!  In `zzparse':  Rule `SEND_ZZ KEY_PAIR_ZZ':"
                           << endl
                           << "`Scan_Parse_Parameter_Type::"
                           << "get_optinum_installer_gpg_pubkey_fingerprint' "
                           << "failed, returning " << status << "."
                           << endl
                           << "Sending error message to `optdbsrv' and continuing."
                           << endl;   

           lock_cerr_mutex(); 
           cerr << param->msg_strm.str();
           unlock_cerr_mutex(); 

           log_strm << param->msg_strm.str();
           err_log_strm << param->msg_strm.str();

           param->msg_strm.str("");

           response.type = Response_Type::COMMAND_ONLY_TYPE;
           temp_strm << "CLIENT ERROR NOT SENDING KEY_PAIR";
           response.command = temp_strm.str();

           ++errors_occurred;

           pthread_mutex_unlock(&global_variable_mutex);

           goto END_SEND_KEY_PAIR;

        } /* |if (status != 0)| */

@q ****** (6) @>

        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "In `zzparse':  Rule `SEND_ZZ KEY_PAIR_ZZ':"
                 << endl
                 << "`Scan_Parse_Parameter_Type::"
                 << "get_optinum_installer_gpg_pubkey_fingerprint' "
                 << "succeeded." << endl
                 << "`optinum_installer_gpg_pubkey_fingerprint' == " 
                 << optinum_installer_gpg_pubkey_fingerprint
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */ 

@q ****** (6) @>

    }  /* |if (optinum_installer_gpg_pubkey_fingerprint.empty())|  */

    pthread_mutex_unlock(&global_variable_mutex);
  
@q ***** (5) @>
@
@<Rules@>=

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "In `zzparse':  Rule `SEND_ZZ KEY_PAIR_ZZ'."
             << endl;
        unlock_cerr_mutex(); 
    }

@q ***** (5) @>

    if (cert_filenames.size() > 0)
       curr_filename = cert_filenames.back();
    else if (!proxy_cred_filename.empty())
    {
        curr_filename = proxy_cred_filename;
        proxy_or_normal = true;
    }
    else 
        curr_filename = DEFAULT_CERT_FILENAME;

@q ***** (5) @>
@
@<Rules@>=

    param->msg_strm.str("");

    status = extract_distinguished_name(curr_filename, curr_dn, proxy_or_normal);

    if (status != 0)
    {

        param->msg_strm << "ERROR!  In `zzparse':  Rule `SEND_ZZ KEY_PAIR_ZZ':"
                        << endl
                        << "`extract_distinguished_name' failed, returning " << status << "."
                        << endl
                        << "Sending error message to `optdbsrv' and continuing."
                        << endl;   

        lock_cerr_mutex(); 
        cerr << param->msg_strm.str();
        unlock_cerr_mutex(); 

        log_strm << param->msg_strm.str();
        err_log_strm << param->msg_strm.str();

        param->msg_strm.str("");

        response.type = Response_Type::COMMAND_ONLY_TYPE;
        temp_strm << "CLIENT ERROR NOT SENDING KEY_PAIR";
        response.command = temp_strm.str();

        ++errors_occurred;

        goto END_SEND_KEY_PAIR;

    }  /* |if (status != 0)|  */

@q ***** (5) @>

    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "In `zzparse':  Rule `SEND_ZZ KEY_PAIR_ZZ':"
             << endl
             << "`extract_distinguished_name' succeeded."
             << endl
             << "`curr_dn' == " << curr_dn << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (param->PARSER_DEBUG)|  */ 

@q ***** (5) Set |param->effective_user_dn| or |param->user_dn|.  @>

@ Set |param->effective_user_dn| or |param->user_dn|.  
\initials{LDF 2011.12.12.}

\LOG
\initials{LDF 2011.12.12.}
Added this section.
\ENDLOG

@<Rules@>=
  
    if (param->effective_user_id > 0)
       param->effective_user_dn = curr_dn;    
    else
       param->user_dn = curr_dn;

@q ***** (5) Create temporary file for 1. exported and encrypted key pair,  @>
@q ***** (5) 2. fingerprint and 3. (unencrypted) public key.                @>

@ Create temporary file for 1. exported and encrypted key pair, 
2. fingerprint and 3. (unencrypted) public key.
\initials{LDF 2011.11.04.}
\initials{LDF 2011.12.12.}

\LOG
\initials{LDF 2011.11.04.}
Added this section.
\ENDLOG

@<Rules@>=

@q ***** (5) Create temporary file.  @>
@ Create temporary file.

@<Rules@>=

     fd[0] = mkstemp(temp_filename);
     fd[1] = mkstemp(temp_filename_1);
     fd[2] = mkstemp(temp_filename_2);
    
     if (fd[0] == -1 || fd[1] == -1 || fd[2] == -1)
     {
          param->msg_strm << "ERROR!  In `zzparse':  Rule `SEND_ZZ KEY_PAIR_ZZ':"
                          << endl
                          << "`mkstemp' failed, returning -1:"
                          << endl << strerror(errno) << endl
                          << "Sending error message to `optdbsrv' and will try to continue."
                          << endl;      

          lock_cerr_mutex(); 
          cerr << param->msg_strm.str();
          unlock_cerr_mutex(); 

          log_strm << param->msg_strm.str();
          err_log_strm << param->msg_strm.str();

          param->msg_strm.str("");

          response.type = Response_Type::COMMAND_ONLY_TYPE;
          temp_strm << "CLIENT ERROR NOT SENDING KEY_PAIR";
          response.command = temp_strm.str();

          ++errors_occurred;

          close(fd[0]);
          close(fd[1]);
          close(fd[2]);

          goto END_SEND_KEY_PAIR;

     } /* |if|  */  

     else if (param->PARSER_DEBUG)
     {

         lock_cerr_mutex(); 
         cerr << "In `zzparse':  Rule `SEND_ZZ KEY_PAIR_ZZ':"
             << endl;
         unlock_cerr_mutex(); 
 
     }  /* |else if (param->PARSER_DEBUG)|  */ 

     close(fd[0]);
     close(fd[1]);
     close(fd[2]);

@q ***** (5) @>

@ @:TODO@> !! TODO: @:NOTE@> !! PLEASE NOTE: 
At the latest, at this point, the public key 
referred to by |optinum_installer_gpg_pubkey_fingerprint| must be signed.
It should be signed by the key we're about to send to the server.
It would be best to do this when this key pair is generated.
\initials{LDF 2011.11.17.}

@<Rules@>=

    system_strm.str("");

    system_strm << "gpg --list-secret-keys \"" << curr_dn << "\" >/dev/null 2>/dev/null && "
                << "gpg --list-public-keys \"" << curr_dn << "\" >/dev/null 2>/dev/null && "
                << "gpg --export-secret-keys --armor \"" << curr_dn 
                << "\" >| " << temp_filename << " 2>/dev/null "
                << "&& echo -e \"\\n\" >> " << temp_filename << " "
                << "&& gpg --export --armor \"" << curr_dn 
                << "\" >> " << temp_filename << " 2>/dev/null "
                << "&& cat " << temp_filename << " | gpg --batch --yes "
                << "--armor --encrypt -r " << optinum_installer_gpg_pubkey_fingerprint << " >| "
                << temp_filename_1 << " 2>/dev/null && "
                << "gpg --export -a '" << curr_dn << "' >| " 
                << temp_filename_2;

    if (param->PARSER_DEBUG)
    {
       lock_cerr_mutex(); 
       cerr << "system_strm.str() == " << system_strm.str() << endl;
       unlock_cerr_mutex(); 
   
    }  /* |if (param->PARSER_DEBUG)|  */ 

    status  = system(system_strm.str().c_str());

    if (param->PARSER_DEBUG) 
    {
        lock_cerr_mutex(); 
        cerr << "status == " << status << endl;
        unlock_cerr_mutex(); 
    }
                         
    if (status == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)
    {  
  
          param->msg_strm << "ERROR!  In `zzparse':  Rule `SEND_ZZ KEY_PAIR_ZZ':"
                          << endl
                          << "`system' failed";

         if (WIFEXITED(status))
             param->msg_strm << ", returning " << WEXITSTATUS(status);

          param->msg_strm << "."
                          << endl
                          << "Failed to export key pair for Distinguished Name "
                          << "\"" << curr_dn << "\"."
                          << endl 
                          << "Sending error message to `optdbsrv' and will try to continue."
                          << endl;      

          lock_cerr_mutex(); 
          cerr << param->msg_strm.str();
          unlock_cerr_mutex(); 

          log_strm << param->msg_strm.str();
          err_log_strm << param->msg_strm.str();

          param->msg_strm.str("");

          response.type = Response_Type::COMMAND_ONLY_TYPE;
          temp_strm << "CLIENT ERROR NOT SENDING KEY_PAIR";
          response.command = temp_strm.str();

          ++errors_occurred;

          goto END_SEND_KEY_PAIR;

    } /* |if (status == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)|  */

    else if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "In `zzparse':  Rule `SEND_ZZ KEY_PAIR_ZZ':"
            << endl
            << "`system' succeeded."
            << endl
            << "Exported key pair, fingerprint and public key "
            << "for Distinguished Name "
            << "\"" << curr_dn << "\" successfully."
            << endl;
        unlock_cerr_mutex(); 
 
    }  /* |else if (param->PARSER_DEBUG)|  */ 

@q ***** (5) Get key id.  @>

@ Get key id.  
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this section.
\ENDLOG

@<Rules@>=

    system_strm.str("");
    system_strm << "printf \"%d\\n\" "
                << "`(printf \"0x\" &&  gpg --fingerprint '"
                << curr_dn << "' | grep \"fingerprint\" | "
                << "cut -f2 -d \"=\" | tr -s \" \" | cut -b2- | cut -f9- -d \" \" | "
                << "tr -d \" \")`";

    if (param->PARSER_DEBUG)
    {
        cerr << "system_strm.str() == " << system_strm.str() << endl;

    }  /* |if (param->PARSER_DEBUG)|  */ 

    fp = popen(system_strm.str().c_str(), "r");

    if (fp == 0)
    {
          param->msg_strm << "ERROR!  In `zzparse':  Rule `SEND_ZZ KEY_PAIR_ZZ':"
                          << endl
                          << "`popen' failed, returning NULL."
                          << endl
                          << "Failed to get key id for Distinguished Name "
                          << "\"" << curr_dn << "\"."
                          << endl 
                          << "Sending error message to `optdbsrv' and will try to continue."
                          << endl;      

          lock_cerr_mutex(); 
          cerr << param->msg_strm.str();
          unlock_cerr_mutex(); 

          log_strm << param->msg_strm.str();
          err_log_strm << param->msg_strm.str();

          param->msg_strm.str("");

          response.type = Response_Type::COMMAND_ONLY_TYPE;
          temp_strm << "CLIENT ERROR NOT SENDING KEY_PAIR";
          response.command = temp_strm.str();

          ++errors_occurred;

          goto END_SEND_KEY_PAIR;

    }  /* |if (fp == 0)|  */
    else if (param->PARSER_DEBUG)
    {
        cerr << "`popen' succeeded." << endl;

    }  /* |else if (param->PARSER_DEBUG)|  */ 

    errno = 0;
    status = fscanf(fp, "%lu", &(param->key_id));

    if (status == EOF || status == 0)
    {
          param->msg_strm << "ERROR!  In `zzparse':  Rule `SEND_ZZ KEY_PAIR_ZZ':"
                          << endl
                          << "`fscanf' failed, returning " << status << "."
                          << endl;

          if (errno != 0)
             param->msg_strm << "fscanf error:  " << strerror(errno) << endl;

          param->msg_strm << "Failed to read key id for Distinguished Name "
                          << "\"" << curr_dn << "\"."
                          << endl 
                          << "Sending error message to `optdbsrv' and will try to continue."
                          << endl;      

          lock_cerr_mutex(); 
          cerr << param->msg_strm.str();
          unlock_cerr_mutex(); 

          log_strm << param->msg_strm.str();
          err_log_strm << param->msg_strm.str();

          param->msg_strm.str("");

          response.type = Response_Type::COMMAND_ONLY_TYPE;
          temp_strm << "CLIENT ERROR NOT SENDING KEY_PAIR";
          response.command = temp_strm.str();

          ++errors_occurred;

          goto END_SEND_KEY_PAIR;

    }  /* |if (status == EOF || status == 0)|  */

    else if (param->PARSER_DEBUG)
    {
        cerr << "param->key_id == " << param->key_id << endl;

    }  /* |else if (param->PARSER_DEBUG)|  */

@q ***** (5) @>

@ This code is only reached if there haven't been any errors.
\initials{LDF 2011.11.04.}

|param->key_id| is sent as a |string| and converted to an |unsigned long int|
in |yyparse|.  Since the key id is a number made up of eight hexadecimal digits, 
it may be larger than |MAX_INT|.  On \.{pcfinston.gwdg.de}, |MAX_UINT| is exactly 
|FFFFFFFF|.  However, it could be |< MAX_INT|. 
\par
It therefore does not work to try to determine in |yyscan| what sort of integer value the 
key id should be.  Nor do I want to use |unsigned long| for all integer values.
\initials{LDF 2011.12.16.}

@<Rules@>=

    response.type = Response_Type::KEY_PAIR_TYPE;

    temp_strm << "CLIENT SENDING KEY_PAIR <" << curr_dn << "> <" << param->key_id << ">";

    if (param->PARSER_DEBUG)
    {
        cerr << "temp_strm.str() == " << temp_strm.str() << endl;

    }  /* |if (param->PARSER_DEBUG)|  */ 

    response.command = temp_strm.str();
    response.local_filename = temp_filename_1;
    response.local_filename_1 = temp_filename_2;

@q ***** (5) @>
@
\LOG
\initials{LDF 2012.01.27.}
@:BUG FIX@> BUG FIX:  Now calling |pclose(fp)|.
\ENDLOG
@<Rules@>=

   END_SEND_KEY_PAIR: ;

   pthread_mutex_lock(&param->response_deque_mutex);
   param->response_deque.push_front(response);
   pthread_mutex_unlock(&param->response_deque_mutex);

   pclose(fp);

   if (!save_temp_files)
      unlink(temp_filename);

};

@q **** (4) replaced_optional.  @>

@ \<replaced optional>.
\initials{LDF 2011.11.14.}

\LOG
\initials{LDF 2011.11.14.}
Added this section.
\ENDLOG

@<Type declarations for non-terminal symbols@>=
@=%type <int_value> replaced_optional@>@/

@q **** (4) replaced_optional --> /* Empty  */ @>

@ \<replaced optional> $\longrightarrow$ \.{Empty}.
\initials{LDF 2011.11.14.}

\LOG
\initials{LDF 2011.11.14.}
Added this rule.
\ENDLOG

@<Rules@>=

@=replaced_optional: /* Empty  */@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "In `zzparse':  Rule `replaced_optional: /* Empty */'."
              << endl;
         unlock_cerr_mutex(); 
     }

     @=$$@> = 0;

};

@q **** (4) replaced_optional --> REPLACED_ZZ. @>

@ \<replaced optional> $\longrightarrow$ \.{REPLACED\_ZZ}.
\initials{LDF 2011.11.14.}

\LOG
\initials{LDF 2011.11.14.}
Added this rule.
\ENDLOG

@<Rules@>=

@=replaced_optional: REPLACED_ZZ @>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "In `zzparse':  Rule `replaced_optional: REPLACED_ZZ'."
              << endl;
         unlock_cerr_mutex(); 
     }

     @=$$@> = 1;

};

@q **** (4) replaced_optional --> NOT_ZZ REPLACED_ZZ. @>

@ \<replaced optional> $\longrightarrow$ \.{NOT\_ZZ} \.{REPLACED\_ZZ}.
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=replaced_optional: NOT_ZZ REPLACED_ZZ @>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "In `zzparse':  Rule `replaced_optional: REPLACED_ZZ'."
              << endl;
         unlock_cerr_mutex(); 
     }

     @=$$@> = 2;

};

@q **** (4) statement --> RECEIVE_ZZ KEY_PAIR_ZZ SUCCEEDED_ZZ replaced_optional.  @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_ZZ} \.{KEY\_PAIR\_ZZ}
\.{SUCCEEDED\_ZZ} \<replaced optional>.
\initials{LDF 2011.11.03.}

\LOG
\initials{LDF 2011.11.03.}
Added this rule.

\initials{LDF 2011.11.14.}
Added \<replaced optional>.
\ENDLOG

@<Rules@>=

@=statement: RECEIVE_ZZ KEY_PAIR_ZZ SUCCEEDED_ZZ replaced_optional@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "In `zzparse':  Rule `statement: "
              << "RECEIVE_ZZ KEY_PAIR_ZZ SUCCEEDED_ZZ replaced_optional'."
              << endl;
         unlock_cerr_mutex(); 
     }

     param->msg_strm.str("");

     param->msg_strm << "Server received key pair successfully.";
 
     if (@=$4@> == 1)
         param->msg_strm << "  Replaced key pair.";

     param->msg_strm << endl;

     lock_cerr_mutex(); 
     cerr << param->msg_strm.str();
     unlock_cerr_mutex(); 

     log_strm << param->msg_strm.str();

     param->msg_strm.str("");

};

@q **** (4) statement --> RECEIVE_ZZ KEY_PAIR_ZZ FAILED_ZZ @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_ZZ} \.{KEY\_PAIR\_ZZ}
\.{FAILED\_ZZ}.
\initials{LDF 2011.11.03.}

\LOG
\initials{LDF 2011.11.03.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: RECEIVE_ZZ KEY_PAIR_ZZ FAILED_ZZ @>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
   
         cerr << "In `zzparse':  Rule `statement: statement --> "
              << "RECEIVE_ZZ KEY_PAIR_ZZ FAILED_ZZ'."
              << endl;

     param->msg_strm << "Error:  Receive key pair failed" << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     param->entry_string_vector.clear();

     param->msg_strm.str("");

     ++errors_occurred;

};

@q **** (4) statement --> RECEIVE_ZZ PUBLIC_KEY_ZZ SUCCEEDED_ZZ replaced_optional.  @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_ZZ} \.{PUBLIC\_KEY\_ZZ}
\.{SUCCEEDED\_ZZ} \<replaced optional>.
\initials{LDF 2011.12.12.}

\LOG
\initials{LDF 2011.12.12.}
Added \<replaced optional>.
\ENDLOG

@<Rules@>=

@=statement: RECEIVE_ZZ PUBLIC_KEY_ZZ SUCCEEDED_ZZ replaced_optional@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "In `zzparse':  Rule `statement: "
              << "RECEIVE_ZZ PUBLIC_KEY_ZZ SUCCEEDED_ZZ replaced_optional'."
              << endl;
         unlock_cerr_mutex(); 
     }

     param->msg_strm.str("");

     param->msg_strm << "Server received public key successfully.";
 
     if (@=$4@> == 1)
         param->msg_strm << "  Replaced public key.";

     else if (@=$4@> == 2)
         param->msg_strm << "  Public key already in database.  Not replaced.";

     param->msg_strm << endl;

     lock_cerr_mutex(); 
     cerr << param->msg_strm.str();
     unlock_cerr_mutex(); 

     log_strm << param->msg_strm.str();

     param->msg_strm.str("");

};

@q **** (4) statement --> RECEIVE_ZZ PUBLIC_KEY_ZZ FAILED_ZZ @>

@ \<statement> $\longrightarrow$ \.{RECEIVE\_ZZ} \.{PUBLIC\_KEY\_ZZ}
\.{FAILED\_ZZ}.
\initials{LDF 2011.12.12.}

\LOG
\initials{LDF 2011.12.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: RECEIVE_ZZ PUBLIC_KEY_ZZ FAILED_ZZ @>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
   
         cerr << "In `zzparse':  Rule `statement: statement --> "
              << "RECEIVE_ZZ PUBLIC_KEY_ZZ FAILED_ZZ'."
              << endl;

     param->msg_strm << "Error:  Receive public key failed" << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     param->entry_string_vector.clear();

     param->msg_strm.str("");

     ++errors_occurred;

};

@q **** (4) package_version_optional.  @>

@ \<package version optional>.
\initials{LDF 2011.10.14.}

\LOG
\initials{LDF 2011.10.14.}
Added this section.
\ENDLOG

@<Type declarations for non-terminal symbols@>=
@=%type <string_value> package_version_optional@>@/

@q **** (4) @>
@
\LOG
\initials{LDF 2011.03.31.}
Added this section.
\ENDLOG

@<Rules@>=
@=package_version_optional: /* Empty  */@>
{
     
   strcpy(@=$$@>, "");

};

@q **** (4) @>
@
\LOG
\initials{LDF 2011.03.31.}
Added this section.
\ENDLOG

@<Rules@>=
@=package_version_optional: PACKAGE_VERSION_ZZ STRING_ZZ@>
{

   strcpy(@=$$@>, @=$2@>);

};

@q **** (4) @>

@ \<stdout filename optional> and \<stderr filename optional>.
\initials{LDF 2011.10.18.}

\LOG
\initials{LDF 2011.10.18.}
Added this section.

\initials{LDF 2011.10.21.}
Added the type declaration for \<timeout optional>.

\initials{LDF 2011.10.28.}
Added the type declaration for \<package version list>.

\initials{LDF 2012.02.07.}
Removed the type declaration for \<timeout optional>.
\ENDLOG

@<Type declarations for non-terminal symbols@>=
@=%type <string_value> stdout_filename_optional@>@/@/
@=%type <string_value> stderr_filename_optional@>@/
@=%type <string_value> package_version_list@>@/

@q **** (4) stdout_filename_optional: /* Empty  */  @>

@ \<stdout filename optional> $\longrightarrow$ \.{Empty}.
\initials{LDF 2011.10.18.}

\LOG
\initials{LDF 2011.10.14.}
Added this rule.
\ENDLOG

@<Rules@>=
@=stdout_filename_optional: /* Empty  */ @>
{
   strcpy(@=$$@>, "");

};

@q **** (4) stdout_filename_optional: STDOUT_FILENAME_ZZ STRING_ZZ @>

@ \<stdout filename optional> $\longrightarrow$ \.{STDOUT\_FILENAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2011.10.18.}

\LOG
\initials{LDF 2011.10.14.}
Added this rule.
\ENDLOG

@<Rules@>=
@=stdout_filename_optional: STDOUT_FILENAME_ZZ STRING_ZZ @>
{
   strcpy(@=$$@>, @=$2@>);

};

@q **** (4) stderr_filename_optional: /* Empty  */  @>

@ \<stderr filename optional> $\longrightarrow$ \.{Empty}.
\initials{LDF 2011.10.18.}

\LOG
\initials{LDF 2011.10.14.}
Added this rule.
\ENDLOG

@<Rules@>=
@=stderr_filename_optional: /* Empty  */ @>
{
   strcpy(@=$$@>, "");

};

@q **** (4) stderr_filename_optional: STDERR_FILENAME_ZZ STRING_ZZ @>

@ \<stderr filename optional> $\longrightarrow$ \.{STDERR\_FILENAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2011.10.18.}

\LOG
\initials{LDF 2011.10.14.}
Added this rule.
\ENDLOG

@<Rules@>=
@=stderr_filename_optional: STDERR_FILENAME_ZZ STRING_ZZ @>
{
   strcpy(@=$$@>, @=$2@>);

};

@q **** (4) statement --> REMOTE_ZZ INSTALLATION_ZZ SUCCEEDED_ZZ      @>
@q **** (4) FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ package_version_optional @>
@q **** (4) GLOBUS_SITE_ZZ STRING_ZZ stdout_filename_optional         @>
@q **** (4) stderr_filename_optional                                  @>

@ \<statement> $\longrightarrow$ \.{REMOTE\_ZZ} \.{INSTALLATION\_ZZ} 
\.{SUCCEEDED\_ZZ} \.{FOR\_ZZ} \.{PACKAGE\_NAME\_ZZ} \.{STRING\_ZZ} 
\<package version optional> \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}
\<stdout filename optional> \<stderr filename optional>.

\LOG
\initials{LDF 2011.10.14.}
Added this rule.

\initials{LDF 2012.02.10.}
Added \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}.
\ENDLOG

@<Rules@>=

@=statement: REMOTE_ZZ INSTALLATION_ZZ SUCCEEDED_ZZ @>@/
@=FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ package_version_optional @>
@=GLOBUS_SITE_ZZ STRING_ZZ stdout_filename_optional stderr_filename_optional @> 
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
     {
         cerr << "In `zzparse':  Rule `statement: REMOTE_ZZ "
              << "INSTALLATION_ZZ SUCCEEDED_ZZ "
              << "FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ package_version_optional "
              << "GLOBUS_SITE_ZZ STRING_ZZ stdout_filename_optional "
              << "stderr_filename_optional'."
              << endl;

         cerr << "package_name == " << @=$6@> << endl
              << "package_version == " << @=$7@> << endl
              << "Globus site == " << @=$9@> << endl 
              << "stdout_filename_optional == " << @=$10@> << endl
              << "stderr_filename_optional == " << @=$11@> << endl;

     }

     bool success = true;

     int status;

     if (strlen(@=$10@>))
     {
        status = accept_data(param, @=$10@>, 0, 
                             Response_Type::REMOTE_INSTALL_TYPE, 
                             0);

     }

     else
     {

        param->msg_strm.str("");

        param->msg_strm << static_cast<char>(12) << endl << "Standard output for " 
                        << @=$6@> << " ";

        if (strlen(@=$7@>) && strcmp(@=$7@>, "(none)"))
  
           param->msg_strm << @=$7@> << " ";

        param->msg_strm << "installation:" << endl << endl;

        cout << param->msg_strm.str();
        log_strm << param->msg_strm.str();

        status = accept_data(param, 0, 0, 
                             Response_Type::REMOTE_INSTALL_TYPE, 
                             0);

        param->msg_strm.str("");

        cout << endl << endl;
        log_strm << endl << endl;

     }

     if (status != 0)
     {

         success = false;

         param->msg_strm << "ERROR!  In `zzparse':  Rule `statement: REMOTE_ZZ "
                         << "INSTALLATION_ZZ SUCCEEDED_ZZ "
                         << endl 
                         << "FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ package_version_optional "
                         << "GLOBUS_SITE_ZZ STRING_ZZ stdout_filename_optional "
                         << "stderr_filename_optional':" 
                         << endl
                         << "`accept_data' failed to save standard output file, "
                         << "returning " << status << endl;

         cerr << param->msg_strm.str();
         log_strm << param->msg_strm.str();
         err_log_strm << param->msg_strm.str();

         param->msg_strm.str("");

         ++errors_occurred;
     
     }
     else if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "In `zzparse':  Rule `statement: REMOTE_ZZ "
              << "INSTALLATION_ZZ SUCCEEDED_ZZ "
              << endl 
              << "FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ package_version_optional "
              << "GLOBUS_SITE_ZZ STRING_ZZ stdout_filename_optional "
              << "stderr_filename_optional':"
              << endl
              << "`accept_data' succeeded for standard output file."  << endl;
         unlock_cerr_mutex(); 
     }

     param->msg_strm.str("");

     if (strlen(@=$11@>))
     {

         status = accept_data(param, @=$11@>, 0, 
                              Response_Type::REMOTE_INSTALL_TYPE, 
                              0);
     }

     else
     {

        param->msg_strm.str("");

        param->msg_strm << static_cast<char>(12) << endl << "Standard error for " 
                        << @=$6@> << " ";

        if (strlen(@=$7@>) && strcmp(@=$7@>, "(none)"))
           param->msg_strm << @=$7@> << " ";

        param->msg_strm << "installation:" << endl << endl;

        cout << param->msg_strm.str();
        log_strm << param->msg_strm.str();

        status = accept_data(param, 0, 0, 
                             Response_Type::REMOTE_INSTALL_TYPE, 
                             0);

        cout << endl << static_cast<char>(12) << endl;
        log_strm << endl << static_cast<char>(12) << endl;

        param->msg_strm.str("");

     }

     if (status != 0)
     {
         success = false;

         param->msg_strm << "ERROR!  In `zzparse':  Rule `statement: REMOTE_ZZ "
                         << "INSTALLATION_ZZ SUCCEEDED_ZZ "
                         << endl 
                         << "FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ package_version_optional "
                         << "GLOBUS_SITE_ZZ STRING_ZZ stdout_filename_optional "
                         << "stderr_filename_optional':" 
                         << endl
                         << "`accept_data' failed to save standard error file, "
                         << "returning " << status << endl;

         cerr << param->msg_strm.str();
         log_strm << param->msg_strm.str();
         err_log_strm << param->msg_strm.str();

         param->msg_strm.str("");

         ++errors_occurred;
     
     }
     else if (param->PARSER_DEBUG)
     {
         cerr << "In `zzparse':  Rule `statement: REMOTE_ZZ "
              << "INSTALLATION_ZZ SUCCEEDED_ZZ "
              << endl 
              << "FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ package_version_optional "
              << "GLOBUS_SITE_ZZ STRING_ZZ stdout_filename_optional "
              << "stderr_filename_optional':"
              << endl
              << "`accept_data' succeeded for standard error file."  << endl;
     }

     if (success && (strlen(@=$10@>) || strlen(@=$11@>)))
     {
         cout << "Remote installation of " << @=$6@>;
  
         if (strlen(@=$7@>))
             cout << " " << @=$7@>;

         cout << " finished." << endl;

         if (strlen(@=$10@>))
            cout << "For results see standard output file `" << @=$10@> << "'";

         if (strlen(@=$11@>))
            cout << " and standard error file `" << @=$11@> << "'";

         cout << "." << endl;

     }

     char ACK = static_cast<char>(6);

     stringstream temp_strm;

     temp_strm << ACK << ACK;

     temp_strm << "Remote installation succeeded for \"" << @=$6@> << "\"";

     if (strlen(@=$7@>))
         temp_strm << " \"" << @=$7@> << "\"";

     if (strlen(@=$9@>))
     {
        temp_strm << " on Globus site \"" << @=$9@> << "\".";
     }

     if (!success)
        temp_strm << "  WARNING:  One or more output files could not be saved.";

     temp_strm << ACK << ACK << endl << endl;

     cout << temp_strm.str();
     log_strm << temp_strm.str();

};

@q **** (4) statement --> REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ         @>
@q **** (4) FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ package_version_optional @>
@q **** (4) GLOBUS_SITE_ZZ STRING_ZZ PROXY_CREDENTIAL_ZZ EXPIRED_ZZ  @>

@ \<statement> $\longrightarrow$ \.{REMOTE\_ZZ} \.{INSTALLATION\_ZZ} 
\.{FAILED\_ZZ} \.{FOR\_ZZ} \.{PACKAGE\_NAME\_ZZ} \.{STRING\_ZZ} 
\<package version optional> \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}
\.{PROXY\_CERTIFICATE\_ZZ} \.{EXPIRED\_ZZ}.
\initials{LDF 2012.02.07.}

\LOG
\initials{LDF 2012.02.07.}
Added this rule.

\initials{LDF 2012.02.10.}
Added \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}.
\ENDLOG

@<Rules@>=

@=statement: REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ FOR_ZZ @>@/
@=PACKAGE_NAME_ZZ STRING_ZZ package_version_optional @>
@=GLOBUS_SITE_ZZ STRING_ZZ PROXY_CREDENTIAL_ZZ EXPIRED_ZZ@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
     {
         cerr << "In `zzparse':  Rule `statement: REMOTE_ZZ "
              << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ "
              << "package_version_optional GLOBUS_SITE_ZZ STRING_ZZ "
              << "PROXY_CREDENTIAL_ZZ EXPIRED_ZZ'."
              << endl;

     }

     param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: REMOTE_ZZ "
                     << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ "
                     << "package_version_optional GLOBUS_SITE_ZZ STRING_ZZ "
                     << "PROXY_CREDENTIAL_ZZ EXPIRED_ZZ':"
                     << endl
                     << endl
                     << "Remote installation failed "
                     << "on Globus site `" << @=$9@> << "':  "
                     << "proxy credential expired."
                     << endl 
                     << "Continuing."
                     << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     ++warnings_occurred;

     stringstream temp_strm;

     char ACK = static_cast<char>(6);

     temp_strm << ACK << ACK;

     temp_strm << "Remote installation failed ";

     if (strlen(@=$6@>))
     {
         temp_strm << "for \"" << @=$6@> << "\" ";

         if (strlen(@=$7@>))
             temp_strm << "\"" << @=$7@> << "\" ";
     }

     temp_strm << "on Globus site \"" << @=$9@> << "\".";

     temp_strm << ACK << ACK 
               << endl 
               << ACK << ACK << "proxy credential expired."
               << ACK << ACK << endl;

     cout << temp_strm.str();
     log_strm << temp_strm.str();

};

@q **** (4) statement --> REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ         @>
@q **** (4) FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ package_version_optional @>
@q **** (4) GLOBUS_SITE_ZZ STRING_ZZ PROXY_CREDENTIAL_ZZ ERROR_ZZ    @>

@ \<statement> $\longrightarrow$ \.{REMOTE\_ZZ} \.{INSTALLATION\_ZZ} 
\.{FAILED\_ZZ} \.{FOR\_ZZ} \.{PACKAGE\_NAME\_ZZ} \.{STRING\_ZZ} 
\<package version optional> \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}
\.{PROXY\_CERTIFICATE\_ZZ} \.{ERROR\_ZZ}.
\initials{LDF 2012.02.07.}

\LOG
\initials{LDF 2012.02.07.}
Added this rule.

\initials{LDF 2012.02.10.}
Added \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}.
\ENDLOG

@<Rules@>=

@=statement: REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ FOR_ZZ @>@/
@=PACKAGE_NAME_ZZ STRING_ZZ package_version_optional @>
@=GLOBUS_SITE_ZZ STRING_ZZ PROXY_CREDENTIAL_ZZ ERROR_ZZ@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
     {
         cerr << "In `zzparse':  Rule `statement: REMOTE_ZZ "
              << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ "
              << "package_version_optional GLOBUS_SITE_ZZ STRING_ZZ "
              << "PROXY_CREDENTIAL_ZZ ERROR_ZZ'."
              << endl;

     }

     param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: REMOTE_ZZ "
                     << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ "
                     << "package_version_optional GLOBUS_SITE_ZZ STRING_ZZ "
                     << "PROXY_CREDENTIAL_ZZ ERROR_ZZ':"
                     << endl
                     << endl
                     << "Remote installation failed "
                     << "on Globus site `" << @=$9@> << "':"
                     << endl
                     << "proxy credential error:  "
                     << "No proxy credential or proxy credential cannot be opened or read."
                     << endl 
                     << "Continuing."
                     << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     ++warnings_occurred;

     stringstream temp_strm;

     char ACK = static_cast<char>(6);

     temp_strm << ACK << ACK;

     temp_strm << "Remote installation failed ";

     if (strlen(@=$6@>))
     {
         temp_strm << "for \"" << @=$6@> << "\" ";

         if (strlen(@=$7@>))
             temp_strm << "\"" << @=$7@> << "\" ";
     }

     temp_strm << "on Globus site \"" << @=$9@> << "\".";

     temp_strm << ACK << ACK
               << endl 
               << ACK << ACK << "proxy credential error:  "
               << "No proxy credential or proxy credential cannot be opened or read."
               << ACK << ACK << endl;

     cout << temp_strm.str();
     log_strm << temp_strm.str();

};

@q **** (4) statement --> REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ          @>
@q **** (4) FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ package_version_optional  @>
@q **** (4) GLOBUS_SITE_ZZ STRING_ZZ PROXY_CREDENTIAL_ZZ NOT_FOUND_ZZ @>

@ \<statement> $\longrightarrow$ \.{REMOTE\_ZZ} \.{INSTALLATION\_ZZ} 
\.{FAILED\_ZZ} \.{FOR\_ZZ} \.{PACKAGE\_NAME\_ZZ} \.{STRING\_ZZ} 
\<package version optional> \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}
\.{PROXY\_CERTIFICATE\_ZZ} \.{NOT\_FOUND\_ZZ}.
\initials{LDF 2012.02.07.}

\LOG
\initials{LDF 2012.02.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ FOR_ZZ @>@/
@=PACKAGE_NAME_ZZ STRING_ZZ package_version_optional @>
@=GLOBUS_SITE_ZZ STRING_ZZ PROXY_CREDENTIAL_ZZ NOT_FOUND_ZZ@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
     {
         cerr << "In `zzparse':  Rule `statement: REMOTE_ZZ "
              << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ "
              << "package_version_optional GLOBUS_SITE_ZZ STRING_ZZ "
              << "PROXY_CREDENTIAL_ZZ NOT_FOUND_ZZ'."
              << endl;

     }

     param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: REMOTE_ZZ "
                     << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ "
                     << "package_version_optional GLOBUS_SITE_ZZ STRING_ZZ "
                     << "PROXY_CREDENTIAL_ZZ NOT_FOUND_ZZ':"
                     << endl
                     << endl
                     << "Remote installation failed on Globus site "
                     << "`" << @=$9@> << "':  proxy credential not found."
                     << endl 
                     << "Continuing."
                     << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     ++warnings_occurred;

     stringstream temp_strm;

     char ACK = static_cast<char>(6);

     temp_strm << ACK << ACK;

     temp_strm << "Remote installation failed ";

     if (strlen(@=$6@>))
     {
         temp_strm << "for \"" << @=$6@> << "\" ";

         if (strlen(@=$7@>))
             temp_strm << "\"" << @=$7@> << "\" ";
     }

     temp_strm << "on Globus site \"" << @=$9@> << "\".";

     temp_strm << ACK << ACK
               << endl 
               << ACK << ACK << "proxy credential not found."
               << ACK << ACK << endl;

     cout << temp_strm.str();
     log_strm << temp_strm.str();

};

@q **** (4) statement --> REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ @>
@q **** (4) USER_ZZ NAME_ZZ NOT_ZZ FOUND_ZZ                   @>

@ \<statement> $\longrightarrow$ \.{REMOTE\_ZZ} \.{INSTALLATION\_ZZ} 
\.{FAILED\_ZZ} \.{USER\_ZZ} \.{NAME\_ZZ} \.{NOT\_ZZ} \.{FOUND\_ZZ}.
\initials{LDF 2011.10.27.}

\LOG
\initials{LDF 2011.10.27.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ USER_ZZ NAME_ZZ NOT_ZZ FOUND_ZZ@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
     {
         cerr << "In `zzparse':  Rule `statement: REMOTE_ZZ "
              << "INSTALLATION_ZZ FAILED_ZZ USER_ZZ "
              << "NAME_ZZ NOT_ZZ FOUND_ZZ'."
              << endl;

     }

     param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: REMOTE_ZZ "
                     << "INSTALLATION_ZZ FAILED_ZZ USER_ZZ "
                     << "NAME_ZZ NOT_ZZ FOUND_ZZ':"
                     << endl
                     << endl
                     << "Remote installation failed.  User name not found."
                     << endl 
                     << "Continuing."
                     << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     ++warnings_occurred;
     
     stringstream temp_strm;

     char ACK = static_cast<char>(6);

     temp_strm << ACK << ACK << endl;     

     temp_strm << "Remote installation failed ";

     temp_strm << ACK << ACK << endl
               << endl << ACK << ACK << "User name not found."
               << ACK << ACK << endl;

     cout << temp_strm.str();
     log_strm << temp_strm.str();

};

@q **** (4) statement --> REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ FOR_ZZ @>
@q **** (4) PACKAGE_NAME_ZZ STRING_ZZ package_version_optional       @>
@q **** (4) USER_ZZ NAME_ZZ NOT_ZZ FOUND_ZZ                          @>

@ \<statement> $\longrightarrow$ \.{REMOTE\_ZZ} \.{INSTALLATION\_ZZ} 
\.{FAILED\_ZZ} \.{FOR\_ZZ} \.{PACKAGE\_NAME\_ZZ} \.{STRING\_ZZ} \<package version optional>
\.{USER\_ZZ} \.{NAME\_ZZ} \.{NOT\_ZZ} \.{FOUND\_ZZ}.
\initials{LDF 2011.10.27.}

\LOG
\initials{LDF 2011.10.27.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ FOR_ZZ @>@/
@=PACKAGE_NAME_ZZ STRING_ZZ package_version_optional @>
@=USER_ZZ NAME_ZZ NOT_ZZ FOUND_ZZ@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
     {
         cerr << "In `zzparse':  Rule `statement: REMOTE_ZZ "
              << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ "
              << "package_version_optional USER_ZZ "
              << "NAME_ZZ NOT_ZZ FOUND_ZZ'."
              << endl;

     }

     param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: REMOTE_ZZ "
                     << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ "
                     << "package_version_optional USER_ZZ "
                     << "NAME_ZZ NOT_ZZ FOUND_ZZ':"
                     << endl
                     << endl
                     << "Remote installation failed.  User name not found."
                     << endl 
                     << "Continuing."
                     << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     ++warnings_occurred;
     
     stringstream temp_strm;

     char ACK = static_cast<char>(6);

     temp_strm << ACK << ACK << endl;     

     temp_strm << "Remote installation failed ";

     if (strlen(@=$6@>))
     {
         temp_strm << "for \"" << @=$6@> << "\" ";

         if (strlen(@=$7@>))
            temp_strm << " \"" << @=$7@> << "\"";
     }

     temp_strm << ACK << ACK << endl
               << endl << ACK << ACK << "User name not found."
               << ACK << ACK << endl;

     cout << temp_strm.str();
     log_strm << temp_strm.str();

};

@q **** (4) statement --> REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ FOR_ZZ @>
@q **** (4) PACKAGE_NAME_ZZ STRING_ZZ GLOBUS_SITE_ZZ STRING_ZZ NOT_ZZ FOUND_ZZ @>

@ \<statement> $\longrightarrow$ \.{REMOTE\_ZZ} \.{INSTALLATION\_ZZ} 
\.{FAILED\_ZZ} \.{FOR\_ZZ} \.{PACKAGE\_NAME\_ZZ} \.{STRING\_ZZ} 
\<package version optional> \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} 
\.{NOT\_ZZ} \.{FOUND\_ZZ}.
\initials{LDF 2011.11.17.}

\LOG
\initials{LDF 2011.11.17.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ FOR_ZZ @>@/
@=PACKAGE_NAME_ZZ STRING_ZZ package_version_optional @>
@=GLOBUS_SITE_ZZ STRING_ZZ NOT_ZZ FOUND_ZZ@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
     {
         cerr << "In `zzparse':  Rule `statement: REMOTE_ZZ "
              << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ "
              << "package_version_optional GLOBUS_SITE_ZZ STRING_ZZ "
              << "NOT_ZZ FOUND_ZZ'."
              << endl;

     }

     param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: REMOTE_ZZ "
                     << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ "
                     << "package_version_optional GLOBUS_SITE_ZZ STRING_ZZ "
                     << "NOT_ZZ FOUND_ZZ':"
                     << endl
                     << endl
                     << "Remote installation failed:  Unknown Globus site "
                     << "`" << @=$9@> << "'."
                     << endl 
                     << "Continuing."
                     << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     ++warnings_occurred;

     stringstream temp_strm;

     char ACK = static_cast<char>(6);

     temp_strm << ACK << ACK << endl;     

     temp_strm << "Remote installation failed";

     if (strlen(@=$6@>))
     {
         temp_strm << " for \"" << @=$6@> << "\" ";

         if (strlen(@=$7@>))
            temp_strm << " \"" << @=$7@> << "\"";
     }

     temp_strm << ACK << ACK
               << endl << ACK << ACK << "Globus site \"" 
               << @=$9@> << "\" not found."
               << ACK << ACK << endl;

     cout << temp_strm.str();
     log_strm << temp_strm.str();

};

@q **** (4) statement --> REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ FOR_ZZ @>
@q **** (4) PACKAGE_NAME_ZZ STRING_ZZ package_version_optional       @>
@q **** (4) GLOBUS_SITE_ZZ STRING_ZZ DISABLED_ZZ.                    @>

@ \<statement> $\longrightarrow$ \.{REMOTE\_ZZ} \.{INSTALLATION\_ZZ} 
\.{FAILED\_ZZ} \.{FOR\_ZZ} \.{PACKAGE\_NAME\_ZZ} \.{STRING\_ZZ} 
\<package version optional> \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} \.{DISABLED\_ZZ}.
\initials{LDF 2011.11.21.}

\LOG
\initials{LDF 2011.11.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ FOR_ZZ @>@/
@=PACKAGE_NAME_ZZ STRING_ZZ package_version_optional @>
@=GLOBUS_SITE_ZZ STRING_ZZ DISABLED_ZZ@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
     {
         cerr << "In `zzparse':  Rule `statement: REMOTE_ZZ "
              << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ "
              << "package_version_optional GLOBUS_SITE_ZZ STRING_ZZ "
              << "DISABLED_ZZ'."
              << endl;

     }

     param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: REMOTE_ZZ "
                     << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ PACKAGE_NAME_ZZ STRING_ZZ "
                     << "package_version_optional GLOBUS_SITE_ZZ STRING_ZZ "
                     << "DISABLED_ZZ':"
                     << endl
                     << endl
                     << "Remote installation failed:  Globus site "
                     << "`" << @=$9@> << "' disabled."
                     << endl 
                     << "Continuing."
                     << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     ++warnings_occurred;

     stringstream temp_strm;

     char ACK = static_cast<char>(6);

     temp_strm << ACK << ACK << endl;     

     temp_strm << "Remote installation failed";

     if (strlen(@=$6@>))
     {
         temp_strm << " for \"" << @=$6@> << "\" ";

         if (strlen(@=$7@>))
             temp_strm << " \"" << @=$7@> << "\"";
     }

     temp_strm << ACK << ACK
               << endl 
               << ACK << ACK 
               << "Globus site \"" << @=$9@> << "\" disabled."
               << ACK << ACK << endl;

     cout << temp_strm.str();
     log_strm << temp_strm.str();

};

@q **** (4) statement --> REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ FOR_ZZ PACKAGE_NAME_ZZ @>
@q **** (4) STRING_ZZ package_version_optional GLOBUS_SITE_ZZ STRING_ZZ @>
@q **** (4) TIMEOUT_ZZ INTEGER_ZZ @>

@ \<statement> $\longrightarrow$ \.{REMOTE\_ZZ} \.{INSTALLATION\_ZZ} 
\.{FAILED\_ZZ} \.{FOR\_ZZ} \.{PACKAGE\_NAME\_ZZ} \.{STRING\_ZZ} 
\<package version optional> \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}
\.{TIMEOUT\_ZZ} \.{INTEGER\_ZZ}.

\LOG
\initials{LDF 2012.02.07.}
Added this rule.

\initials{LDF 2012.02.10.}
Added \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}.
\ENDLOG

@<Rules@>=

@=statement: REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ FOR_ZZ @>@/
@=PACKAGE_NAME_ZZ STRING_ZZ package_version_optional GLOBUS_SITE_ZZ STRING_ZZ @>
@=TIMEOUT_ZZ INTEGER_ZZ@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
     {
         cerr << "In `zzparse':  Rule `statement: REMOTE_ZZ "
              << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ "
              << "PACKAGE_NAME_ZZ STRING_ZZ package_version_optional "
              << "GLOBUS_SITE_ZZ STRING_ZZ TIMEOUT_ZZ INTEGER_ZZ'."
              << endl;

     }

     param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: REMOTE_ZZ "
                     << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ "
                     << "PACKAGE_NAME_ZZ STRING_ZZ package_version_optional "
                     << "GLOBUS_SITE_ZZ STRING_ZZ TIMEOUT_ZZ INTEGER_ZZ':"
                     << endl
                     << endl
                     << "Remote installation failed for `"
                     << @=$6@> << "' ";

     if (strlen(@=$7@>))

       param->msg_strm << "`" << @=$7@> << "' ";

     param->msg_strm << "on Globus site `" << @=$9@> << "'.";

     if (@=$11@> != -1)
 
        param->msg_strm << "  Installation timed out after " 
                        << @=$11@> << " seconds." << endl;

     param->msg_strm << endl << "Continuing."
                     << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     ++warnings_occurred;

     stringstream temp_strm;

     char ACK = static_cast<char>(6);

     temp_strm << ACK << ACK;

     temp_strm << "Remote installation failed for \"" << @=$6@> << "\" ";

     if (strlen(@=$7@>))
         temp_strm << "\"" << @=$7@> << "\" ";

     temp_strm << "on Globus site \"" << @=$9@> << "\".";

     temp_strm << ACK << ACK;

     if (@=$11@> != -1)
         temp_strm << endl << ACK << ACK << "Installation timed out after " 
                   << @=$11@> << " seconds." << ACK << ACK << endl;

     cout << temp_strm.str();
     log_strm << temp_strm.str();

};

@q **** (4) statement --> REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ FOR_ZZ @>
@q **** (4) PACKAGE_NAME_ZZ STRING_ZZ package_version_optional       @>
@q **** (4) GLOBUS_SITE_ZZ STRING_ZZ OTHER_ZZ REASON_ZZ              @>

@ \<statement> $\longrightarrow$ \.{REMOTE\_ZZ} \.{INSTALLATION\_ZZ} 
\.{FAILED\_ZZ} \.{FOR\_ZZ} \.{PACKAGE\_NAME\_ZZ} \.{STRING\_ZZ} 
\<package version optional> \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}
\.{OTHER\_ZZ} \.{REASON\_ZZ}.

\LOG
\initials{LDF 2011.10.18.}
Added this rule.

\initials{LDF 2011.10.19.}
Added symbols ``\.{FOR\_ZZ} \.{PACKAGE\_NAME\_ZZ} \.{STRING\_ZZ} 
\<package version optional>'':

\initials{LDF 2011.10.21.}
Added \<timeout optional>.

\initials{LDF 2012.02.07.}
Removed \<timeout optional>.

\initials{LDF 2012.02.07.}
Added \.{OTHER\_ZZ} \.{REASON\_ZZ}.

\initials{LDF 2012.02.10.}
Added \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}.
\ENDLOG

@<Rules@>=

@=statement: REMOTE_ZZ INSTALLATION_ZZ FAILED_ZZ FOR_ZZ @>@/
@=PACKAGE_NAME_ZZ STRING_ZZ package_version_optional @>
@=GLOBUS_SITE_ZZ STRING_ZZ OTHER_ZZ REASON_ZZ @>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
     {
         cerr << "In `zzparse':  Rule `statement: REMOTE_ZZ "
              << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ "
              << "PACKAGE_NAME_ZZ STRING_ZZ package_version_optional "
              << "GLOBUS_SITE_ZZ STRING_ZZ OTHER_ZZ REASON_ZZ'."
              << endl;

     }

     param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: REMOTE_ZZ "
                     << "INSTALLATION_ZZ FAILED_ZZ FOR_ZZ "
                     << "PACKAGE_NAME_ZZ STRING_ZZ package_version_optional "
                     << "GLOBUS_SITE_ZZ STRING_ZZ OTHER_ZZ REASON_ZZ':"
                     << endl
                     << endl
                     << "Remote installation failed for `"
                     << @=$6@> << "'";

     if (strlen(@=$7@>))
     {
        param->msg_strm << " `" << @=$7@> << "' ";
     }

     param->msg_strm << "on Globus site `" << @=$9@> << "'.  ";

     param->msg_strm << endl << "Continuing."
                     << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     ++warnings_occurred;

     stringstream temp_strm;

     char ACK = static_cast<char>(6);

     temp_strm << ACK << ACK;

     temp_strm << "Remote installation failed for \"" << @=$6@> << "\" ";

     if (strlen(@=$7@>))
         temp_strm << "\"" << @=$7@> << "\" ";

     temp_strm << "on Globus site \"" << @=$9@> << "\".";

     temp_strm << ACK << ACK << endl;

     cout << temp_strm.str();
     log_strm << temp_strm.str();

};

@q **** (4) package_version_list@>
@ \<package version list>.

\LOG
\initials{LDF 2011.10.28.}
Added this rule.
\ENDLOG

@<Rules@>=
@=package_version_list: NO_VERSION_ZZ@>
{

    strcpy(@=$$@>, "(no version)");

};

@q **** (4) package_version_list@>
@ \<package version list>.

\LOG
\initials{LDF 2011.10.28.}
Added this rule.
\ENDLOG

@<Rules@>=
@=package_version_list: STRING_ZZ@>
{

    strcpy(@=$$@>, @=$1@>);

};

@q **** (4) package_version_list@>
@ \<package version list>.

\LOG
\initials{LDF 2011.10.28.}
Added this rule.
\ENDLOG

@<Rules@>=
@=package_version_list: package_version_list NO_VERSION_ZZ@>
{
    strcpy(@=$$@>, @=$1@>);
    strcat(@=$$@>, ", (no version)");

};

@q **** (4) package_version_list@>
@ \<package version list>.

\LOG
\initials{LDF 2011.10.28.}
Added this rule.
\ENDLOG

@<Rules@>=
@=package_version_list: package_version_list STRING_ZZ@>
{

    strcpy(@=$$@>, @=$1@>);
    strcat(@=$$@>, ", ");
    strcat(@=$$@>, @=$2@>);

};

@q **** (4) statement --> REMOTE_ZZ INSTALLATION_ZZ WARNING_ZZ         @>
@q **** (4) PACKAGE_NAME_ZZ STRING_ZZ MULTIPLE_ZZ PACKAGE_VERSIONS_ZZ  @>
@q **** (4) package_version_list GLOBUS_SITE_ZZ STRING_ZZ              @>

@ \<statement> $\longrightarrow$ \.{REMOTE\_ZZ} \.{INSTALLATION\_ZZ} 
\.{WARNING\_ZZ} \.{PACKAGE\_NAME\_ZZ} 
\.{STRING\_ZZ} \.{MULTIPLE\_ZZ} \.{PACKAGE\_VERSIONS\_ZZ} \<package version list>
\.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2011.10.28.}

\LOG
\initials{LDF 2011.10.28.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement: REMOTE_ZZ INSTALLATION_ZZ WARNING_ZZ @>@/
@=PACKAGE_NAME_ZZ STRING_ZZ MULTIPLE_ZZ PACKAGE_VERSIONS_ZZ @>
@=package_version_list GLOBUS_SITE_ZZ STRING_ZZ@>
{

     Scan_Parse_Parameter_Type *param = static_cast<Scan_Parse_Parameter_Type*>(
              zzget_extra(parameter));

     param->msg_strm.str("");

     if (param->PARSER_DEBUG)
     {
         cerr << "In `zzparse':  Rule "
              << "`statement: REMOTE_ZZ INSTALLATION_ZZ WARNING_ZZ "
              << "PACKAGE_NAME_ZZ STRING_ZZ MULTIPLE_ZZ PACKAGE_VERSIONS_ZZ "
              << "package_version_list GLOBUS_SITE_ZZ STRING_ZZ'."
              << endl;

     }

     param->msg_strm << "WARNING!  In `zzparse':  Rule "
                     << "`statement: REMOTE_ZZ INSTALLATION_ZZ WARNING_ZZ "
                     << "PACKAGE_NAME_ZZ STRING_ZZ MULTIPLE_ZZ PACKAGE_VERSIONS_ZZ "
                     << "package_version_list GLOBUS_SITE_ZZ STRING_ZZ':"
                     << endl
                     << endl
                     << "Installing multiple versions of package "
                     << "`" << @=$5@> << "':  " << @=$8@> << " "
                     << " on Globus site `" << @=$10@> << "'."
                     << endl 
                     << "Continuing."
                     << endl;

     cerr << param->msg_strm.str();
     log_strm << param->msg_strm.str();
     err_log_strm << param->msg_strm.str();

     ++warnings_occurred;

};

@q **** (4) statement --> ADDED_ZZ download_info FOR_ZZ ENTRY_ZZ @>
@q **** (4) INTEGER_ZZ entry_string_list                         @>

@ \<statement> $\longrightarrow$ \.{ADDED\_ZZ} \<download info> \.{FOR\_ZZ} 
\.{ENTRY\_ZZ} \.{INTEGER\_ZZ} \<entry string list>.
\initials{LDF 2011.10.31.}

\LOG
\initials{LDF 2011.10.31.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: ADDED_ZZ download_info FOR_ZZ ENTRY_ZZ INTEGER_ZZ entry_string_list@> 
{

   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `ADDED_ZZ download_info "
            << "FOR_ZZ ENTRY_ZZ INTEGER_ZZ entry_string_list'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Added ";

   if (@=$2@> == Response_Type::DOWNLOAD_URL_TYPE)
      param->msg_strm << "download URL (unencrypted) ";

   else if (@=$2@> == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE)
      param->msg_strm << "encrypted download URL ";

   else if (@=$2@> == Response_Type::DOWNLOAD_COMMAND_TYPE)
      param->msg_strm << "download command (unencrypted) ";

   else if (@=$2@> == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE)
      param->msg_strm << "encrypted download command ";

   param->msg_strm << "for entry `" 
                   << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "'."
                   << endl;

   log_strm << param->msg_strm.str();

   cerr << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

};

@q **** (4) statement --> FAILED_ZZ TO_ZZ ADD_ZZ download_info @>
@q **** (4) FOR_ZZ ENTRY_ZZ INTEGER_ZZ entry_string_list       @>

@ \<statement> $\longrightarrow$ \.{FAILED\_ZZ} \.{TO\_ZZ} \.{ADD\_ZZ} 
\<download info> \.{FOR\_ZZ} \.{ENTRY\_ZZ} \.{INTEGER\_ZZ} \<entry string list>.
\initials{LDF 2011.10.31.}

\LOG
\initials{LDF 2011.10.31.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: FAILED_ZZ TO_ZZ ADD_ZZ download_info FOR_ZZ ENTRY_ZZ @>@/
@=INTEGER_ZZ entry_string_list@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `FAILED_ZZ TO_ZZ ADD_ZZ "
            << "download_info FOR_ZZ ENTRY_ZZ INTEGER_ZZ entry_string_list'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "ERROR!  Failed to add ";

   if (@=$4@> == Response_Type::DOWNLOAD_URL_TYPE)
      param->msg_strm << "download URL (unencrypted) ";

   else if (@=$4@> == Response_Type::DOWNLOAD_URL_ENCRYPTED_TYPE)
      param->msg_strm << "encrypted download URL ";

   else if (@=$4@> == Response_Type::DOWNLOAD_COMMAND_TYPE)
      param->msg_strm << "download command (unencrypted) ";

   else if (@=$4@> == Response_Type::DOWNLOAD_COMMAND_ENCRYPTED_TYPE)
      param->msg_strm << "encrypted download command ";

   param->msg_strm << "for entry `"
                   << param->entry_string_vector[0];

   if (param->entry_string_vector.size() > 1)
      param->msg_strm << " " << param->entry_string_vector[1];

   param->msg_strm << "'.  Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   ++errors_occurred;

};

@q **** (4) statement --> SERVER_ZZ SENDING_ZZ KEY_PAIR_ZZ STRING_ZZ.  @>
@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SENDING\_ZZ} 
\.{KEY\_PAIR\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2011.11.10.}

\.{STRING\_ZZ} (|@=$4@>|) is ``key name'', i.e., 
the Distinguished Name of the user.
\initials{LDF 2011.11.15.}

\LOG
\initials{LDF 2011.11.10.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SENDING_ZZ KEY_PAIR_ZZ STRING_ZZ@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    int status = 0;

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "In `zzparse':  Rule `statement: SERVER_ZZ SENDING_ZZ "
             << "KEY_PAIR_ZZ STRING_ZZ'."
             << endl
             << "STRING_ZZ $4 (key name ) == " << @=$4@> << endl;
        unlock_cerr_mutex(); 
    }

@q ***** (5) @>

    Response_Type response;

    response.type    = Response_Type::COMMAND_ONLY_TYPE;

    stringstream temp_strm;

    char temp_filename[] = "/tmp/JJXXXXXX";

    int fd = mkstemp(temp_filename);

    if (fd == -1)
    {
        param->msg_strm.str("");

        param->msg_strm << "ERROR!  In `zzparse':  Rule `statement: SERVER_ZZ "
                        << "SENDING_ZZ KEY_PAIR_ZZ STRING_ZZ':"
                        << endl
                        << "`mkstemp' failed, returning -1:"
                        << endl
                        << strerror(errno)
                        << endl
                        << "Can't store key pair."
                        << endl 
                        << "Will try to continue."
                        << endl;   

        lock_cerr_mutex(); 
        cerr << param->msg_strm.str();
        unlock_cerr_mutex(); 

        err_log_strm << param->msg_strm.str();
        log_strm << param->msg_strm.str();

        param->msg_strm.str("");

        temp_strm.str("");

        temp_strm << "RECEIVE KEY_PAIR FAILED";

        response.command = temp_strm.str();
                        
        temp_strm.str("");

        pthread_mutex_unlock(&param->response_deque_mutex);
        param->response_deque.push_front(response);
        pthread_mutex_unlock(&param->response_deque_mutex);

        ++errors_occurred;

        goto END_SERVER_SENDING_KEY_PAIR;

    }  /* |if (fd == -1)|  */

    else if (param->PARSER_DEBUG)
    {
        cerr << "In `zzparse':  Rule `statement: SERVER_ZZ SENDING_ZZ "
             << "KEY_PAIR_ZZ STRING_ZZ':"
             << endl
             << "`mkstemp' succeeded."
             << endl;   

    }  /* |else if (param->PARSER_DEBUG)|  */ 

@q ***** (5) @>
@
@<Rules@>=

    close(fd);

    status = accept_data(param, 
                         temp_filename,
                         -1, 
                         Response_Type::KEY_PAIR_TYPE);

@q ***** (5) @>
@
@<Rules@>=

    if (status != 0)
    {
        param->msg_strm.str("");

        param->msg_strm << "ERROR!  In `zzparse':  Rule `statement: SERVER_ZZ "
                        << "SENDING_ZZ KEY_PAIR_ZZ STRING_ZZ':"
                        << endl
                        << "`accept_data' failed, returning " << status
                        << endl
                        << "Failed to receive key pair."
                        << endl 
                        << "Will try to continue."
                        << endl;   

        lock_cerr_mutex(); 
        cerr << param->msg_strm.str();
        unlock_cerr_mutex(); 

        err_log_strm << param->msg_strm.str();
        log_strm << param->msg_strm.str();

        param->msg_strm.str("");

        temp_strm.str("");

        temp_strm << "RECEIVE KEY_PAIR FAILED";

        response.command = temp_strm.str();
                        
        temp_strm.str("");

        pthread_mutex_unlock(&param->response_deque_mutex);
        param->response_deque.push_front(response);
        pthread_mutex_unlock(&param->response_deque_mutex);

        ++errors_occurred;
  
        if (!save_temp_files)
           unlink(temp_filename);

        goto END_SERVER_SENDING_KEY_PAIR;

    }  /* |if (status != 0)|  */

@q ***** (5) @>
@
@<Rules@>=

    else 
    {
@q ****** (6) @>
 
        if (param->PARSER_DEBUG)
        {
             lock_cerr_mutex(); 
             cerr << "In `zzparse':  Rule `statement: SERVER_ZZ SENDING_ZZ "
                  << "KEY_PAIR_ZZ STRING_ZZ':"
                  << endl
                  << "`accept_data' succeeded." 
                  << endl;
             unlock_cerr_mutex(); 

             log_strm << "Received key pair successfully." << endl;

             lock_cerr_mutex(); 
             cerr << "Received key pair successfully." << endl;
             unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */

        temp_strm.str("");

        temp_strm << "RECEIVE KEY_PAIR SUCCEEDED";

        response.command = temp_strm.str();

        temp_strm.str("");

        pthread_mutex_unlock(&param->response_deque_mutex);
        param->response_deque.push_front(response);
        pthread_mutex_unlock(&param->response_deque_mutex);

        if (param->PARSER_DEBUG)
        {
             lock_cerr_mutex(); 
             cerr << "In `zzparse':  Rule `statement: SERVER_ZZ SENDING_ZZ "
                  << "KEY_PAIR_ZZ STRING_ZZ':"
                  << endl
                  << "Outputting temporary file `" << temp_filename << "':"
                  << endl;

             string temp_str;
             temp_str = "cat ";
             temp_str += temp_filename;

             system(temp_str.c_str());

             unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */

@q ****** (6) Call |Scan_Parse_Parameter_Type::install_key_pair|.  @>

@ Call |Scan_Parse_Parameter_Type::install_key_pair|.  
\initials{LDF 2011.11.14.}

If |Scan_Parse_Parameter_Type::install_key_pair| fails, an error message is issued and
|errors_occurred| is incremented, but no message is sent to the 
server.  After all, the client received the key pair successfully.
\initials{LDF 2011.11.14.}

\LOG
\initials{LDF 2011.11.14.}
Added this section.
\ENDLOG

@<Rules@>=

        status = param->install_key_pair(@=$4@>, temp_filename);

        if (   (status == 0 || status == 2 || status == 4 || status == 6) 
            && param->PARSER_DEBUG)
        {
             lock_cerr_mutex(); 
             cerr << "In `zzparse':  Rule `statement: SERVER_ZZ SENDING_ZZ KEY_PAIR_ZZ "
                  << "STRING_ZZ':"
                  << endl
                  << "`Scan_Parse_Parameter_Type::install_key_pair' succeeded, " 
                  << "returning " << status << "."
                  << endl;
             unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */

        if (status == 0)
        {
           log_strm << "Installed key pair and set trust value successfully." << endl;

           lock_cerr_mutex(); 
           cerr << "Installed key pair and set trust value successfully." << endl;
           unlock_cerr_mutex(); 
        }
        else if (status == 2)
        {

               log_strm << "Secret and/or public key already installed.  "
                        << "Installed other key, if applicable."
                        << endl 
                        << "Set trust value successfully." << endl;

               lock_cerr_mutex(); 
               cerr << "Secret and/or public key already installed.  "
                    << "Installed other key, if applicable."
                    << endl 
                    << "Set trust value successfully." << endl;    
               unlock_cerr_mutex(); 

        }  /* |else if|  */
        else 
        {
            param->msg_strm.str("");

            param->msg_strm << "ERROR!  In `zzparse':  Rule `statement: SERVER_ZZ SENDING_ZZ "
                            << "KEY_PAIR_ZZ STRING_ZZ':"
                            << endl
                            << "`Scan_Parse_Parameter_Type::install_key_pair' failed, "
                            << "returning " << status
                            << endl
                            << "Will try to continue."
                            << endl;   

            lock_cerr_mutex(); 
            cerr << param->msg_strm.str();
            unlock_cerr_mutex(); 

            err_log_strm << param->msg_strm.str();
            log_strm << param->msg_strm.str();

            param->msg_strm.str("");

            ++errors_occurred;
  
            if (!save_temp_files)
               unlink(temp_filename);

            goto END_SERVER_SENDING_KEY_PAIR;

        }  /* |else|  */

@q ****** (6) @>
@
@<Rules@>=

        if (!save_temp_files)
           unlink(temp_filename);

    }  /* |else|  */ 

@q ***** (5) @>
@
@<Rules@>=

    END_SERVER_SENDING_KEY_PAIR: ;

@q ***** (5) @>

};

@q **** (4) statement --> SERVER_ZZ NOT_ZZ SENDING_ZZ KEY_PAIR_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{NOT\_ZZ} \.{SENDING\_ZZ} 
\.{KEY\_PAIR\_ZZ}.
\initials{LDF 2011.11.10.}

\LOG
\initials{LDF 2011.11.10.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ NOT_ZZ SENDING_ZZ KEY_PAIR_ZZ @>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "In `zzparse':  Rule `statement: SERVER_ZZ NOT_ZZ SENDING_ZZ KEY_PAIR_ZZ'."
             << endl;
        unlock_cerr_mutex(); 
    }
 
    param->msg_strm.str("");

    param->msg_strm << "ERROR!  In `zzparse':  Rule `statement: SERVER_ZZ NOT_ZZ SENDING_ZZ "
                    << "KEY_PAIR_ZZ':"
                    << endl
                    << "Server-side error:  Server not sending key pair."
                    << endl
                    << "Will try to continue."
                    << endl;   

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

    ++errors_occurred;

};

@q *** (3) statement --> SERVER_ZZ NOT_ZZ DISTRIBUTING_ZZ KEY_PAIR_ZZ STRING_ZZ.@>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{NOT\_ZZ} \.{DISTRIBUTING\_ZZ} 
\.{KEY\_PAIR\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2011.11.21.}

\LOG
\initials{LDF 2011.11.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ NOT_ZZ DISTRIBUTING_ZZ KEY_PAIR_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "In `zzparse':  Rule `statement: SERVER_ZZ NOT_ZZ DISTRIBUTING_ZZ "
             << "KEY_PAIR_ZZ STRING_ZZ'."
             << endl;
        unlock_cerr_mutex(); 
    }
 
    param->msg_strm.str("");

    param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: SERVER_ZZ "
                    << "NOT_ZZ DISTRIBUTING_ZZ KEY_PAIR_ZZ STRING_ZZ':"
                    << endl
                    << "Server-side error:  Server not distributing key pair:"
                    << endl
                    << @=$5@>
                    << endl 
                    << "Will try to continue."
                    << endl;   

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

    ++warnings_occurred;

};

@q *** (3) statement --> SERVER_ZZ DISTRIBUTE_ZZ KEY_PAIR_ZZ SUCCEEDED_ZZ @>
@q *** (3) DISTINGUISHED_NAME_ZZ STRING_ZZ GLOBUS_SITE_ZZ                 @>
@q *** (3) STRING_ZZ INTEGER_ZZ.                                          @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{DISTRIBUTE\_ZZ} 
\.{KEY\_PAIR\_ZZ} \.{SUCCEEDED\_ZZ} \.{DISTINGUISHED\_NAME\_ZZ} 
\.{STRING\_ZZ } \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}
\.{INTEGER\_ZZ}.
\initials{LDF 2011.12.07.}

\LOG
\initials{LDF 2011.12.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DISTRIBUTE_ZZ KEY_PAIR_ZZ SUCCEEDED_ZZ @>@/
@=DISTINGUISHED_NAME_ZZ STRING_ZZ GLOBUS_SITE_ZZ STRING_ZZ INTEGER_ZZ@>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "In `zzparse':  Rule `statement: SERVER_ZZ DISTRIBUTE_ZZ "
             << endl 
             << "KEY_PAIR_ZZ SUCCEEDED_ZZ DISTINGUISHED_NAME_ZZ STRING_ZZ "
             << endl 
             << "GLOBUS_SITE_ZZ STRING_ZZ INTEGER_ZZ'."
             << endl
             << "`Key name' == " << @=$6@>
             << endl 
             << "`Globus site' == " << @=$8@>
             << endl
             << "Status code == " << @=$9@>
             << endl;
        unlock_cerr_mutex(); 
    }
 
    param->msg_strm.str("");

    string curr_dn;

    if (!param->effective_user_dn.empty())
       curr_dn = param->effective_user_dn;
    else
       curr_dn = param->user_dn;

    if (param->PARSER_DEBUG)
    {
       lock_cerr_mutex(); 
       cerr << "curr_dn == " << curr_dn << endl;
       unlock_cerr_mutex(); 
    }

    param->msg_strm << "In `zzparse':  Rule `statement: SERVER_ZZ "
                    << "DISTRIBUTE_ZZ KEY_PAIR_ZZ SUCCEEDED_ZZ "
                    << endl 
                    << "DISTINGUISHED_NAME_ZZ STRING_ZZ "
                    << "GLOBUS_SITE_ZZ STRING_ZZ INTEGER_ZZ':"
                    << endl;

    if (@=$9@> == 0)
    {
        param->msg_strm << "Distributed key pair to Globus site `" 
                        << @=$8@> << "' "
                        << "successfully."
                        << endl;   
    }

    else if (@=$9@> == 2)
    {
        param->msg_strm << "Key pair with key name"
                        << endl 
                        << "`" << @=$6@> << "'"
                        << endl 
                        << "already installed on Globus site "
                        << "`" << @=$8@> << "'."
                        << endl
                        << "Not reinstalled."
                        << endl;
    }

    else if (@=$9@> == 3)
    {
        param->msg_strm << "WARNING:  Key pair with key name"
                        << endl 
                        << "`" << @=$6@> << "'"
                        << endl 
                        << "installed successfully on Globus site "
                        << "`" << @=$8@> << "'."
                        << endl
                        << "However, Setting \"owner trust\" on public key failed."
                        << endl;

        ++warnings_occurred;

        err_log_strm << param->msg_strm.str();

    }

    else if (@=$9@> == 4)
    {
        param->msg_strm << "WARNING:  Key pair with key name"
                        << endl 
                        << "`" << @=$6@> << "'"
                        << endl 
                        << "installed successfully on Globus site `" << @=$8@> << "'."
                        << endl
                        << "However, another secret key was already present."
                        << endl
                        << "It may be necessary to sign the new public key "
                        << "in order to be able to use it without being queried."
                        << endl;

        ++warnings_occurred;

        err_log_strm << param->msg_strm.str();

    }

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

};

@q *** (3) statement --> SERVER_ZZ DISTRIBUTE_ZZ KEY_PAIR_ZZ FAILED_ZZ @>
@q *** (3) DISTINGUISHED_NAME_ZZ STRING_ZZ GLOBUS_SITE_ZZ              @>
@q *** (3) STRING_ZZ INTEGER_ZZ.                                       @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{DISTRIBUTE\_ZZ} 
\.{KEY\_PAIR\_ZZ} \.{FAILED\_ZZ} \.{DISTINGUISHED\_NAME\_ZZ} 
\.{STRING\_ZZ } \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2011.12.07.}

\LOG
\initials{LDF 2011.12.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DISTRIBUTE_ZZ KEY_PAIR_ZZ FAILED_ZZ @>@/
@=DISTINGUISHED_NAME_ZZ STRING_ZZ GLOBUS_SITE_ZZ STRING_ZZ INTEGER_ZZ@>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "In `zzparse':  Rule `statement: SERVER_ZZ DISTRIBUTE_ZZ "
             << endl 
             << "KEY_PAIR_ZZ FAILED_ZZ DISTINGUISHED_NAME_ZZ STRING_ZZ "
             << "GLOBUS_SITE_ZZ STRING_ZZ INTEGER_ZZ'."
             << endl
             << "`Key name' == " << @=$6@>
             << endl 
             << "`Globus site' == " << @=$8@>
             << endl
             << "Status code == " << @=$9@>
             << endl;
        unlock_cerr_mutex(); 
    }
 
    param->msg_strm.str("");

    param->msg_strm << "ERROR!  In `zzparse':  Rule `statement: SERVER_ZZ "
                    << "DISTRIBUTE_ZZ KEY_PAIR_ZZ FAILED_ZZ "
                    << endl 
                    << "DISTINGUISHED_NAME_ZZ STRING_ZZ GLOBUS_SITE_ZZ "
                    << endl 
                    << "STRING_ZZ INTEGER_ZZ':"
                    << endl
                    << "Server-side error:  Server failed to distribute key pair "
                    << "with key name `" << @=$6@> << "'"
                    << endl 
                    << "to Globus site " << @=$8@> << "."
                    << endl
                    << "Error code:  " << @=$9@>
                    << endl 
                    << "Will try to continue."
                    << endl;   

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

    ++errors_occurred;

};

@q *** (3) statement --> SERVER_ZZ DELETE_ZZ KEY_PAIR_ZZ @>
@q *** (3) FROM_ZZ DATABASE_ZZ SUCCEEDED_ZZ              @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{DELETE\_ZZ} 
\.{KEY\_PAIR\_ZZ} \.{FROM\_ZZ} \.{DATABASE\_ZZ} \.{SUCCEEDED\_ZZ}.
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DELETE_ZZ KEY_PAIR_ZZ FROM_ZZ DATABASE_ZZ SUCCEEDED_ZZ @>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
   {
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ DELETE_ZZ "
            << "KEY_PAIR_ZZ FROM_ZZ DATABASE_ZZ SUCCEEDED_ZZ'."
            << endl;
   }

   param->msg_strm.str("");

   param->msg_strm << "Server deleted key pair from database successfully."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   param->msg_strm.str("");

};

@q *** (3) statement --> SERVER_ZZ DELETE_ZZ KEY_PAIR_ZZ @>
@q *** (3) FROM_ZZ DATABASE_ZZ FAILED_ZZ                 @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{DELETE\_ZZ} 
\.{KEY\_PAIR\_ZZ} \.{FROM\_ZZ} \.{DATABASE\_ZZ} \.{FAILED\_ZZ}.
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DELETE_ZZ KEY_PAIR_ZZ FROM_ZZ DATABASE_ZZ FAILED_ZZ @>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ DELETE_ZZ "
            << "KEY_PAIR_ZZ FROM_ZZ DATABASE_ZZ FAILED_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Server failed to delete key pair from database."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   ++warnings_occurred;

};

@q *** (3) statement --> SERVER_ZZ DELETE_ZZ KEY_PAIR_ZZ   @>
@q *** (3) FROM_ZZ DATABASE_ZZ FAILED_ZZ NO_ZZ KEY_PAIR_ZZ @>
@q *** (3) IN_ZZ DATABASE_ZZ                               @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{DELETE\_ZZ} 
\.{KEY\_PAIR\_ZZ} \.{FROM\_ZZ} \.{DATABASE\_ZZ} \.{FAILED\_ZZ}
\.{NO\_ZZ} \.{KEY\_PAIR\_ZZ} \.{IN\_ZZ} \.{DATABASE\_ZZ}.
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DELETE_ZZ KEY_PAIR_ZZ FROM_ZZ DATABASE_ZZ FAILED_ZZ @>@/
@=NO_ZZ KEY_PAIR_ZZ IN_ZZ DATABASE_ZZ @>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ DELETE_ZZ "
            << "KEY_PAIR_ZZ FROM_ZZ DATABASE_ZZ FAILED_ZZ "
            << "NO_ZZ KEY_PAIR_ZZ IN_ZZ DATABASE_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Server failed to delete key pair from database:  "
                   << "No key pair in database.  Couldn't delete."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   ++warnings_occurred;

};

@q *** (3) statement --> SERVER_ZZ DELETE_ZZ PUBLIC_KEY_ZZ @>
@q *** (3) FROM_ZZ DATABASE_ZZ SUCCEEDED_ZZ                @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{DELETE\_ZZ} 
\.{PUBLIC\_KEY\_ZZ} \.{FROM\_ZZ} \.{DATABASE\_ZZ} \.{SUCCEEDED\_ZZ}.
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DELETE_ZZ PUBLIC_KEY_ZZ FROM_ZZ DATABASE_ZZ SUCCEEDED_ZZ @>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
   {
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ DELETE_ZZ "
            << "PUBLIC_KEY_ZZ FROM_ZZ DATABASE_ZZ SUCCEEDED_ZZ'."
            << endl;
   }

   param->msg_strm.str("");

   param->msg_strm << "Server deleted public key from database successfully."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   param->msg_strm.str("");

};

@q *** (3) statement --> SERVER_ZZ DELETE_ZZ PUBLIC_KEY_ZZ @>
@q *** (3) FROM_ZZ DATABASE_ZZ FAILED_ZZ                   @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{DELETE\_ZZ} 
\.{PUBLIC\_KEY\_ZZ} \.{FROM\_ZZ} \.{DATABASE\_ZZ} \.{FAILED\_ZZ}.
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DELETE_ZZ PUBLIC_KEY_ZZ FROM_ZZ DATABASE_ZZ FAILED_ZZ @>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ DELETE_ZZ "
            << "PUBLIC_KEY_ZZ FROM_ZZ DATABASE_ZZ FAILED_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Server failed to delete public key from database."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   ++warnings_occurred;

};

@q *** (3) statement --> SERVER_ZZ DELETE_ZZ PUBLIC_KEY_ZZ   @>
@q *** (3) FROM_ZZ DATABASE_ZZ FAILED_ZZ NO_ZZ PUBLIC_KEY_ZZ @>
@q *** (3) IN_ZZ DATABASE_ZZ                                 @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{DELETE\_ZZ} 
\.{PUBLIC\_KEY\_ZZ} \.{FROM\_ZZ} \.{DATABASE\_ZZ} \.{FAILED\_ZZ}
\.{NO\_ZZ} \.{PUBLIC\_KEY\_ZZ} \.{IN\_ZZ} \.{DATABASE\_ZZ}.
\initials{LDF 2011.12.16.}

\LOG
\initials{LDF 2011.12.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DELETE_ZZ PUBLIC_KEY_ZZ FROM_ZZ DATABASE_ZZ FAILED_ZZ @>@/
@=NO_ZZ PUBLIC_KEY_ZZ IN_ZZ DATABASE_ZZ @>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ DELETE_ZZ "
            << "PUBLIC_KEY_ZZ FROM_ZZ DATABASE_ZZ FAILED_ZZ "
            << "NO_ZZ PUBLIC_KEY_ZZ IN_ZZ DATABASE_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Server failed to delete public key from database:  "
                   << "No public key in database.  Couldn't delete."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   ++warnings_occurred;

};

@q **** (4) statement --> SERVER_ZZ SESSION_ID_ZZ STRING_ZZ  @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SESSION\_ID\_ZZ} 
\.{STRING\_ZZ}.
\initials{LDF 2011.12.22.}

Session ids are used when calling \.{optdbcli} from the web application (currently 
\.{test\_js.fcgi}, later most likely \.{optwbsrv}).  The web application generates
the session id consisting of a random string of 15 alphanumeric characters.
\initials{LDF 2011.12.22.}

@:NOTE@> !! PLEASE NOTE:  Currently, this is the only rule that calls |return| 
to return from |zzparse|, in case of an error:
\par
Currently, if the session ids don't match, the client breaks off the connection.  
It does not send a message to the server telling it why.  In order to make this work, 
it would be necessary to add an appropriate constant in |Response_Type|, etc.
@:TODO@> !! TODO:  Do something about this.  Not urgent, however.
\par
The reason it's not urgent is because it's the client that determines the session id for 
both peers:  It's own session id is set using the command-line option \.{--session-id} and
the server's is set using the \.{SESSION\_ID} command with a string argument.
\initials{LDF 2011.12.22.}

\LOG
\initials{LDF 2011.12.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement:  SERVER_ZZ SESSION_ID_ZZ STRING_ZZ @>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ SESSION_ID_ZZ "
            << "STRING_ZZ'."
            << endl;

   if (param->session_id.empty())
      param->session_id = @=$3@>;

   else if (param->session_id != string(@=$3@>))
   {
       param->msg_strm.str("");

       param->msg_strm << "ERROR!  In `zzparse':  Rule `statement:  "
                       << "`SERVER_ZZ SESSION_ID_ZZ "
                       << "STRING_ZZ':"
                       << endl
                       << "Session ID mismatch:"
                       << endl
                       << "Client:  " << param->session_id
                       << endl
                       << "Server:  " << @=$3@>
                       << endl
                       << "Exiting function unsuccessfully with return value 1."
                       << endl;

       cerr << param->msg_strm.str();
       log_strm << param->msg_strm.str();
       err_log_strm << param->msg_strm.str();

       ++errors_occurred;

       param->msg_strm.str("");

       return(1);
   }
   else if (param->PARSER_DEBUG)
   {
       param->msg_strm.str("");

       param->msg_strm << "In `zzparse':  Rule `statement:  "
                       << "`SERVER_ZZ SESSION_ID_ZZ "
                       << "STRING_ZZ':"
                       << endl
                       << "Session IDs match correctly:"
                       << endl
                       << "Client:  " << param->session_id
                       << endl
                       << "Server:  " << @=$3@>
                       << endl;

       cerr << param->msg_strm.str();
       log_strm << param->msg_strm.str();

       param->msg_strm.str("");

   }  /* |else if (param->PARSER_DEBUG)|  */

};

@q **** (4) statement: DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ  @>
@q **** (4) FAILED_ZZ INTEGER_ZZ                                 @>

@ \<statement> $\longrightarrow$ \.{DELETE\_ZZ} \.{ENVIRONMENT\_ZZ} 
\.{SHELLSCRIPTS\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.03.26.}

\LOG
\initials{LDF 2012.03.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ  @>@/
@=FAILED_ZZ INTEGER_ZZ@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ "
            << "FAILED_ZZ INTEGER_ZZ'."
            << endl;

    param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: DELETE_ZZ "
                    << "ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ "
                    << "FAILED_ZZ INTEGER_ZZ':"
                    << endl;

    if (@=$5@> == 0)
       param->msg_strm << "No environment shellscripts to delete."
                       << endl;

    else
       param->msg_strm << "`INTEGER_ZZ' == " << @=$5@> << " (!= 0)."
                       << endl
                       << "A server-side error must have occurred."
                       << endl;

     param->msg_strm << "Continuing."
                     << endl;   

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

    ++warnings_occurred;

@q ***** (5) @>

};

@q **** (4) statement: DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ  @>
@q **** (4) SUCCEEDED_ZZ INTEGER_ZZ                              @>

@ \<statement> $\longrightarrow$ \.{DELETE\_ZZ} \.{ENVIRONMENT\_ZZ} 
\.{SHELLSCRIPTS\_ZZ} \.{SUCCEEDED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.03.26.}

\LOG
\initials{LDF 2012.03.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ @>@/
@=SUCCEEDED_ZZ INTEGER_ZZ@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ "
            << "SUCCEEDED_ZZ INTEGER_ZZ'."
            << endl;
 
    param->msg_strm << "In `zzparse':  Rule `statement: DELETE_ZZ "
                    << "ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ "
                    << "SUCCEEDED_ZZ INTEGER_ZZ':"
                    << endl
                    << "Deleted " << @=$5@> << " environment shellscripts."
                    << endl;

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

@q ***** (5) @>

};

@q **** (4) statement: DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ  @>
@q **** (4) FOR_ZZ GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ INTEGER_ZZ @>

@ \<statement> $\longrightarrow$ \.{DELETE\_ZZ} \.{ENVIRONMENT\_ZZ} 
\.{SHELLSCRIPTS\_ZZ} \.{FOR\_ZZ} \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}
\.{FAILED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.03.21.}

\LOG
\initials{LDF 2012.03.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ FOR_ZZ @>@/
@=GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ INTEGER_ZZ@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ "
            << "FOR_ZZ GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ INTEGER_ZZ'."
            << endl;
 
    if (param->PARSER_DEBUG)
        cerr << "Globus site == " << @=$6@> 
             << endl;

    param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: DELETE_ZZ "
                    << "ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ "
                    << "FOR_ZZ GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ INTEGER_ZZ':"
                    << endl;

    if (@=$8@> == 0)
       param->msg_strm << "No environment shellscripts to delete for "
                       << "Globus site `" << @=$6@> << "'."
                       << endl;

    else
       param->msg_strm << "`INTEGER_ZZ' == " << @=$8@> << " (!= 0)."
                       << endl
                       << "A server-side error must have occurred."
                       << endl;

     param->msg_strm << "Continuing."
                     << endl;   

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

    ++warnings_occurred;

@q ***** (5) @>

};

@q **** (4) statement: DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ     @>
@q **** (4) FOR_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCEEDED_ZZ INTEGER_ZZ @>

@ \<statement> $\longrightarrow$ \.{DELETE\_ZZ} \.{ENVIRONMENT\_ZZ} 
\.{SHELLSCRIPTS\_ZZ} \.{FOR\_ZZ} \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}
\.{SUCCEEDED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.03.21.}

\LOG
\initials{LDF 2012.03.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ FOR_ZZ @>@/
@=GLOBUS_SITE_ZZ STRING_ZZ SUCCEEDED_ZZ INTEGER_ZZ@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ "
            << "FOR_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCEEDED_ZZ INTEGER_ZZ'."
            << endl;
 
    if (param->PARSER_DEBUG)
        cerr << "Globus site == " << @=$6@> 
             << endl;

    param->msg_strm << "In `zzparse':  Rule `statement: DELETE_ZZ "
                    << "ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ "
                    << "FOR_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCEEDED_ZZ INTEGER_ZZ':"
                    << endl
                    << "Deleted " << @=$8@> << " environment shellscripts for "
                    << "Globus site `" << @=$6@> << "'."
                    << endl;

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

@q ***** (5) @>

};

@q **** (4) statement --> SERVER_ZZ  ENVIRONMENT_ZZ SHELLSCRIPT_ZZ  @>
@q **** (4) USER_ZZ NOT_ZZ ADMIN_ZZ FOR_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{ENVIRONMENT\_ZZ} 
\.{SHELLSCRIPT\_ZZ} \.{USER\_ZZ} \.{NOT\_ZZ} \.{ADMIN\_ZZ} \.{FOR\_ZZ} 
\.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.03.23.}

\LOG
\initials{LDF 2012.03.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ @>@/
@=USER_ZZ NOT_ZZ ADMIN_ZZ FOR_ZZ GLOBUS_SITE_ZZ STRING_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ "
            << "ENVIRONMENT_ZZ SHELLSCRIPT_ZZ USER_ZZ NOT_ZZ ADMIN_ZZ FOR_ZZ "
            << "GLOBUS_SITE_ZZ STRING_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  User not admin for Globus site `" << @=$9@> << "'."
                   << endl 
                   << "Server will try to store environment shellscript without `admin' flag."
                   << endl 
                   << "Continuing." << endl;

   cerr << param->msg_strm.str();
   
   err_log_strm << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   ++warnings_occurred;

   param->msg_strm.str("");

};

@q **** (4) statement: DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ  @>
@q **** (4) INTEGER_ZZ FAILED_ZZ                                @>

@ \<statement> $\longrightarrow$ \.{DELETE\_ZZ} \.{ENVIRONMENT\_ZZ} 
\.{SHELLSCRIPT\_ZZ} \.{INTEGER\_ZZ} \.{FAILED\_ZZ}.
\initials{LDF 2012.03.26.}

\LOG
\initials{LDF 2012.03.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ INTEGER_ZZ @>@/
@=FAILED_ZZ@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
            << "INTEGER_ZZ FAILED_ZZ'."
            << endl;
 
    param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: DELETE_ZZ "
                    << "ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
                    << "INTEGER_ZZ FAILED_ZZ':"
                    << endl
                    << "Continuing."
                    << endl;   

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

    ++warnings_occurred;

@q ***** (5) @>

};

@q **** (4) statement: DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ  @>   
@q **** (4) INTEGER_ZZ SUCCEEDED_ZZ.                            @>

@ \<statement> $\longrightarrow$ \.{DELETE\_ZZ} \.{ENVIRONMENT\_ZZ} 
\.{SHELLSCRIPT\_ZZ} \.{INTEGER\_ZZ} \.{SUCCEEDED\_ZZ}.
\initials{LDF 2012.03.26.}

\LOG
\initials{LDF 2012.03.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ INTEGER_ZZ @>@/
@=SUCCEEDED_ZZ@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `DELETE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
            << "INTEGER_ZZ SUCCEEDED_ZZ'."
            << endl;
 
    param->msg_strm << "In `zzparse':  Rule `statement: DELETE_ZZ "
                    << "ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
                    << "INTEGER_ZZ SUCCEEDED_ZZ':"
                    << endl
                    << "Deleted environment shellscript " << @=$4@> << "."
                    << endl;

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

@q ***** (5) @>

};

@q **** (4) statement:  SERVER_ZZ SHOW_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ FAILED_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SHOW\_ZZ} 
\.{ENVIRONMENT\_ZZ} \.{SHELLSCRIPTS\_ZZ} \.{FAILED\_ZZ}.
\initials{LDF 2012.03.23.}

\LOG
\initials{LDF 2012.03.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SHOW_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ FAILED_ZZ @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ SHOW_ZZ "
             << "ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ FAILED_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->msg_strm.str("");

    param->msg_strm << "ERROR!  In `zzparse':  "
                    << "Rule `statement:  SERVER_ZZ SHOW_ZZ ENVIRONMENT_ZZ "
                    << "SHELLSCRIPTS_ZZ FAILED_ZZ':  "
                    << "Can't show environment shellscripts.  Continuing."
                    << endl;

    cerr << param->msg_strm.str();
    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    ++errors_occurred;

    param->msg_strm.str("");

};

@q **** (4) statement:  SERVER_ZZ NO_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ TO_ZZ SHOW_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{NO\_ZZ} 
\.{ENVIRONMENT\_ZZ} \.{SHELLSCRIPTS\_ZZ} \.{TO\_ZZ SHOW\_ZZ}.
\initials{LDF 2012.03.23.}

\LOG
\initials{LDF 2012.03.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ NO_ZZ ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ TO_ZZ SHOW_ZZ @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ NO_ZZ "
             << "ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ TO_ZZ SHOW_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->msg_strm.str("");

    param->msg_strm << "WARNING!  In `zzparse':  "
                    << "Rule `statement:  SERVER_ZZ NO_ZZ "
                    << "ENVIRONMENT_ZZ SHELLSCRIPTS_ZZ TO_ZZ SHOW_ZZ':  "
                    << "No environment shellscripts to show.  Continuing."
                    << endl;

    cerr << param->msg_strm.str();
    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    ++warnings_occurred;

    param->msg_strm.str("");

};

@q **** (4) statement:  SERVER_ZZ SENDING_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ INFO_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SENDING\_ZZ} \.{ENVIRONMENT\_ZZ} 
\.{SHELLSCRIPT\_ZZ} \.{INFO\_ZZ}.
\initials{LDF 2012.03.23.}

\LOG
\initials{LDF 2012.03.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SENDING_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ INFO_ZZ @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ SENDING_ZZ "
             << "ENVIRONMENT_ZZ SHELLSCRIPT_ZZ INFO_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    int status = accept_data(param, 
                             0,
                             -1, 
                             Response_Type::SHOW_ENVIRONMENT_SHELLSCRIPTS_TYPE);

};

@q **** (4) statement: ENABLE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ  @>
@q **** (4) INTEGER_ZZ FAILED_ZZ INTEGER_ZZ                     @>

@ \<statement> $\longrightarrow$ \.{ENABLE\_ZZ} \.{ENVIRONMENT\_ZZ} 
\.{SHELLSCRIPT\_ZZ} \.{INTEGER\_ZZ} \.{FAILED\_ZZ} \.{INTEGER\_ZZ}. 
\initials{LDF 2012.03.26.}

\LOG
\initials{LDF 2012.03.26.}
Added this rule.
\ENDLOG

@:TODO@> !! TODO:  Add code for interpreting the error codes (i.e., the
last \.{INTEGER\_ZZ}).  See |Scan_Parse_Parameter_Type::enable_environment_shellscript|
in \filename{spptenvf.web}.
\initials{LDF 2012.03.26.}

@<Rules@>=

@=statement: ENABLE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ INTEGER_ZZ @>@/
@=FAILED_ZZ INTEGER_ZZ@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `ENABLE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
            << "INTEGER_ZZ FAILED_ZZ INTEGER_ZZ'."
            << endl;
 
    if (@=$6@> == 1)
          param->msg_strm << "WARNING:  Environment shellscript " << @=$4@> << " already "
                          << "enabled." << endl;
    else
       param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: ENABLE_ZZ "
                       << "ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
                       << "INTEGER_ZZ FAILED_ZZ INTEGER_ZZ':"
                       << endl
                       << "Server failed to enable environment shellscript "
                       << @=$4@> << ".  Continuing."
                       << endl;   

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

    ++warnings_occurred;

@q ***** (5) @>

};

@q **** (4) statement: DISABLE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ  @>
@q **** (4) INTEGER_ZZ FAILED_ZZ INTEGER_ZZ                     @>

@ \<statement> $\longrightarrow$ \.{DISABLE\_ZZ} \.{ENVIRONMENT\_ZZ} 
\.{SHELLSCRIPT\_ZZ} \.{INTEGER\_ZZ} \.{FAILED\_ZZ} \.{INTEGER\_ZZ}. 
\initials{LDF 2012.03.26.}

\LOG
\initials{LDF 2012.03.26.}
Added this rule.
\ENDLOG

@:TODO@> !! TODO:  Add code for interpreting the error codes (i.e., the
last \.{INTEGER\_ZZ}).  See |Scan_Parse_Parameter_Type::enable_environment_shellscript|
in \filename{spptenvf.web}.
\initials{LDF 2012.03.26.}

@<Rules@>=

@=statement: DISABLE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ INTEGER_ZZ @>@/
@=FAILED_ZZ INTEGER_ZZ@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `DISABLE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
            << "INTEGER_ZZ FAILED_ZZ INTEGER_ZZ'."
            << endl;

    if (@=$6@> == 1)
       param->msg_strm << "WARNING:  Environment shellscript " << @=$4@> << " already "
                          << "disabled." << endl;
    else
       param->msg_strm << "WARNING!  In `zzparse':  Rule `statement: DISABLE_ZZ "
                       << "ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
                       << "INTEGER_ZZ FAILED_ZZ INTEGER_ZZ':"
                       << endl
                       << "Server failed to disable environment shellscript "
                       << @=$4@> << ".  Continuing."
                       << endl;   

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

    ++warnings_occurred;

@q ***** (5) @>

};

@q **** (4) statement: ENABLE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ  @>
@q **** (4) INTEGER_ZZ SUCCEEDED_ZZ                             @>

@ \<statement> $\longrightarrow$ \.{ENABLE\_ZZ} \.{ENVIRONMENT\_ZZ} 
\.{SHELLSCRIPT\_ZZ} \.{INTEGER\_ZZ} \.{SUCCEEDED\_ZZ}.
\initials{LDF 2012.03.26.}

\LOG
\initials{LDF 2012.03.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: ENABLE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ INTEGER_ZZ @>@/
@=SUCCEEDED_ZZ@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `ENABLE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
            << "INTEGER_ZZ SUCCEEDED_ZZ'."
            << endl;

    param->msg_strm << "Enabled environment shellscript " << @=$4@> 
                    << " successfully." << endl;
     
    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

@q ***** (5) @>

};

@q **** (4) statement: DISABLE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ  @>
@q **** (4) INTEGER_ZZ SUCCEEDED_ZZ                              @>

@ \<statement> $\longrightarrow$ \.{DISABLE\_ZZ} \.{ENVIRONMENT\_ZZ} 
\.{SHELLSCRIPT\_ZZ} \.{INTEGER\_ZZ} \.{SUCCEEDED\_ZZ}. 
\initials{LDF 2012.03.26.}

\LOG
\initials{LDF 2012.03.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DISABLE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ INTEGER_ZZ @>@/
@=SUCCEEDED_ZZ@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `DISABLE_ZZ ENVIRONMENT_ZZ SHELLSCRIPT_ZZ "
            << "INTEGER_ZZ SUCCEEDED_ZZ'."
            << endl;

    param->msg_strm << "Disabled environment shellscript " << @=$4@> 
                    << " successfully." << endl;

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

@q ***** (5) @>

};

@q *** (3) statement --> SERVER_ZZ ADD_ZZ GLOBUS_SITE_ZZ @>
@q *** (3) STRING_ZZ TO_ZZ DATABASE_ZZ SUCCEEDED_ZZ      @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{ADD\_ZZ} 
\.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} \.{TO\_ZZ} \.{DATABASE\_ZZ} \.{SUCCEEDED\_ZZ}
\.{INTEGER\_ZZ}.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ ADD_ZZ GLOBUS_SITE_ZZ STRING_ZZ TO_ZZ DATABASE_ZZ @>@/
@= SUCCEEDED_ZZ INTEGER_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
   {
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ ADD_ZZ "
            << "GLOBUS_SITE_ZZ STRING_ZZ TO_ZZ DATABASE_ZZ "
            << "SUCCEEDED_ZZ INTEGER_ZZ'."
            << endl
            << "`INTEGER_ZZ' == " << @=$8@>
            << endl;
   }

   param->msg_strm.str("");

   if (@=$8@> == 1)
      param->msg_strm << "Server replaced Globus site `" << @=$4@> 
                      << "' in database successfully." << endl;

   else
     param->msg_strm << "Server added Globus site `" << @=$4@> 
                      << "' to database successfully." << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   param->msg_strm.str("");

};

@q *** (3) statement --> SERVER_ZZ ADD_ZZ GLOBUS_SITE_ZZ    @>
@q *** (3) STRING_ZZ TO_ZZ DATABASE_ZZ FAILED_ZZ INTEGER_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{ADD\_ZZ} 
\.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} \.{TO\_ZZ} \.{DATABASE\_ZZ} \.{FAILED\_ZZ}
\.{INTEGER\_ZZ}.
\initials{LDF 2012.04.12.}

\LOG
\initials{LDF 2012.04.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ ADD_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>@/
@=TO_ZZ DATABASE_ZZ FAILED_ZZ INTEGER_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
   {
       cerr << "In `zzparse':  Rule `statement:  `SERVER_ZZ ADD_ZZ "
            << "GLOBUS_SITE_ZZ STRING_ZZ TO_ZZ DATABASE_ZZ FAILED_ZZ INTEGER_ZZ'."
            << endl
            << "`INTEGER_ZZ' == " << @=$8@>
            << endl;
   }

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Server failed to add Globus site `" 
                   << @=$4@> << "' to database:"
                   << endl;

   if (@=$8@> == 1)
       param->msg_strm << "Server-side MySQL API function error.";

   else if (@=$8@> == 2)
       param->msg_strm << "No data found for user in `Privileges' database table "
                       << "and not replacing."
                       << endl
                       << "(If not replacing, no checking is performed to determine whether "
                       << "user is admin of an existing Globus site.)";

   else if (@=$8@> == 3)
       param->msg_strm << "User not permitted to add Globus sites and not replacing."
                       << endl
                       << "(If not replacing, no checking is performed to determine whether "
                       << "user is admin of an existing Globus site.)";

   else if (@=$8@> == 4)
       param->msg_strm << "Data already exists for Globus site `" 
                       << @=$4@> << "' in `Globus_Sites' database table "
                       << "and not replacing.";

   else if (@=$8@> == 5 || @=$8@> == 6)
       param->msg_strm << "Server failed to retrieve Globus site ID from "
                       << "`Globus_Sites' database table.";

   else if (@=$8@> == 7)
       param->msg_strm << "User not permitted to add Globus sites and not "
                       << "admin of the existing "
                       << "Globus site `" << @=$4@> << "'.  Server can't replace.";

   else if (@=$8@> == 8)
       param->msg_strm << "Options specified would cause no change to existing database entry "
                       << "for Globus site `" << @=$4@> << "'.  Not replaced.";
   else
       param->msg_strm << "Unspecified error.";

   param->msg_strm << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");

   ++warnings_occurred;

};

@q **** (4) statement:  SERVER_ZZ SHOW_ZZ GLOBUS_ZZ SITES_ZZ FAILED_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SHOW\_ZZ} 
\.{GLOBUS\_SITES\_ZZ} \.{FAILED\_ZZ}.
\initials{LDF 2012.04.13.}

\LOG
\initials{LDF 2012.04.13.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SHOW_ZZ GLOBUS_SITES_ZZ FAILED_ZZ @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ SHOW_ZZ "
             << "GLOBUS_SITES_ZZ FAILED_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->msg_strm.str("");

    param->msg_strm << "ERROR!  In `zzparse':  "
                    << "Rule `statement:  SERVER_ZZ SHOW_ZZ GLOBUS_ZZ "
                    << "SITES_ZZ FAILED_ZZ':  "
                    << "Can't show Globus sites.  Continuing."
                    << endl;

    cerr << param->msg_strm.str();
    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    ++errors_occurred;

    param->msg_strm.str("");

};

@q **** (4) statement:  SERVER_ZZ NO_ZZ GLOBUS_SITES_ZZ TO_ZZ SHOW_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{NO\_ZZ} 
\.{GLOBUS\_SITES\_ZZ} \.{TO\_ZZ SHOW\_ZZ}.
\initials{LDF 2012.04.13.}

\LOG
\initials{LDF 2012.04.13.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ NO_ZZ GLOBUS_SITES_ZZ TO_ZZ SHOW_ZZ @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ NO_ZZ "
             << "GLOBUS_SITES_ZZ TO_ZZ SHOW_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->msg_strm.str("");

    param->msg_strm << "WARNING!  In `zzparse':  "
                    << "Rule `statement:  SERVER_ZZ NO_ZZ "
                    << "GLOBUS_SITES_ZZ TO_ZZ SHOW_ZZ':  "
                    << "No Globus sites to show.  Continuing."
                    << endl;

    cerr << param->msg_strm.str();
    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    ++warnings_occurred;

    param->msg_strm.str("");

};

@q **** (4) statement:  SERVER_ZZ SENDING_ZZ GLOBUS_SITE_ZZ INFO_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SENDING\_ZZ} 
\.{GLOBUS\_SITE\_ZZ} \.{INFO\_ZZ}.
\initials{LDF 2012.04.13.}

\LOG
\initials{LDF 2012.04.13.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SENDING_ZZ GLOBUS_SITE_ZZ INFO_ZZ @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ SENDING_ZZ "
             << "GLOBUS_SITE_ZZ INFO_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    int status = accept_data(param, 
                             0,
                             -1, 
                             Response_Type::SHOW_GLOBUS_SITES_TYPE);

};

@q **** (4) statement:  SERVER_ZZ DELETE_ZZ GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ INTEGER_ZZ@>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{DELETE\_ZZ} 
\.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} \.{FAILED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DELETE_ZZ GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ INTEGER_ZZ@>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ DELETE_ZZ "
             << "GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ INTEGER_ZZ'." 
             << endl 
             << "`STRING_ZZ' == " << @=$4@>
             << endl
             << "`INTEGER_ZZ' == " << @=$6@>
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->msg_strm.str("");

    param->msg_strm << "WARNING!  In `zzparse':  "
                    << "`statement:  SERVER_ZZ DELETE_ZZ "
                    << "GLOBUS_SITE_ZZ STRING_ZZ FAILED_ZZ INTEGER_ZZ':" 
                    << endl 
                    << "Server failed to delete Globus site `" << @=$4@> << "':"
                    << endl;

    if (@=$6@> == 1)
    {
        param->msg_strm << "Server-side MySQL error." << endl;
    }
    else if (@=$6@> == 2)
    {
        param->msg_strm << "No data found for Globus site `" << @=$4@> << "'."
                        << endl;
    }
    else if (@=$6@> == 3)
    {
        param->msg_strm << "User not admin of Globus site `" << @=$4@> << "' "
                        << "and not otherwise entitled to delete Globus sites."
                        << endl;
    }
    else if (@=$6@> == 4)
    {
        param->msg_strm << "Server-side error checking privileges."
                        << endl;
    }
    else 
    {

        param->msg_strm << "Unspecified server-side error." << endl;
    }

    cerr << param->msg_strm.str();
    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    ++warnings_occurred;

    param->msg_strm.str("");

};

@q **** (4) statement:  SERVER_ZZ DELETE_ZZ GLOBUS_SITES_ZZ FAILED_ZZ INTEGER_ZZ@>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{DELETE\_ZZ} 
\.{GLOBUS\_SITES\_ZZ} \.{FAILED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DELETE_ZZ GLOBUS_SITES_ZZ FAILED_ZZ INTEGER_ZZ@>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ DELETE_ZZ "
             << "GLOBUS_SITES_ZZ FAILED_ZZ INTEGER_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->msg_strm.str("");

    param->msg_strm << "WARNING!  In `zzparse':  "
                    << "`statement:  SERVER_ZZ DELETE_ZZ "
                    << "GLOBUS_SITES_ZZ FAILED_ZZ INTEGER_ZZ':" 
                    << endl 
                    << "Server failed to delete Globus sites:"
                    << endl;

    if (@=$5@> == 0)
    {
        param->msg_strm << "No Globus sites specified." << endl;
    }
    if (@=$5@> == 1)
    {
        param->msg_strm << "Server-side MySQL error." << endl;
    }
    else if (@=$5@> == 2)
    {
        param->msg_strm << "No data found for the specified Globus sites." << endl;
    }
    else if (@=$5@> == 4)
    {
        param->msg_strm << "Server-side error checking privileges."
                        << endl;
    }
    else 
    {
        param->msg_strm << "Unspecified server-side error." << endl;
    }

    cerr << param->msg_strm.str();
    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    ++warnings_occurred;

    param->msg_strm.str("");

};

@q **** (4) statement:  SERVER_ZZ DELETE_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCEEDED_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{DELETE\_ZZ} 
\.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} \.{SUCCEEDED\_ZZ}.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ DELETE_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCEEDED_ZZ@>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ DELETE_ZZ "
             << "GLOBUS_SITE_ZZ STRING_ZZ SUCCEEDED_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->msg_strm.str("");

    param->msg_strm << "Server deleted Globus site `" << @=$4@> 
                    << "' successfully."
                    << endl;

    cerr << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

};

@q **** (4) |add_or_delete|.  @>

@ \<add or delete>.
\initials{LDF 2012.05.02.}

\LOG
\initials{LDF 2012.05.02.}
Added this section.
\ENDLOG

@<Type declarations for non-terminal symbols@>=
@=%type <int_value> add_or_delete@>@/

@q ***** (5) add_or_delete: ADD_ZZ  @>

@ \<add or delete> $\longrightarrow$ \.{ADD\_ZZ}.
\initials{LDF 2012.05.02.}

\LOG
\initials{LDF 2012.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=
@=add_or_delete: ADD_ZZ@>
{

   @=$$@> = 0;

};

@q ***** (5) add_or_delete: DELETE_ZZ  @>

@ \<add or delete> $\longrightarrow$ \.{DELETE\_ZZ}.
\initials{LDF 2012.05.02.}

\LOG
\initials{LDF 2012.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=
@=add_or_delete: DELETE_ZZ@>
{

   @=$$@> = 1;

};

@q **** (4) statement:  SERVER_ZZ add_or_delete ADMIN_ZZ GLOBUS_SITE_ZZ @>
@q **** (4) STRING_ZZ USER_ZZ INTEGER_ZZ FAILED_ZZ INTEGER_ZZ           @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \<add or delete>
\.{ADMIN\_ZZ} \.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} 
\.{USER\_ZZ} \.{INTEGER\_ZZ} \.{FAILED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ add_or_delete ADMIN_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>@/
@=USER_ZZ INTEGER_ZZ FAILED_ZZ INTEGER_ZZ@>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ add_or_delete "
             << "ADMIN_ZZ GLOBUS_SITE_ZZ STRING_ZZ USER_ZZ INTEGER_ZZ FAILED_ZZ INTEGER_ZZ'."
             << endl
             << "`add_or_delete' == " << @=$2@>
             << endl 
             << "`INTEGER_ZZ' == " << @=$9@>
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    string action_str;

    if (@=$2@> == 0)
       action_str = "add";
    else
       action_str = "delete";

    param->msg_strm.str("");

    stringstream temp_strm;

    string error_or_warning;

    if (@=$9@> == 1)
    {
       temp_strm << "Server-side MySQL error.";
       ++errors_occurred;
       error_or_warning = "ERROR!";
    }
    else if (@=$9@> == 2)
    {
       temp_strm << "User not allowed to " << action_str 
                       << " admin for Globus site `" << @=$5@> << "'.";

       ++errors_occurred;
       error_or_warning = "ERROR!";
 
    }
    else if (@=$9@> == 3)
    {
       temp_strm << "No data for user " << @=$7@> << " in `Users' database table.";
       ++errors_occurred;
       error_or_warning = "ERROR!";

    }

    else if (@=$2@> == 0 && @=$9@> == 4 )
    {
       temp_strm << "User " << @=$7@> 
                       << " is already admin for Globus site `" << @=$5@> << "'.  "
                       << "Not set again.";
       ++warnings_occurred;
       error_or_warning = "WARNING!";
    }

    else if (@=$2@> == 1 && @=$9@> == 4 )
    {
       temp_strm << "User " << @=$7@> 
                       << " is not admin for Globus site `" << @=$5@> << "'.  "
                       << "Not deleted.";
       ++warnings_occurred;
       error_or_warning = "WARNING!";

    }
    else 
    {
        temp_strm << "Unspecified server-side error.";
        ++errors_occurred;
       error_or_warning = "ERROR!";
    }    

    param->msg_strm << "[Thread " << param->thread_ctr 
         << "] " << error_or_warning << "  In `zzparse':  `statement:  SERVER_ZZ add_or_delete "
         << "ADMIN_ZZ GLOBUS_SITE_ZZ STRING_ZZ USER_ZZ INTEGER_ZZ FAILED_ZZ INTEGER_ZZ':"
         << endl
         << temp_strm.str() << endl;

    lock_cerr_mutex();
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    log_strm << param->msg_strm.str();
    err_log_strm << param->msg_strm.str();

    param->msg_strm.str("");

};

@q **** (4) statement:  SERVER_ZZ add_or_delete ADMIN_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>
@q **** (4) USER_ZZ INTEGER_ZZ SUCCEEDED_ZZ                                       @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \<add or delete> \.{ADMIN\_ZZ}  
\.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} \.{USER\_ZZ} \.{INTEGER\_ZZ} \.{SUCCEEDED\_ZZ}.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ add_or_delete ADMIN_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>@/
@=USER_ZZ INTEGER_ZZ SUCCEEDED_ZZ@>

{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ add_or_delete "
             << "ADMIN_ZZ GLOBUS_SITE_ZZ STRING_ZZ USER_ZZ INTEGER_ZZ SUCCEEDED_ZZ'." 
             << endl
             << "`add_or_delete' == " << @=$2@>
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    string action_str = (@=$2@> == 0) ? "added" : "deleted";

    param->msg_strm << "Server " << action_str << " user " << @=$7@> 
                    << " as admin of Globus site `" << @=$5@> << "' successfully."
                    << endl;
 
    lock_cerr_mutex();
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

};

@q **** (4) statement --> MARKED_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>
@q **** (4)               AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ   @>

@ \<statement> $\longrightarrow$ \.{MARKED\_ZZ} \.{GLOBUS\_SITE\_ZZ}
\.{STRING\_ZZ} \.{AS\_ZZ} \.{DELETED\_ZZ} \.{SUCCESSFULLY\_ZZ}.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: MARKED_ZZ GLOBUS_SITE_ZZ STRING_ZZ AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ @> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`MARKED_ZZ GLOBUS_SITE_ZZ STRING_ZZ "
            << "AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Marked Globus site `" << @=$3@> << "' as deleted successfully."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

};

@q **** (4) statement --> UNMARKED_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>
@q **** (4)               AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ     @>

@ \<statement> $\longrightarrow$ \.{UNMARKED\_ZZ} \.{GLOBUS\_SITE\_ZZ}
\.{STRING\_ZZ}\.{AS\_ZZ} \.{DELETED\_ZZ} \.{SUCCESSFULLY\_ZZ}.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: UNMARKED_ZZ GLOBUS_SITE_ZZ STRING_ZZ AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ @> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`UNMARKED_ZZ GLOBUS_SITE_ZZ STRING_ZZ "
            << "AS_ZZ DELETED_ZZ SUCCESSFULLY_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Unmarked Globus site `" << @=$3@> << "' as deleted successfully."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

};

@q **** (4) statement --> FAILED_ZZ TO_ZZ MARK_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>
@q **** (4) AS_ZZ DELETED_ZZ INTEGER_ZZ                                    @>

@ \<statement> $\longrightarrow$ \.{FAILED\_ZZ} \.{TO\_ZZ} \.{MARK\_ZZ} 
\.{GLOBUS\_SITE\_ZZ}\.{STRING\_ZZ}\.{AS\_ZZ} \.{DELETED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: FAILED_ZZ TO_ZZ MARK_ZZ GLOBUS_SITE_ZZ STRING_ZZ AS_ZZ DELETED_ZZ @>@/
@=INTEGER_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`FAILED_ZZ TO_ZZ MARK_ZZ GLOBUS_SITE_ZZ STRING_ZZ AS_ZZ DELETED_ZZ "
            << "INTEGER_ZZ'."
            << endl 
            << "`INTEGER_ZZ' == " << @=$8@>
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Failed to mark Globus site `" << @=$5@> 
                   << "' as deleted:"
                   << endl;

   if (@=$8@> == 0)
      param->msg_strm << "Globus site `" << @=$5@> << "' not found in database."
                      << endl;

   else if (@=$8@> == 1)
      param->msg_strm << "Server-side MySQL error." << endl;

   else if (@=$8@> == 2)
      param->msg_strm << "User does not have permission to "
                      << "mark Globus site `" << @=$5@> << "' as deleted." << endl;

   else 
      param->msg_strm << "Unspecified server-side error." << endl;

   param->msg_strm << "Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

   ++warnings_occurred;

};

@q **** (4) statement --> FAILED_ZZ TO_ZZ UNMARK_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>
@q **** (4) AS_ZZ DELETED_ZZ INTEGER_ZZ                                      @>

@ \<statement> $\longrightarrow$ \.{FAILED\_ZZ} \.{TO\_ZZ} \.{UNMARK\_ZZ} 
\.{GLOBUS\_SITE\_ZZ} \.{STRING\_ZZ} \.{AS\_ZZ} \.{DELETED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.04.16.}

\LOG
\initials{LDF 2012.04.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: FAILED_ZZ TO_ZZ UNMARK_ZZ GLOBUS_SITE_ZZ STRING_ZZ AS_ZZ DELETED_ZZ @>@/
@=INTEGER_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`FAILED_ZZ TO_ZZ UNMARK_ZZ GLOBUS_SITE_ZZ STRING_ZZ AS_ZZ DELETED "
            << "INTEGER_ZZ'."
            << endl 
            << "`INTEGER_ZZ' == " << @=$8@>
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Failed to unmark Globus site `" << @=$5@> 
                   << "' as deleted:" << endl;

   if (@=$8@> == 0)
      param->msg_strm << "Globus site `" << @=$5@> << "' not found in database."
                      << endl;

   else if (@=$8@> == 1)
      param->msg_strm << "Server-side MySQL error." << endl;

   else if (@=$8@> == 2)
      param->msg_strm << "User does not have permission to "
                      << "unmark Globus site `" << @=$5@> << "' as deleted." << endl;

   else 
      param->msg_strm << "Unspecified server-side error." << endl;

   param->msg_strm << "Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

   ++warnings_occurred;

};

@q **** (4) statement --> ENABLED_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCESSFULLY_ZZ  @>

@ \<statement> $\longrightarrow$ \.{ENABLED\_ZZ} \.{GLOBUS\_SITE\_ZZ}
\.{STRING\_ZZ} \.{SUCCESSFULLY\_ZZ}.
\initials{LDF 2012.04.30.}

\LOG
\initials{LDF 2012.04.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: ENABLED_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCESSFULLY_ZZ @> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`ENABLED_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCESSFULLY_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Enabled Globus site `" << @=$3@> << "' successfully."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

};

@q **** (4) statement --> FAILED_ZZ TO_ZZ ENABLE_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>
@q **** (4) INTEGER_ZZ                                                       @>

@ \<statement> $\longrightarrow$ \.{FAILED\_ZZ} \.{TO\_ZZ} \.{ENABLE\_ZZ} 
\.{GLOBUS\_SITE\_ZZ}\.{STRING\_ZZ}\.{AS\_ZZ} \.{DELETED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.04.30.}

\LOG
\initials{LDF 2012.04.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: FAILED_ZZ TO_ZZ ENABLE_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>@/
@=INTEGER_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`FAILED_ZZ TO_ZZ ENABLE_ZZ GLOBUS_SITE_ZZ STRING_ZZ "
            << "INTEGER_ZZ'."
            << endl 
            << "`INTEGER_ZZ' == " << @=$6@>
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Failed to enable Globus site `" << @=$5@> 
                   << "':"
                   << endl;

   if (@=$6@> == 0)
      param->msg_strm << "Globus site `" << @=$5@> << "' not found in database."
                      << endl;
   else if (@=$6@> == 1)
      param->msg_strm << "Server-side MySQL error." << endl;

   else if (@=$6@> == 2)
      param->msg_strm << "Globus site `" << @=$5@> << "' is already enabled."
                      << endl;
   else if (@=$6@> == 3)
      param->msg_strm << "Server-side error checking privileges."
                      << endl;
   else if (@=$6@> == 4)
      param->msg_strm << "User not permitted to enable Globus site `" 
                      << @=$5@> << "'."
                      << endl;
   else 
      param->msg_strm << "Unspecified server-side error." << endl;

   param->msg_strm << "Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

   ++warnings_occurred;

};

@q **** (4) statement --> DISABLED_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCESSFULLY_ZZ  @>

@ \<statement> $\longrightarrow$ \.{DISABLED\_ZZ} \.{GLOBUS\_SITE\_ZZ}
\.{STRING\_ZZ} \.{SUCCESSFULLY\_ZZ}.
\initials{LDF 2012.04.30.}

\LOG
\initials{LDF 2012.04.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DISABLED_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCESSFULLY_ZZ @> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`DISABLED_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCESSFULLY_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Disabled Globus site `" << @=$3@> << "' successfully."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

};

@q **** (4) statement --> FAILED_ZZ TO_ZZ DISABLE_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>
@q **** (4) INTEGER_ZZ                                                        @>

@ \<statement> $\longrightarrow$ \.{FAILED\_ZZ} \.{TO\_ZZ} \.{DISABLE\_ZZ} 
\.{GLOBUS\_SITE\_ZZ}\.{STRING\_ZZ}\.{AS\_ZZ} \.{DELETED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.04.30.}

\LOG
\initials{LDF 2012.04.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: FAILED_ZZ TO_ZZ DISABLE_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>@/
@=INTEGER_ZZ@>
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`FAILED_ZZ TO_ZZ DISABLE_ZZ GLOBUS_SITE_ZZ STRING_ZZ "
            << "INTEGER_ZZ'."
            << endl 
            << "`INTEGER_ZZ' == " << @=$6@>
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Failed to disable Globus site `" << @=$5@> 
                   << "':"
                   << endl;

   if (@=$6@> == 0)
      param->msg_strm << "Globus site `" << @=$5@> << "' not found in database."
                      << endl;

   else if (@=$6@> == 1)
      param->msg_strm << "Server-side MySQL error." << endl;

   else if (@=$6@> == 2)
      param->msg_strm << "Globus site `" << @=$5@> << "' is already disabled."
                      << endl;
   else if (@=$6@> == 3)
      param->msg_strm << "Server-side error checking privileges."
                      << endl;
   else if (@=$6@> == 4)
      param->msg_strm << "User not permitted to disable Globus site `" 
                      << @=$5@> << "'."
                      << endl;
   else 
      param->msg_strm << "Unspecified server-side error." << endl;

   param->msg_strm << "Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

   ++warnings_occurred;

};

@q **** (4) statement --> SERVER_ZZ NOT_ZZ SHOWING_ZZ GLOBUS_SITE_ZZ INFO_ZZ STRING_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{NOT\_ZZ} \.{SHOWING\_ZZ} 
\.{INFO\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.05.02.}

\LOG
\initials{LDF 2012.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ NOT_ZZ SHOWING_ZZ GLOBUS_SITE_ZZ INFO_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type *param 
       =  static_cast<Scan_Parse_Parameter_Type*>(
             zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "In `zzparse':  Rule `statement: SERVER_ZZ NOT_ZZ SHOWING_ZZ "
             << "GLOBUS_SITE_ZZ INFO_ZZ STRING_ZZ'."
             << endl;
        unlock_cerr_mutex(); 
    }
 
    param->msg_strm.str("");

    param->msg_strm << "ERROR!  In `zzparse':  Rule `statement: SERVER_ZZ NOT_ZZ SHOWING_ZZ "
                    << "GLOBUS_SITE_ZZ':"
                    << endl
                    << @=$6@>
                    << endl
                    << "Will try to continue."
                    << endl;   

    lock_cerr_mutex(); 
    cerr << param->msg_strm.str();
    unlock_cerr_mutex(); 

    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

    ++errors_occurred;

};

@q **** (4) statement --> SERVER_ZZ EDITED_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCESSFULLY_ZZ  @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{EDITED\_ZZ} \.{GLOBUS\_SITE\_ZZ}
\.{STRING\_ZZ} \.{SUCCESSFULLY\_ZZ}.
\initials{LDF 2012.05.03.}

\LOG
\initials{LDF 2012.05.03.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ EDITED_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCESSFULLY_ZZ @> 
{
   
   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`SERVER_ZZ EDITED_ZZ GLOBUS_SITE_ZZ STRING_ZZ SUCCESSFULLY_ZZ'."
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "Server:  Edited Globus site `" << @=$4@> << "' successfully."
                   << endl;

   lock_cerr_mutex(); 
   cerr << param->msg_strm.str();
   unlock_cerr_mutex(); 

   log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

};

@q **** (4) statement --> SERVER_ZZ FAILED_ZZ TO_ZZ EDIT_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>
@q **** (4) INTEGER_ZZ                                                               @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{FAILED\_ZZ} \.{TO\_ZZ} \.{EDIT\_ZZ} 
\.{GLOBUS\_SITE\_ZZ}\.{STRING\_ZZ}\.{AS\_ZZ} \.{DELETED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.05.03.}

\LOG
\initials{LDF 2012.05.03.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ FAILED_ZZ TO_ZZ EDIT_ZZ GLOBUS_SITE_ZZ STRING_ZZ @>@/
@=INTEGER_ZZ@>
{

   Scan_Parse_Parameter_Type *param 
      =  static_cast<Scan_Parse_Parameter_Type*>(
            zzget_extra(parameter));

   if (param->PARSER_DEBUG)
       cerr << "In `zzparse':  Rule `statement:  "
            << "`SERVER_ZZ FAILED_ZZ TO_ZZ EDIT_ZZ GLOBUS_SITE_ZZ STRING_ZZ "
            << "INTEGER_ZZ'."
            << endl 
            << "`INTEGER_ZZ' == " << @=$7@>
            << endl;

   param->msg_strm.str("");

   param->msg_strm << "WARNING!  Server failed to edit Globus site `" << @=$6@> 
                   << "':"
                   << endl;

   if (@=$7@> == 1)
      param->msg_strm << "Server-side MySQL error.";

   else if (@=$7@> == 2)
      param->msg_strm << "User not permitted to edit Globus site `" << @=$6@> << "'.";

   else if (@=$7@> == 3)
      param->msg_strm << "Globus site `" << @=$6@> << "' unknown.";

   else if (@=$7@> == 4)
      param->msg_strm << "No options set.";

   else if (@=$7@> == 5)
      param->msg_strm << "Options specified cause no change to Globus site `" << @=$6@> << "'.  "
                      << "Database entry not updated.";

   else
      param->msg_strm << "Unspecified server-side error.";

   param->msg_strm << endl 
                   << "Continuing."
                   << endl;

   cerr << param->msg_strm.str();
   log_strm << param->msg_strm.str();
   err_log_strm << param->msg_strm.str();

   param->msg_strm.str("");
   param->entry_string_vector.clear();

   ++warnings_occurred;

};

@q **** (4) statement:  SERVER_ZZ SENDING_ZZ PRIVILEGES_ZZ INFO_ZZ @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SENDING\_ZZ} \.{PRIVILEGES\_ZZ} 
\.{INFO\_ZZ}
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SENDING_ZZ PRIVILEGES_ZZ INFO_ZZ @>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ SENDING_ZZ PRIVILEGES_ZZ INFO_ZZ'." 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    int status = accept_data(param, 
                             0,
                             -1, 
                             Response_Type::SHOW_PRIVILEGES_TYPE);

};

@q **** (4) statement:  SERVER_ZZ SHOW_ZZ PRIVILEGES_ZZ FAILED_ZZ INTEGER_ZZ.  @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SHOW\_ZZ} \.{PRIVILEGES\_ZZ} 
\.{FAILED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.05.07.}

\LOG
\initials{LDF 2012.05.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SHOW_ZZ PRIVILEGES_ZZ FAILED_ZZ INTEGER_ZZ@>
{

    Scan_Parse_Parameter_Type *param = 
       static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex();
        cerr << "[Thread " << param->thread_ctr 
             << "] In `zzparse':  `statement:  SERVER_ZZ SHOW_ZZ "
             << "PRIVILEGES_ZZ FAILED_ZZ INTEGER_ZZ'." 
             << endl
             << "`INTEGER_ZZ' (error code) == " << @=$5@> 
             << endl;
        unlock_cerr_mutex();

    }  /* |if (param->PARSER_DEBUG)|  */

    param->msg_strm.str("");

    string temp_str = "In `zzparse':  Rule `statement:  ";
    temp_str += "SERVER_ZZ SHOW_ZZ PRIVILEGES_ZZ FAILED_ZZ INTEGER_ZZ':\n";

    if (@=$5@> == 0)
    {
        param->msg_strm << "ERROR!  " << temp_str << "No privileges found for user.  "
                        << "Can't show privileges of user or other users.";

        ++errors_occurred;
    }

    else if (@=$5@> == 1)
    {
        param->msg_strm << "ERROR!  " << temp_str 
                        << "Server-side MySQL error.  Can't show privileges.";

        ++errors_occurred;
    }

    else if (@=$5@> == 2)
    {
        param->msg_strm << "WARNING!  " << temp_str 
                        << "User not permitted to view privileges for other users.";
        ++warnings_occurred;
    }

@
\vskip\baselineskip
\halign{#:\quad&#\hfil\cr
%
{\bf Other error codes}\span\cr
\noalign{\vskip.5\baselineskip}
%
3&|mkstemp| failed to open a temporary file.\cr
%
4&Set by |exchange_data_with_client|:\cr
\omit&This function succeeded, but |strlen(buffer) > 0| and |response.local_filename|
is not empty upon return.\cr
\omit&This isn't supposed to happen.\cr
}
\noindent
These errors are not relevant for the user on the client-side,
so no special messages are issued here.
\initials{LDF 2012.05.08.}

@<Rules@>=

    else 
    {
        param->msg_strm << "ERROR!  " << temp_str 
                        << "Unspecified server-side error.  Can't show privileges.";
        ++errors_occurred;
    }

    param->msg_strm << endl << "Continuing." << endl;

    cerr << param->msg_strm.str();
    err_log_strm << param->msg_strm.str();
    log_strm << param->msg_strm.str();

    param->msg_strm.str("");

};

@q *** (3) @>

@q ** (2) @>

@ Putting the client parser ({\tt prsrclnt}) together.
@c
@=%{@>
@<Include files@>@;@/
using namespace std;
@<Declarations of additional functions@>@;@/
@=%}@>
@<Options@>@;@/
@<|union| declaration@>@;@/
@<Token and type declarations@>@;@/
@<Type declarations for non-terminal symbols@>@;@/
@=%%@>
@q Rules @>
@<Rules@>@;@/

@q * (1) Emacs-Lisp code for use in indirect buffers  @>

@q (progn (cweb-mode) (outline-minor-mode) (setq abbrev-mode t)  @>

@q * (1) Local variables for Emacs @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q abbrev-mode:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>

